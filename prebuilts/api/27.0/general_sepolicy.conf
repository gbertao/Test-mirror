#line 1 "system/sepolicy/private/security_classes"
# FLASK

#
# Define the security object classes
#

# Classes marked as userspace are classes
# for userspace object managers

class security
class process
class system
class capability

# file-related classes
class filesystem
class file
class dir
class fd
class lnk_file
class chr_file
class blk_file
class sock_file
class fifo_file

# network-related classes
class socket
class tcp_socket
class udp_socket
class rawip_socket
class node
class netif
class netlink_socket
class packet_socket
class key_socket
class unix_stream_socket
class unix_dgram_socket

# sysv-ipc-related classes
class sem
class msg
class msgq
class shm
class ipc

# extended netlink sockets
class netlink_route_socket
class netlink_tcpdiag_socket
class netlink_nflog_socket
class netlink_xfrm_socket
class netlink_selinux_socket
class netlink_audit_socket
class netlink_dnrt_socket

# IPSec association
class association

# Updated Netlink class for KOBJECT_UEVENT family.
class netlink_kobject_uevent_socket

class appletalk_socket

class packet

# Kernel access key retention
class key

class dccp_socket

class memprotect

# network peer labels
class peer

# Capabilities >= 32
class capability2

# kernel services that need to override task security, e.g. cachefiles
class kernel_service

class tun_socket

class binder

# Updated netlink classes for more recent netlink protocols.
class netlink_iscsi_socket
class netlink_fib_lookup_socket
class netlink_connector_socket
class netlink_netfilter_socket
class netlink_generic_socket
class netlink_scsitransport_socket
class netlink_rdma_socket
class netlink_crypto_socket

# Capability checks when on a non-init user namespace
class cap_userns
class cap2_userns

# New socket classes introduced by extended_socket_class policy capability.
# These two were previously mapped to rawip_socket.
class sctp_socket
class icmp_socket
# These were previously mapped to socket.
class ax25_socket
class ipx_socket
class netrom_socket
class atmpvc_socket
class x25_socket
class rose_socket
class decnet_socket
class atmsvc_socket
class rds_socket
class irda_socket
class pppox_socket
class llc_socket
class can_socket
class tipc_socket
class bluetooth_socket
class iucv_socket
class rxrpc_socket
class isdn_socket
class phonet_socket
class ieee802154_socket
class caif_socket
class alg_socket
class nfc_socket
class vsock_socket
class kcm_socket
class qipcrtr_socket
class smc_socket

# Property service
class property_service          # userspace

# Service manager
class service_manager           # userspace

# hardware service manager      # userspace
class hwservice_manager

# Keystore Key
class keystore_key              # userspace

class drmservice                # userspace
# FLASK
#line 1 "system/sepolicy/private/initial_sids"
# FLASK

#
# Define initial security identifiers
#

sid kernel
sid security
sid unlabeled
sid fs
sid file
sid file_labels
sid init
sid any_socket
sid port
sid netif
sid netmsg
sid node
sid igmp_packet
sid icmp_socket
sid tcp_socket
sid sysctl_modprobe
sid sysctl
sid sysctl_fs
sid sysctl_kernel
sid sysctl_net
sid sysctl_net_unix
sid sysctl_vm
sid sysctl_dev
sid kmod
sid policy
sid scmp_packet
sid devnull

# FLASK
#line 1 "system/sepolicy/private/access_vectors"
#
# Define common prefixes for access vectors
#
# common common_name { permission_name ... }


#
# Define a common prefix for file access vectors.
#

common file
{
	ioctl
	read
	write
	create
	getattr
	setattr
	lock
	relabelfrom
	relabelto
	append
	map
	unlink
	link
	rename
	execute
	quotaon
	mounton
}


#
# Define a common prefix for socket access vectors.
#

common socket
{
# inherited from file
	ioctl
	read
	write
	create
	getattr
	setattr
	lock
	relabelfrom
	relabelto
	append
	map
# socket-specific
	bind
	connect
	listen
	accept
	getopt
	setopt
	shutdown
	recvfrom
	sendto
	name_bind
}

#
# Define a common prefix for ipc access vectors.
#

common ipc
{
	create
	destroy
	getattr
	setattr
	read
	write
	associate
	unix_read
	unix_write
}

#
# Define a common for capability access vectors.
#
common cap
{
	# The capabilities are defined in include/linux/capability.h
	# Capabilities >= 32 are defined in the cap2 common.
	# Care should be taken to ensure that these are consistent with
	# those definitions. (Order matters)

	chown
	dac_override
	dac_read_search
	fowner
	fsetid
	kill
	setgid
	setuid
	setpcap
	linux_immutable
	net_bind_service
	net_broadcast
	net_admin
	net_raw
	ipc_lock
	ipc_owner
	sys_module
	sys_rawio
	sys_chroot
	sys_ptrace
	sys_pacct
	sys_admin
	sys_boot
	sys_nice
	sys_resource
	sys_time
	sys_tty_config
	mknod
	lease
	audit_write
	audit_control
	setfcap
}

common cap2
{
	mac_override	# unused by SELinux
	mac_admin	# unused by SELinux
	syslog
	wake_alarm
	block_suspend
	audit_read
}

#
# Define the access vectors.
#
# class class_name [ inherits common_name ] { permission_name ... }


#
# Define the access vector interpretation for file-related objects.
#

class filesystem
{
	mount
	remount
	unmount
	getattr
	relabelfrom
	relabelto
	associate
	quotamod
	quotaget
}

class dir
inherits file
{
	add_name
	remove_name
	reparent
	search
	rmdir
	open
	audit_access
	execmod
}

class file
inherits file
{
	execute_no_trans
	entrypoint
	execmod
	open
	audit_access
}

class lnk_file
inherits file
{
	open
	audit_access
	execmod
}

class chr_file
inherits file
{
	execute_no_trans
	entrypoint
	execmod
	open
	audit_access
}

class blk_file
inherits file
{
	open
	audit_access
	execmod
}

class sock_file
inherits file
{
	open
	audit_access
	execmod
}

class fifo_file
inherits file
{
	open
	audit_access
	execmod
}

class fd
{
	use
}


#
# Define the access vector interpretation for network-related objects.
#

class socket
inherits socket

class tcp_socket
inherits socket
{
	node_bind
	name_connect
}

class udp_socket
inherits socket
{
	node_bind
}

class rawip_socket
inherits socket
{
	node_bind
}

class node
{
	recvfrom
	sendto
}

class netif
{
	ingress
	egress
}

class netlink_socket
inherits socket

class packet_socket
inherits socket

class key_socket
inherits socket

class unix_stream_socket
inherits socket
{
	connectto
}

class unix_dgram_socket
inherits socket

#
# Define the access vector interpretation for process-related objects
#

class process
{
	fork
	transition
	sigchld # commonly granted from child to parent
	sigkill # cannot be caught or ignored
	sigstop # cannot be caught or ignored
	signull # for kill(pid, 0)
	signal  # all other signals
	ptrace
	getsched
	setsched
	getsession
	getpgid
	setpgid
	getcap
	setcap
	share
	getattr
	setexec
	setfscreate
	noatsecure
	siginh
	setrlimit
	rlimitinh
	dyntransition
	setcurrent
	execmem
	execstack
	execheap
	setkeycreate
	setsockcreate
	getrlimit
}


#
# Define the access vector interpretation for ipc-related objects
#

class ipc
inherits ipc

class sem
inherits ipc

class msgq
inherits ipc
{
	enqueue
}

class msg
{
	send
	receive
}

class shm
inherits ipc
{
	lock
}


#
# Define the access vector interpretation for the security server.
#

class security
{
	compute_av
	compute_create
	compute_member
	check_context
	load_policy
	compute_relabel
	compute_user
	setenforce     # was avc_toggle in system class
	setbool
	setsecparam
	setcheckreqprot
	read_policy
	validate_trans
}


#
# Define the access vector interpretation for system operations.
#

class system
{
	ipc_info
	syslog_read
	syslog_mod
	syslog_console
	module_request
	module_load
}

#
# Define the access vector interpretation for controlling capabilities
#

class capability
inherits cap

class capability2
inherits cap2

#
# Extended Netlink classes
#
class netlink_route_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_tcpdiag_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_nflog_socket
inherits socket

class netlink_xfrm_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
}

class netlink_selinux_socket
inherits socket

class netlink_audit_socket
inherits socket
{
	nlmsg_read
	nlmsg_write
	nlmsg_relay
	nlmsg_readpriv
	nlmsg_tty_audit
}

class netlink_dnrt_socket
inherits socket

# Define the access vector interpretation for controlling
# access to IPSec network data by association
#
class association
{
	sendto
	recvfrom
	setcontext
	polmatch
}

# Updated Netlink class for KOBJECT_UEVENT family.
class netlink_kobject_uevent_socket
inherits socket

class appletalk_socket
inherits socket

class packet
{
	send
	recv
	relabelto
	flow_in		# deprecated
	flow_out	# deprecated
	forward_in
	forward_out
}

class key
{
	view
	read
	write
	search
	link
	setattr
	create
}

class dccp_socket
inherits socket
{
	node_bind
	name_connect
}

class memprotect
{
	mmap_zero
}

# network peer labels
class peer
{
	recv
}

class kernel_service
{
	use_as_override
	create_files_as
}

class tun_socket
inherits socket
{
	attach_queue
}

class binder
{
	impersonate
	call
	set_context_mgr
	transfer
}

class netlink_iscsi_socket
inherits socket

class netlink_fib_lookup_socket
inherits socket

class netlink_connector_socket
inherits socket

class netlink_netfilter_socket
inherits socket

class netlink_generic_socket
inherits socket

class netlink_scsitransport_socket
inherits socket

class netlink_rdma_socket
inherits socket

class netlink_crypto_socket
inherits socket

#
# Define the access vector interpretation for controlling capabilities
# in user namespaces
#

class cap_userns
inherits cap

class cap2_userns
inherits cap2


#
# Define the access vector interpretation for the new socket classes
# enabled by the extended_socket_class policy capability.
#

#
# The next two classes were previously mapped to rawip_socket and therefore
# have the same definition as rawip_socket (until further permissions
# are defined).
#
class sctp_socket
inherits socket
{
	node_bind
}

class icmp_socket
inherits socket
{
	node_bind
}

#
# The remaining network socket classes were previously
# mapped to the socket class and therefore have the
# same definition as socket.
#

class ax25_socket
inherits socket

class ipx_socket
inherits socket

class netrom_socket
inherits socket

class atmpvc_socket
inherits socket

class x25_socket
inherits socket

class rose_socket
inherits socket

class decnet_socket
inherits socket

class atmsvc_socket
inherits socket

class rds_socket
inherits socket

class irda_socket
inherits socket

class pppox_socket
inherits socket

class llc_socket
inherits socket

class can_socket
inherits socket

class tipc_socket
inherits socket

class bluetooth_socket
inherits socket

class iucv_socket
inherits socket

class rxrpc_socket
inherits socket

class isdn_socket
inherits socket

class phonet_socket
inherits socket

class ieee802154_socket
inherits socket

class caif_socket
inherits socket

class alg_socket
inherits socket

class nfc_socket
inherits socket

class vsock_socket
inherits socket

class kcm_socket
inherits socket

class qipcrtr_socket
inherits socket

class smc_socket
inherits socket

class property_service
{
	set
}

class service_manager
{
	add
	find
	list
}

class hwservice_manager
{
	add
	find
	list
}

class keystore_key
{
	get_state
	get
	insert
	delete
	exist
	list
	reset
	password
	lock
	unlock
	is_empty
	sign
	verify
	grant
	duplicate
	clear_uid
	add_auth
	user_changed
	gen_unique_id
}

class drmservice {
	consumeRights
	setPlaybackStatus
	openDecryptSession
	closeDecryptSession
	initializeDecryptUnit
	decrypt
	finalizeDecryptUnit
	pread
}
#line 1 "system/sepolicy/public/global_macros"
#####################################
# Common groupings of object classes.
#














#####################################
# Common groupings of permissions.
#




















#####################################
# Common socket permission sets.






#line 1 "system/sepolicy/public/neverallow_macros"
#
# Common neverallow permissions





#####################################
# neverallow_establish_socket_comms(src, dst)
# neverallow src domain establishing socket connections to dst domain.
#
#line 15

#line 1 "system/sepolicy/private/mls_macros"
########################################
#
# gen_cats(N)
#
# declares categores c0 to c(N-1)
#
#line 10




########################################
#
# gen_sens(N)
#
# declares sensitivites s0 to s(N-1) with dominance
# in increasing numeric order with s0 lowest, s(N-1) highest
#
#line 24




#line 34


########################################
#
# gen_levels(N,M)
#
# levels from s0 to (N-1) with categories c0 to (M-1)
#
#line 45




########################################
#
# Basic level names for system low and high
#


#line 1 "system/sepolicy/private/mls_decl"
#########################################
# MLS declarations
#

# Generate the desired number of sensitivities and categories.

#line 6
# Each sensitivity has a name and zero or more aliases.
#line 6
sensitivity s0;
#line 6

#line 6

#line 6
# Define the ordering of the sensitivity levels (least to greatest)
#line 6
dominance { s0  }
#line 6

category c0;
#line 7
category c1;
#line 7
category c2;
#line 7
category c3;
#line 7
category c4;
#line 7
category c5;
#line 7
category c6;
#line 7
category c7;
#line 7
category c8;
#line 7
category c9;
#line 7
category c10;
#line 7
category c11;
#line 7
category c12;
#line 7
category c13;
#line 7
category c14;
#line 7
category c15;
#line 7
category c16;
#line 7
category c17;
#line 7
category c18;
#line 7
category c19;
#line 7
category c20;
#line 7
category c21;
#line 7
category c22;
#line 7
category c23;
#line 7
category c24;
#line 7
category c25;
#line 7
category c26;
#line 7
category c27;
#line 7
category c28;
#line 7
category c29;
#line 7
category c30;
#line 7
category c31;
#line 7
category c32;
#line 7
category c33;
#line 7
category c34;
#line 7
category c35;
#line 7
category c36;
#line 7
category c37;
#line 7
category c38;
#line 7
category c39;
#line 7
category c40;
#line 7
category c41;
#line 7
category c42;
#line 7
category c43;
#line 7
category c44;
#line 7
category c45;
#line 7
category c46;
#line 7
category c47;
#line 7
category c48;
#line 7
category c49;
#line 7
category c50;
#line 7
category c51;
#line 7
category c52;
#line 7
category c53;
#line 7
category c54;
#line 7
category c55;
#line 7
category c56;
#line 7
category c57;
#line 7
category c58;
#line 7
category c59;
#line 7
category c60;
#line 7
category c61;
#line 7
category c62;
#line 7
category c63;
#line 7
category c64;
#line 7
category c65;
#line 7
category c66;
#line 7
category c67;
#line 7
category c68;
#line 7
category c69;
#line 7
category c70;
#line 7
category c71;
#line 7
category c72;
#line 7
category c73;
#line 7
category c74;
#line 7
category c75;
#line 7
category c76;
#line 7
category c77;
#line 7
category c78;
#line 7
category c79;
#line 7
category c80;
#line 7
category c81;
#line 7
category c82;
#line 7
category c83;
#line 7
category c84;
#line 7
category c85;
#line 7
category c86;
#line 7
category c87;
#line 7
category c88;
#line 7
category c89;
#line 7
category c90;
#line 7
category c91;
#line 7
category c92;
#line 7
category c93;
#line 7
category c94;
#line 7
category c95;
#line 7
category c96;
#line 7
category c97;
#line 7
category c98;
#line 7
category c99;
#line 7
category c100;
#line 7
category c101;
#line 7
category c102;
#line 7
category c103;
#line 7
category c104;
#line 7
category c105;
#line 7
category c106;
#line 7
category c107;
#line 7
category c108;
#line 7
category c109;
#line 7
category c110;
#line 7
category c111;
#line 7
category c112;
#line 7
category c113;
#line 7
category c114;
#line 7
category c115;
#line 7
category c116;
#line 7
category c117;
#line 7
category c118;
#line 7
category c119;
#line 7
category c120;
#line 7
category c121;
#line 7
category c122;
#line 7
category c123;
#line 7
category c124;
#line 7
category c125;
#line 7
category c126;
#line 7
category c127;
#line 7
category c128;
#line 7
category c129;
#line 7
category c130;
#line 7
category c131;
#line 7
category c132;
#line 7
category c133;
#line 7
category c134;
#line 7
category c135;
#line 7
category c136;
#line 7
category c137;
#line 7
category c138;
#line 7
category c139;
#line 7
category c140;
#line 7
category c141;
#line 7
category c142;
#line 7
category c143;
#line 7
category c144;
#line 7
category c145;
#line 7
category c146;
#line 7
category c147;
#line 7
category c148;
#line 7
category c149;
#line 7
category c150;
#line 7
category c151;
#line 7
category c152;
#line 7
category c153;
#line 7
category c154;
#line 7
category c155;
#line 7
category c156;
#line 7
category c157;
#line 7
category c158;
#line 7
category c159;
#line 7
category c160;
#line 7
category c161;
#line 7
category c162;
#line 7
category c163;
#line 7
category c164;
#line 7
category c165;
#line 7
category c166;
#line 7
category c167;
#line 7
category c168;
#line 7
category c169;
#line 7
category c170;
#line 7
category c171;
#line 7
category c172;
#line 7
category c173;
#line 7
category c174;
#line 7
category c175;
#line 7
category c176;
#line 7
category c177;
#line 7
category c178;
#line 7
category c179;
#line 7
category c180;
#line 7
category c181;
#line 7
category c182;
#line 7
category c183;
#line 7
category c184;
#line 7
category c185;
#line 7
category c186;
#line 7
category c187;
#line 7
category c188;
#line 7
category c189;
#line 7
category c190;
#line 7
category c191;
#line 7
category c192;
#line 7
category c193;
#line 7
category c194;
#line 7
category c195;
#line 7
category c196;
#line 7
category c197;
#line 7
category c198;
#line 7
category c199;
#line 7
category c200;
#line 7
category c201;
#line 7
category c202;
#line 7
category c203;
#line 7
category c204;
#line 7
category c205;
#line 7
category c206;
#line 7
category c207;
#line 7
category c208;
#line 7
category c209;
#line 7
category c210;
#line 7
category c211;
#line 7
category c212;
#line 7
category c213;
#line 7
category c214;
#line 7
category c215;
#line 7
category c216;
#line 7
category c217;
#line 7
category c218;
#line 7
category c219;
#line 7
category c220;
#line 7
category c221;
#line 7
category c222;
#line 7
category c223;
#line 7
category c224;
#line 7
category c225;
#line 7
category c226;
#line 7
category c227;
#line 7
category c228;
#line 7
category c229;
#line 7
category c230;
#line 7
category c231;
#line 7
category c232;
#line 7
category c233;
#line 7
category c234;
#line 7
category c235;
#line 7
category c236;
#line 7
category c237;
#line 7
category c238;
#line 7
category c239;
#line 7
category c240;
#line 7
category c241;
#line 7
category c242;
#line 7
category c243;
#line 7
category c244;
#line 7
category c245;
#line 7
category c246;
#line 7
category c247;
#line 7
category c248;
#line 7
category c249;
#line 7
category c250;
#line 7
category c251;
#line 7
category c252;
#line 7
category c253;
#line 7
category c254;
#line 7
category c255;
#line 7
category c256;
#line 7
category c257;
#line 7
category c258;
#line 7
category c259;
#line 7
category c260;
#line 7
category c261;
#line 7
category c262;
#line 7
category c263;
#line 7
category c264;
#line 7
category c265;
#line 7
category c266;
#line 7
category c267;
#line 7
category c268;
#line 7
category c269;
#line 7
category c270;
#line 7
category c271;
#line 7
category c272;
#line 7
category c273;
#line 7
category c274;
#line 7
category c275;
#line 7
category c276;
#line 7
category c277;
#line 7
category c278;
#line 7
category c279;
#line 7
category c280;
#line 7
category c281;
#line 7
category c282;
#line 7
category c283;
#line 7
category c284;
#line 7
category c285;
#line 7
category c286;
#line 7
category c287;
#line 7
category c288;
#line 7
category c289;
#line 7
category c290;
#line 7
category c291;
#line 7
category c292;
#line 7
category c293;
#line 7
category c294;
#line 7
category c295;
#line 7
category c296;
#line 7
category c297;
#line 7
category c298;
#line 7
category c299;
#line 7
category c300;
#line 7
category c301;
#line 7
category c302;
#line 7
category c303;
#line 7
category c304;
#line 7
category c305;
#line 7
category c306;
#line 7
category c307;
#line 7
category c308;
#line 7
category c309;
#line 7
category c310;
#line 7
category c311;
#line 7
category c312;
#line 7
category c313;
#line 7
category c314;
#line 7
category c315;
#line 7
category c316;
#line 7
category c317;
#line 7
category c318;
#line 7
category c319;
#line 7
category c320;
#line 7
category c321;
#line 7
category c322;
#line 7
category c323;
#line 7
category c324;
#line 7
category c325;
#line 7
category c326;
#line 7
category c327;
#line 7
category c328;
#line 7
category c329;
#line 7
category c330;
#line 7
category c331;
#line 7
category c332;
#line 7
category c333;
#line 7
category c334;
#line 7
category c335;
#line 7
category c336;
#line 7
category c337;
#line 7
category c338;
#line 7
category c339;
#line 7
category c340;
#line 7
category c341;
#line 7
category c342;
#line 7
category c343;
#line 7
category c344;
#line 7
category c345;
#line 7
category c346;
#line 7
category c347;
#line 7
category c348;
#line 7
category c349;
#line 7
category c350;
#line 7
category c351;
#line 7
category c352;
#line 7
category c353;
#line 7
category c354;
#line 7
category c355;
#line 7
category c356;
#line 7
category c357;
#line 7
category c358;
#line 7
category c359;
#line 7
category c360;
#line 7
category c361;
#line 7
category c362;
#line 7
category c363;
#line 7
category c364;
#line 7
category c365;
#line 7
category c366;
#line 7
category c367;
#line 7
category c368;
#line 7
category c369;
#line 7
category c370;
#line 7
category c371;
#line 7
category c372;
#line 7
category c373;
#line 7
category c374;
#line 7
category c375;
#line 7
category c376;
#line 7
category c377;
#line 7
category c378;
#line 7
category c379;
#line 7
category c380;
#line 7
category c381;
#line 7
category c382;
#line 7
category c383;
#line 7
category c384;
#line 7
category c385;
#line 7
category c386;
#line 7
category c387;
#line 7
category c388;
#line 7
category c389;
#line 7
category c390;
#line 7
category c391;
#line 7
category c392;
#line 7
category c393;
#line 7
category c394;
#line 7
category c395;
#line 7
category c396;
#line 7
category c397;
#line 7
category c398;
#line 7
category c399;
#line 7
category c400;
#line 7
category c401;
#line 7
category c402;
#line 7
category c403;
#line 7
category c404;
#line 7
category c405;
#line 7
category c406;
#line 7
category c407;
#line 7
category c408;
#line 7
category c409;
#line 7
category c410;
#line 7
category c411;
#line 7
category c412;
#line 7
category c413;
#line 7
category c414;
#line 7
category c415;
#line 7
category c416;
#line 7
category c417;
#line 7
category c418;
#line 7
category c419;
#line 7
category c420;
#line 7
category c421;
#line 7
category c422;
#line 7
category c423;
#line 7
category c424;
#line 7
category c425;
#line 7
category c426;
#line 7
category c427;
#line 7
category c428;
#line 7
category c429;
#line 7
category c430;
#line 7
category c431;
#line 7
category c432;
#line 7
category c433;
#line 7
category c434;
#line 7
category c435;
#line 7
category c436;
#line 7
category c437;
#line 7
category c438;
#line 7
category c439;
#line 7
category c440;
#line 7
category c441;
#line 7
category c442;
#line 7
category c443;
#line 7
category c444;
#line 7
category c445;
#line 7
category c446;
#line 7
category c447;
#line 7
category c448;
#line 7
category c449;
#line 7
category c450;
#line 7
category c451;
#line 7
category c452;
#line 7
category c453;
#line 7
category c454;
#line 7
category c455;
#line 7
category c456;
#line 7
category c457;
#line 7
category c458;
#line 7
category c459;
#line 7
category c460;
#line 7
category c461;
#line 7
category c462;
#line 7
category c463;
#line 7
category c464;
#line 7
category c465;
#line 7
category c466;
#line 7
category c467;
#line 7
category c468;
#line 7
category c469;
#line 7
category c470;
#line 7
category c471;
#line 7
category c472;
#line 7
category c473;
#line 7
category c474;
#line 7
category c475;
#line 7
category c476;
#line 7
category c477;
#line 7
category c478;
#line 7
category c479;
#line 7
category c480;
#line 7
category c481;
#line 7
category c482;
#line 7
category c483;
#line 7
category c484;
#line 7
category c485;
#line 7
category c486;
#line 7
category c487;
#line 7
category c488;
#line 7
category c489;
#line 7
category c490;
#line 7
category c491;
#line 7
category c492;
#line 7
category c493;
#line 7
category c494;
#line 7
category c495;
#line 7
category c496;
#line 7
category c497;
#line 7
category c498;
#line 7
category c499;
#line 7
category c500;
#line 7
category c501;
#line 7
category c502;
#line 7
category c503;
#line 7
category c504;
#line 7
category c505;
#line 7
category c506;
#line 7
category c507;
#line 7
category c508;
#line 7
category c509;
#line 7
category c510;
#line 7
category c511;
#line 7
category c512;
#line 7
category c513;
#line 7
category c514;
#line 7
category c515;
#line 7
category c516;
#line 7
category c517;
#line 7
category c518;
#line 7
category c519;
#line 7
category c520;
#line 7
category c521;
#line 7
category c522;
#line 7
category c523;
#line 7
category c524;
#line 7
category c525;
#line 7
category c526;
#line 7
category c527;
#line 7
category c528;
#line 7
category c529;
#line 7
category c530;
#line 7
category c531;
#line 7
category c532;
#line 7
category c533;
#line 7
category c534;
#line 7
category c535;
#line 7
category c536;
#line 7
category c537;
#line 7
category c538;
#line 7
category c539;
#line 7
category c540;
#line 7
category c541;
#line 7
category c542;
#line 7
category c543;
#line 7
category c544;
#line 7
category c545;
#line 7
category c546;
#line 7
category c547;
#line 7
category c548;
#line 7
category c549;
#line 7
category c550;
#line 7
category c551;
#line 7
category c552;
#line 7
category c553;
#line 7
category c554;
#line 7
category c555;
#line 7
category c556;
#line 7
category c557;
#line 7
category c558;
#line 7
category c559;
#line 7
category c560;
#line 7
category c561;
#line 7
category c562;
#line 7
category c563;
#line 7
category c564;
#line 7
category c565;
#line 7
category c566;
#line 7
category c567;
#line 7
category c568;
#line 7
category c569;
#line 7
category c570;
#line 7
category c571;
#line 7
category c572;
#line 7
category c573;
#line 7
category c574;
#line 7
category c575;
#line 7
category c576;
#line 7
category c577;
#line 7
category c578;
#line 7
category c579;
#line 7
category c580;
#line 7
category c581;
#line 7
category c582;
#line 7
category c583;
#line 7
category c584;
#line 7
category c585;
#line 7
category c586;
#line 7
category c587;
#line 7
category c588;
#line 7
category c589;
#line 7
category c590;
#line 7
category c591;
#line 7
category c592;
#line 7
category c593;
#line 7
category c594;
#line 7
category c595;
#line 7
category c596;
#line 7
category c597;
#line 7
category c598;
#line 7
category c599;
#line 7
category c600;
#line 7
category c601;
#line 7
category c602;
#line 7
category c603;
#line 7
category c604;
#line 7
category c605;
#line 7
category c606;
#line 7
category c607;
#line 7
category c608;
#line 7
category c609;
#line 7
category c610;
#line 7
category c611;
#line 7
category c612;
#line 7
category c613;
#line 7
category c614;
#line 7
category c615;
#line 7
category c616;
#line 7
category c617;
#line 7
category c618;
#line 7
category c619;
#line 7
category c620;
#line 7
category c621;
#line 7
category c622;
#line 7
category c623;
#line 7
category c624;
#line 7
category c625;
#line 7
category c626;
#line 7
category c627;
#line 7
category c628;
#line 7
category c629;
#line 7
category c630;
#line 7
category c631;
#line 7
category c632;
#line 7
category c633;
#line 7
category c634;
#line 7
category c635;
#line 7
category c636;
#line 7
category c637;
#line 7
category c638;
#line 7
category c639;
#line 7
category c640;
#line 7
category c641;
#line 7
category c642;
#line 7
category c643;
#line 7
category c644;
#line 7
category c645;
#line 7
category c646;
#line 7
category c647;
#line 7
category c648;
#line 7
category c649;
#line 7
category c650;
#line 7
category c651;
#line 7
category c652;
#line 7
category c653;
#line 7
category c654;
#line 7
category c655;
#line 7
category c656;
#line 7
category c657;
#line 7
category c658;
#line 7
category c659;
#line 7
category c660;
#line 7
category c661;
#line 7
category c662;
#line 7
category c663;
#line 7
category c664;
#line 7
category c665;
#line 7
category c666;
#line 7
category c667;
#line 7
category c668;
#line 7
category c669;
#line 7
category c670;
#line 7
category c671;
#line 7
category c672;
#line 7
category c673;
#line 7
category c674;
#line 7
category c675;
#line 7
category c676;
#line 7
category c677;
#line 7
category c678;
#line 7
category c679;
#line 7
category c680;
#line 7
category c681;
#line 7
category c682;
#line 7
category c683;
#line 7
category c684;
#line 7
category c685;
#line 7
category c686;
#line 7
category c687;
#line 7
category c688;
#line 7
category c689;
#line 7
category c690;
#line 7
category c691;
#line 7
category c692;
#line 7
category c693;
#line 7
category c694;
#line 7
category c695;
#line 7
category c696;
#line 7
category c697;
#line 7
category c698;
#line 7
category c699;
#line 7
category c700;
#line 7
category c701;
#line 7
category c702;
#line 7
category c703;
#line 7
category c704;
#line 7
category c705;
#line 7
category c706;
#line 7
category c707;
#line 7
category c708;
#line 7
category c709;
#line 7
category c710;
#line 7
category c711;
#line 7
category c712;
#line 7
category c713;
#line 7
category c714;
#line 7
category c715;
#line 7
category c716;
#line 7
category c717;
#line 7
category c718;
#line 7
category c719;
#line 7
category c720;
#line 7
category c721;
#line 7
category c722;
#line 7
category c723;
#line 7
category c724;
#line 7
category c725;
#line 7
category c726;
#line 7
category c727;
#line 7
category c728;
#line 7
category c729;
#line 7
category c730;
#line 7
category c731;
#line 7
category c732;
#line 7
category c733;
#line 7
category c734;
#line 7
category c735;
#line 7
category c736;
#line 7
category c737;
#line 7
category c738;
#line 7
category c739;
#line 7
category c740;
#line 7
category c741;
#line 7
category c742;
#line 7
category c743;
#line 7
category c744;
#line 7
category c745;
#line 7
category c746;
#line 7
category c747;
#line 7
category c748;
#line 7
category c749;
#line 7
category c750;
#line 7
category c751;
#line 7
category c752;
#line 7
category c753;
#line 7
category c754;
#line 7
category c755;
#line 7
category c756;
#line 7
category c757;
#line 7
category c758;
#line 7
category c759;
#line 7
category c760;
#line 7
category c761;
#line 7
category c762;
#line 7
category c763;
#line 7
category c764;
#line 7
category c765;
#line 7
category c766;
#line 7
category c767;
#line 7
category c768;
#line 7
category c769;
#line 7
category c770;
#line 7
category c771;
#line 7
category c772;
#line 7
category c773;
#line 7
category c774;
#line 7
category c775;
#line 7
category c776;
#line 7
category c777;
#line 7
category c778;
#line 7
category c779;
#line 7
category c780;
#line 7
category c781;
#line 7
category c782;
#line 7
category c783;
#line 7
category c784;
#line 7
category c785;
#line 7
category c786;
#line 7
category c787;
#line 7
category c788;
#line 7
category c789;
#line 7
category c790;
#line 7
category c791;
#line 7
category c792;
#line 7
category c793;
#line 7
category c794;
#line 7
category c795;
#line 7
category c796;
#line 7
category c797;
#line 7
category c798;
#line 7
category c799;
#line 7
category c800;
#line 7
category c801;
#line 7
category c802;
#line 7
category c803;
#line 7
category c804;
#line 7
category c805;
#line 7
category c806;
#line 7
category c807;
#line 7
category c808;
#line 7
category c809;
#line 7
category c810;
#line 7
category c811;
#line 7
category c812;
#line 7
category c813;
#line 7
category c814;
#line 7
category c815;
#line 7
category c816;
#line 7
category c817;
#line 7
category c818;
#line 7
category c819;
#line 7
category c820;
#line 7
category c821;
#line 7
category c822;
#line 7
category c823;
#line 7
category c824;
#line 7
category c825;
#line 7
category c826;
#line 7
category c827;
#line 7
category c828;
#line 7
category c829;
#line 7
category c830;
#line 7
category c831;
#line 7
category c832;
#line 7
category c833;
#line 7
category c834;
#line 7
category c835;
#line 7
category c836;
#line 7
category c837;
#line 7
category c838;
#line 7
category c839;
#line 7
category c840;
#line 7
category c841;
#line 7
category c842;
#line 7
category c843;
#line 7
category c844;
#line 7
category c845;
#line 7
category c846;
#line 7
category c847;
#line 7
category c848;
#line 7
category c849;
#line 7
category c850;
#line 7
category c851;
#line 7
category c852;
#line 7
category c853;
#line 7
category c854;
#line 7
category c855;
#line 7
category c856;
#line 7
category c857;
#line 7
category c858;
#line 7
category c859;
#line 7
category c860;
#line 7
category c861;
#line 7
category c862;
#line 7
category c863;
#line 7
category c864;
#line 7
category c865;
#line 7
category c866;
#line 7
category c867;
#line 7
category c868;
#line 7
category c869;
#line 7
category c870;
#line 7
category c871;
#line 7
category c872;
#line 7
category c873;
#line 7
category c874;
#line 7
category c875;
#line 7
category c876;
#line 7
category c877;
#line 7
category c878;
#line 7
category c879;
#line 7
category c880;
#line 7
category c881;
#line 7
category c882;
#line 7
category c883;
#line 7
category c884;
#line 7
category c885;
#line 7
category c886;
#line 7
category c887;
#line 7
category c888;
#line 7
category c889;
#line 7
category c890;
#line 7
category c891;
#line 7
category c892;
#line 7
category c893;
#line 7
category c894;
#line 7
category c895;
#line 7
category c896;
#line 7
category c897;
#line 7
category c898;
#line 7
category c899;
#line 7
category c900;
#line 7
category c901;
#line 7
category c902;
#line 7
category c903;
#line 7
category c904;
#line 7
category c905;
#line 7
category c906;
#line 7
category c907;
#line 7
category c908;
#line 7
category c909;
#line 7
category c910;
#line 7
category c911;
#line 7
category c912;
#line 7
category c913;
#line 7
category c914;
#line 7
category c915;
#line 7
category c916;
#line 7
category c917;
#line 7
category c918;
#line 7
category c919;
#line 7
category c920;
#line 7
category c921;
#line 7
category c922;
#line 7
category c923;
#line 7
category c924;
#line 7
category c925;
#line 7
category c926;
#line 7
category c927;
#line 7
category c928;
#line 7
category c929;
#line 7
category c930;
#line 7
category c931;
#line 7
category c932;
#line 7
category c933;
#line 7
category c934;
#line 7
category c935;
#line 7
category c936;
#line 7
category c937;
#line 7
category c938;
#line 7
category c939;
#line 7
category c940;
#line 7
category c941;
#line 7
category c942;
#line 7
category c943;
#line 7
category c944;
#line 7
category c945;
#line 7
category c946;
#line 7
category c947;
#line 7
category c948;
#line 7
category c949;
#line 7
category c950;
#line 7
category c951;
#line 7
category c952;
#line 7
category c953;
#line 7
category c954;
#line 7
category c955;
#line 7
category c956;
#line 7
category c957;
#line 7
category c958;
#line 7
category c959;
#line 7
category c960;
#line 7
category c961;
#line 7
category c962;
#line 7
category c963;
#line 7
category c964;
#line 7
category c965;
#line 7
category c966;
#line 7
category c967;
#line 7
category c968;
#line 7
category c969;
#line 7
category c970;
#line 7
category c971;
#line 7
category c972;
#line 7
category c973;
#line 7
category c974;
#line 7
category c975;
#line 7
category c976;
#line 7
category c977;
#line 7
category c978;
#line 7
category c979;
#line 7
category c980;
#line 7
category c981;
#line 7
category c982;
#line 7
category c983;
#line 7
category c984;
#line 7
category c985;
#line 7
category c986;
#line 7
category c987;
#line 7
category c988;
#line 7
category c989;
#line 7
category c990;
#line 7
category c991;
#line 7
category c992;
#line 7
category c993;
#line 7
category c994;
#line 7
category c995;
#line 7
category c996;
#line 7
category c997;
#line 7
category c998;
#line 7
category c999;
#line 7
category c1000;
#line 7
category c1001;
#line 7
category c1002;
#line 7
category c1003;
#line 7
category c1004;
#line 7
category c1005;
#line 7
category c1006;
#line 7
category c1007;
#line 7
category c1008;
#line 7
category c1009;
#line 7
category c1010;
#line 7
category c1011;
#line 7
category c1012;
#line 7
category c1013;
#line 7
category c1014;
#line 7
category c1015;
#line 7
category c1016;
#line 7
category c1017;
#line 7
category c1018;
#line 7
category c1019;
#line 7
category c1020;
#line 7
category c1021;
#line 7
category c1022;
#line 7
category c1023;
#line 7


# Generate level definitions for each sensitivity and category.
level s0:c0.c1023;
#line 10

#line 1 "system/sepolicy/private/mls"
#################################################
# MLS policy constraints
#

#
# Process constraints
#

# Process transition:  Require equivalence unless the subject is trusted.
mlsconstrain process { transition dyntransition }
	     ((h1 eq h2 and l1 eq l2) or t1 == mlstrustedsubject);

# Process read operations: No read up unless trusted.
mlsconstrain process { getsched getsession getpgid getcap getattr ptrace share }
	     (l1 dom l2 or t1 == mlstrustedsubject);

# Process write operations:  Require equivalence unless trusted.
mlsconstrain process { sigkill sigstop signal setsched setpgid setcap setrlimit ptrace share }
	     (l1 eq l2 or t1 == mlstrustedsubject);

#
# Socket constraints
#

# Create/relabel operations:  Subject must be equivalent to object unless
# the subject is trusted.  Sockets inherit the range of their creator.
mlsconstrain { socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket } { create relabelfrom relabelto }
	     ((h1 eq h2 and l1 eq l2) or t1 == mlstrustedsubject);

# Datagram send: Sender must be equivalent to the receiver unless one of them
# is trusted.
mlsconstrain unix_dgram_socket { sendto }
	     (l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);

# Stream connect:  Client must be equivalent to server unless one of them
# is trusted.
mlsconstrain unix_stream_socket { connectto }
	     (l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);

#
# Directory/file constraints
#

# Create/relabel operations:  Subject must be equivalent to object unless
# the subject is trusted. Also, files should always be single-level.
# Do NOT exempt mlstrustedobject types from this constraint.
mlsconstrain { dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { create relabelfrom relabelto }
	     (l2 eq h2 and (l1 eq l2 or t1 == mlstrustedsubject));

#
# Constraints for app data files only.
#

# Only constrain open, not read/write.
# Also constrain other forms of manipulation, e.g. chmod/chown, unlink, rename, etc.
# Subject must be equivalent to object unless the subject is trusted.
mlsconstrain dir { open search setattr rename add_name remove_name reparent rmdir }
	     (t2 != app_data_file or l1 eq l2 or t1 == mlstrustedsubject);
mlsconstrain { file lnk_file sock_file } { open setattr unlink link rename }
	     (t2 != app_data_file or l1 eq l2 or t1 == mlstrustedsubject);

#
# Constraints for file types other than app data files.
#

# Read operations: Subject must dominate object unless the subject
# or the object is trusted.
mlsconstrain dir { read getattr search }
	     (t2 == app_data_file or l1 dom l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

mlsconstrain { file lnk_file sock_file chr_file blk_file } { read getattr execute }
	     (t2 == app_data_file or l1 dom l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

# Write operations: Subject must be equivalent to the object unless the
# subject or the object is trusted.
mlsconstrain dir { write setattr rename add_name remove_name reparent rmdir }
	     (t2 == app_data_file or l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

mlsconstrain { file lnk_file sock_file chr_file blk_file } { write setattr append unlink link rename }
	     (t2 == app_data_file or l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject);

# Special case for FIFOs.
# These can be unnamed pipes, in which case they will be labeled with the
# creating process' label. Thus we also have an exemption when the "object"
# is a domain type, so that processes can communicate via unnamed pipes
# passed by binder or local socket IPC.
mlsconstrain fifo_file { read getattr }
	     (l1 dom l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject or t2 == domain);

mlsconstrain fifo_file { write setattr append unlink link rename }
	     (l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedobject or t2 == domain);

#
# Binder IPC constraints
#
# Presently commented out, as apps are expected to call one another.
# This would only make sense if apps were assigned categories
# based on allowable communications rather than per-app categories.
#mlsconstrain binder call
#	(l1 eq l2 or t1 == mlstrustedsubject or t2 == mlstrustedsubject);
#line 1 "system/sepolicy/private/policy_capabilities"
# Enable new networking controls.
policycap network_peer_controls;

# Enable open permission check.
policycap open_perms;

# Enable separate security classes for
# all network address families previously
# mapped to the socket class and for
# ICMP and SCTP sockets previously mapped
# to the rawip_socket class.
policycap extended_socket_class;

#line 1 "system/sepolicy/public/te_macros"
#####################################
# domain_trans(olddomain, type, newdomain)
# Allow a transition from olddomain to newdomain
# upon executing a file labeled with type.
# This only allows the transition; it does not
# cause it to occur automatically - use domain_auto_trans
# if that is what you want.
#
#line 21


#####################################
# domain_auto_trans(olddomain, type, newdomain)
# Automatically transition from olddomain to newdomain
# upon executing a file labeled with type.
#
#line 33


#####################################
# file_type_trans(domain, dir_type, file_type)
# Allow domain to create a file labeled file_type in a
# directory labeled dir_type.
# This only allows the transition; it does not
# cause it to occur automatically - use file_type_auto_trans
# if that is what you want.
#
#line 49


#####################################
# file_type_auto_trans(domain, dir_type, file_type)
# Automatically label new files with file_type when
# they are created by domain in directories labeled dir_type.
#
#line 62


#####################################
# r_dir_file(domain, type)
# Allow the specified domain to read directories, files
# and symbolic links of the specified type.
#line 71


#####################################
# tmpfs_domain(domain)
# Define and allow access to a unique type for
# this domain when creating tmpfs / shmem / ashmem files.
#line 82


# pdx macros for IPC. pdx is a high-level name which contains transport-specific
# rules from underlying transport (e.g. UDS-based implementation).

#####################################
# pdx_service_attributes(service)
# Defines type attribute used to identify various service-related types.
#line 95


#####################################
# pdx_service_socket_types(service, endpoint_dir_t)
# Define types for endpoint and channel sockets.
#line 108


#####################################
# pdx_server(server_domain, service)
#line 127


#####################################
# pdx_connect(client, service)
#line 137


#####################################
# pdx_use(client, service)
#line 152


#####################################
# pdx_client(client, service)
#line 159


#####################################
# init_daemon_domain(domain)
# Set up a transition from init to the daemon domain
# upon executing its binary.
#line 168


#####################################
# app_domain(domain)
# Allow a base set of permissions required for all apps.
#line 179


#####################################
# untrusted_app_domain(domain)
# Allow a base set of permissions required for all untrusted apps.
#line 186


#####################################
# net_domain(domain)
# Allow a base set of permissions required for network access.
#line 193


#####################################
# bluetooth_domain(domain)
# Allow a base set of permissions required for bluetooth access.
#line 200


#####################################
# hal_server_domain(domain, hal_type)
# Allow a base set of permissions required for a domain to offer a
# HAL implementation of the specified type over HwBinder.
#
# For example, default implementation of Foo HAL:
#   type hal_foo_default, domain;
#   hal_server_domain(hal_foo_default, hal_foo)
#
#line 215


#####################################
# hal_client_domain(domain, hal_type)
# Allow a base set of permissions required for a domain to be a
# client of a HAL of the specified type.
#
# For example, make some_domain a client of Foo HAL:
#   hal_client_domain(some_domain, hal_foo)
#
#line 239


#####################################
# passthrough_hal_client_domain(domain, hal_type)
# Allow a base set of permissions required for a domain to be a
# client of a passthrough HAL of the specified type.
#
# For example, make some_domain a client of passthrough Foo HAL:
#   passthrough_hal_client_domain(some_domain, hal_foo)
#
#line 257


#####################################
# unix_socket_connect(clientdomain, socket, serverdomain)
# Allow a local socket connection from clientdomain via
# socket to serverdomain.
#
# Note: If you see denial records that distill to the
# following allow rules:
# allow clientdomain property_socket:sock_file write;
# allow clientdomain init:unix_stream_socket connectto;
# allow clientdomain something_prop:property_service set;
#
# This sequence is indicative of attempting to set a property.
# use set_prop(sourcedomain, targetproperty)
#
#line 280


#line 285


#####################################
# set_prop(sourcedomain, targetproperty)
# Allows source domain to set the
# targetproperty.
#
#line 296


#####################################
# get_prop(sourcedomain, targetproperty)
# Allows source domain to read the
# targetproperty.
#
#line 305


#####################################
# unix_socket_send(clientdomain, socket, serverdomain)
# Allow a local socket send from clientdomain via
# socket to serverdomain.
#line 314


#####################################
# binder_use(domain)
# Allow domain to use Binder IPC.
#line 328


#####################################
# hwbinder_use(domain)
# Allow domain to use HwBinder IPC.
#line 344


#####################################
# vndbinder_use(domain)
# Allow domain to use Binder IPC.
#line 358


#####################################
# binder_call(clientdomain, serverdomain)
# Allow clientdomain to perform binder IPC to serverdomain.
#line 370


#####################################
# binder_service(domain)
# Mark a domain as being a Binder service domain.
# Used to allow binder IPC to the various system services.
#line 378


#####################################
# wakelock_use(domain)
# Allow domain to manage wake locks
#line 388


#####################################
# selinux_check_access(domain)
# Allow domain to check SELinux permissions via selinuxfs.
#line 398


#####################################
# selinux_check_context(domain)
# Allow domain to check SELinux contexts via selinuxfs.
#line 407


#####################################
# create_pty(domain)
# Allow domain to create and use a pty, isolated from any other domain ptys.
#line 426


#####################################
# Non system_app application set
#


#####################################
# Recovery only
# SELinux rules which apply only to recovery mode
#


#####################################
# Full TREBLE only
# SELinux rules which apply only to full TREBLE devices
#
#line 448


#####################################
# Not full TREBLE
# SELinux rules which apply only to devices which are not full TREBLE devices
#


#####################################
# Userdebug or eng builds
# SELinux rules which apply only to userdebug or eng builds
#


#####################################
# User builds
# SELinux rules which apply only to user builds
#


#####################################
# asan builds
# SELinux rules which apply only to asan builds
#


####################################
# Fallback crash handling for processes that can't exec crash_dump (e.g. because of seccomp).
#
#line 490


#####################################
# WITH_DEXPREOPT builds
# SELinux rules which apply only when pre-opting.
#


#####################################
# write_logd(domain)
# Ability to write to android log
# daemon via sockets
#line 505


#####################################
# read_logd(domain)
# Ability to run logcat and read from android
# log daemon via sockets
#line 514


#####################################
# read_runtime_log_tags(domain)
# ability to directly map the runtime event log tags
#line 521


#####################################
# control_logd(domain)
# Ability to control
# android log daemon via sockets
#line 531


#####################################
# use_keystore(domain)
# Ability to use keystore.
# Keystore is requires the following permissions
# to call getpidcon.
#line 544


###########################################
# use_drmservice(domain)
# Ability to use DrmService which requires
# DrmService to call getpidcon.
#line 554


###########################################
# add_service(domain, service)
# Ability for domain to add a service to service_manager
# and find it. It also creates a neverallow preventing
# others from adding it.
#line 564


###########################################
# add_hwservice(domain, service)
# Ability for domain to add a service to hwservice_manager
# and find it. It also creates a neverallow preventing
# others from adding it.
#line 575


##########################################
# print a message with a trailing newline
# print(`args')
#line 581

#line 1 "system/sepolicy/public/attributes"
######################################
# Attribute declarations
#

# All types used for devices.
# On change, update CHECK_FC_ASSERT_ATTRS
# in tools/checkfc.c
attribute dev_type;

# All types used for processes.
attribute domain;

# All types used for filesystems.
# On change, update CHECK_FC_ASSERT_ATTRS
# definition in tools/checkfc.c.
attribute fs_type;

# All types used for context= mounts.
attribute contextmount_type;

# All types used for files that can exist on a labeled fs.
# Do not use for pseudo file types.
# On change, update CHECK_FC_ASSERT_ATTRS
# definition in tools/checkfc.c.
attribute file_type;

# All types used for domain entry points.
attribute exec_type;

# All types used for /data files.
attribute data_file_type;
expandattribute data_file_type false;
# All types in /data, not in /data/vendor
attribute core_data_file_type;
# All types in /vendor
attribute vendor_file_type;

# All types use for sysfs files.
attribute sysfs_type;

# All types use for debugfs files.
attribute debugfs_type;

# Attribute used for all sdcards
attribute sdcard_type;

# All types used for nodes/hosts.
attribute node_type;

# All types used for network interfaces.
attribute netif_type;

# All types used for network ports.
attribute port_type;

# All types used for property service
# On change, update CHECK_PC_ASSERT_ATTRS
# definition in tools/checkfc.c.
attribute property_type;

# All properties defined in core SELinux policy. Should not be
# used by device specific properties
attribute core_property_type;

# All properties used to configure log filtering.
attribute log_property_type;

# All service_manager types created by system_server
attribute system_server_service;

# services which should be available to all but isolated apps
attribute app_api_service;

# services which should be available to all ephemeral apps
attribute ephemeral_app_api_service;

# services which export only system_api
attribute system_api_service;

# All types used for services managed by servicemanager.
# On change, update CHECK_SC_ASSERT_ATTRS
# definition in tools/checkfc.c.
attribute service_manager_type;

# All types used for services managed by hwservicemanager
attribute hwservice_manager_type;

# All HwBinder services guaranteed to be passthrough. These services always run
# in the process of their clients, and thus operate with the same access as
# their clients.
attribute same_process_hwservice;

# All HwBinder services guaranteed to be offered only by core domain components
attribute coredomain_hwservice;

# All types used for services managed by vndservicemanager
attribute vndservice_manager_type;


# All domains that can override MLS restrictions.
# i.e. processes that can read up and write down.
attribute mlstrustedsubject;

# All types that can override MLS restrictions.
# i.e. files that can be read by lower and written by higher
attribute mlstrustedobject;

# All domains used for apps.
attribute appdomain;

# All third party apps.
attribute untrusted_app_all;

# All domains used for apps with network access.
attribute netdomain;

# All domains used for apps with bluetooth access.
attribute bluetoothdomain;

# All domains used for binder service domains.
attribute binderservicedomain;

# update_engine related domains that need to apply an update and run
# postinstall. This includes the background daemon and the sideload tool from
# recovery for A/B devices.
attribute update_engine_common;

# All core domains (as opposed to vendor/device-specific domains)
attribute coredomain;

# All socket devices owned by core domain components
attribute coredomain_socket;

# All vendor domains which violate the requirement of not using Binder
# TODO(b/35870313): Remove this once there are no violations
attribute binder_in_vendor_violators;
expandattribute binder_in_vendor_violators false;

# All vendor domains which violate the requirement of not using sockets for
# communicating with core components
# TODO(b/36577153): Remove this once there are no violations
attribute socket_between_core_and_vendor_violators;
expandattribute socket_between_core_and_vendor_violators false;

# All vendor domains which violate the requirement of not executing
# system processes
# TODO(b/36463595)
attribute vendor_executes_system_violators;
expandattribute vendor_executes_system_violators false;

# hwservices that are accessible from untrusted applications
# WARNING: Use of this attribute should be avoided unless
# absolutely necessary.  It is a temporary allowance to aid the
# transition to treble and will be removed in a future platform
# version, requiring all hwservices that are labeled with this
# attribute to be submitted to AOSP in order to maintain their
# app-visibility.
attribute untrusted_app_visible_hwservice;
expandattribute untrusted_app_visible_hwservice false;

# halserver domains that are accessible to untrusted applications.  These
# domains are typically those hosting  hwservices attributed by the
# untrusted_app_visible_hwservice.
# WARNING: Use of this attribute should be avoided unless absolutely necessary.
# It is a temporary allowance to aid the transition to treble and will be
# removed in the future platform version, requiring all halserver domains that
# are labeled with this attribute to be submitted to AOSP in order to maintain
# their app-visibility.
attribute untrusted_app_visible_halserver;
expandattribute untrusted_app_visible_halserver false;

# PDX services
attribute pdx_endpoint_dir_type;
attribute pdx_endpoint_socket_type;
expandattribute pdx_endpoint_socket_type false;
attribute pdx_channel_socket_type;
expandattribute pdx_channel_socket_type false;


#line 179
attribute pdx_display_client_endpoint_dir_type;
#line 179
attribute pdx_display_client_endpoint_socket_type;
#line 179
attribute pdx_display_client_channel_socket_type;
#line 179
attribute pdx_display_client_server_type;
#line 179


#line 180
attribute pdx_display_manager_endpoint_dir_type;
#line 180
attribute pdx_display_manager_endpoint_socket_type;
#line 180
attribute pdx_display_manager_channel_socket_type;
#line 180
attribute pdx_display_manager_server_type;
#line 180


#line 181
attribute pdx_display_screenshot_endpoint_dir_type;
#line 181
attribute pdx_display_screenshot_endpoint_socket_type;
#line 181
attribute pdx_display_screenshot_channel_socket_type;
#line 181
attribute pdx_display_screenshot_server_type;
#line 181


#line 182
attribute pdx_display_vsync_endpoint_dir_type;
#line 182
attribute pdx_display_vsync_endpoint_socket_type;
#line 182
attribute pdx_display_vsync_channel_socket_type;
#line 182
attribute pdx_display_vsync_server_type;
#line 182


#line 183
attribute pdx_performance_client_endpoint_dir_type;
#line 183
attribute pdx_performance_client_endpoint_socket_type;
#line 183
attribute pdx_performance_client_channel_socket_type;
#line 183
attribute pdx_performance_client_server_type;
#line 183


#line 184
attribute pdx_bufferhub_client_endpoint_dir_type;
#line 184
attribute pdx_bufferhub_client_endpoint_socket_type;
#line 184
attribute pdx_bufferhub_client_channel_socket_type;
#line 184
attribute pdx_bufferhub_client_server_type;
#line 184


# All HAL servers
attribute halserverdomain;
# All HAL clients
attribute halclientdomain;
expandattribute halclientdomain true;

# HALs
attribute hal_allocator;
expandattribute hal_allocator true;
attribute hal_allocator_client;
expandattribute hal_allocator_client true;
attribute hal_allocator_server;
expandattribute hal_allocator_server false;
attribute hal_audio;
expandattribute hal_audio false;
attribute hal_audio_client;
expandattribute hal_audio_client true;
attribute hal_audio_server;
expandattribute hal_audio_server false;
attribute hal_bluetooth;
expandattribute hal_bluetooth true;
attribute hal_bluetooth_client;
expandattribute hal_bluetooth_client true;
attribute hal_bluetooth_server;
expandattribute hal_bluetooth_server false;
attribute hal_bootctl;
expandattribute hal_bootctl false;
attribute hal_bootctl_client;
expandattribute hal_bootctl_client true;
attribute hal_bootctl_server;
expandattribute hal_bootctl_server false;
attribute hal_broadcastradio;
expandattribute hal_broadcastradio true;
attribute hal_broadcastradio_client;
expandattribute hal_broadcastradio_client true;
attribute hal_broadcastradio_server;
expandattribute hal_broadcastradio_server false;
attribute hal_camera;
expandattribute hal_camera false;
attribute hal_camera_client;
expandattribute hal_camera_client true;
attribute hal_camera_server;
expandattribute hal_camera_server false;
attribute hal_configstore;
expandattribute hal_configstore true;
attribute hal_configstore_client;
expandattribute hal_configstore_client true;
attribute hal_configstore_server;
expandattribute hal_configstore_server false;
attribute hal_contexthub;
expandattribute hal_contexthub true;
attribute hal_contexthub_client;
expandattribute hal_contexthub_client true;
attribute hal_contexthub_server;
expandattribute hal_contexthub_server false;
attribute hal_drm;
expandattribute hal_drm false;
attribute hal_drm_client;
expandattribute hal_drm_client true;
attribute hal_drm_server;
expandattribute hal_drm_server false;
attribute hal_cas;
expandattribute hal_cas false;
attribute hal_cas_client;
expandattribute hal_cas_client true;
attribute hal_cas_server;
expandattribute hal_cas_server false;
attribute hal_dumpstate;
expandattribute hal_dumpstate true;
attribute hal_dumpstate_client;
expandattribute hal_dumpstate_client true;
attribute hal_dumpstate_server;
expandattribute hal_dumpstate_server false;
attribute hal_fingerprint;
expandattribute hal_fingerprint true;
attribute hal_fingerprint_client;
expandattribute hal_fingerprint_client true;
attribute hal_fingerprint_server;
expandattribute hal_fingerprint_server false;
attribute hal_gatekeeper;
expandattribute hal_gatekeeper true;
attribute hal_gatekeeper_client;
expandattribute hal_gatekeeper_client true;
attribute hal_gatekeeper_server;
expandattribute hal_gatekeeper_server false;
attribute hal_gnss;
expandattribute hal_gnss true;
attribute hal_gnss_client;
expandattribute hal_gnss_client true;
attribute hal_gnss_server;
expandattribute hal_gnss_server false;
attribute hal_graphics_allocator;
expandattribute hal_graphics_allocator true;
attribute hal_graphics_allocator_client;
expandattribute hal_graphics_allocator_client true;
attribute hal_graphics_allocator_server;
expandattribute hal_graphics_allocator_server false;
attribute hal_graphics_composer;
expandattribute hal_graphics_composer true;
attribute hal_graphics_composer_client;
expandattribute hal_graphics_composer_client true;
attribute hal_graphics_composer_server;
expandattribute hal_graphics_composer_server false;
attribute hal_health;
expandattribute hal_health true;
attribute hal_health_client;
expandattribute hal_health_client true;
attribute hal_health_server;
expandattribute hal_health_server false;
attribute hal_ir;
expandattribute hal_ir true;
attribute hal_ir_client;
expandattribute hal_ir_client true;
attribute hal_ir_server;
expandattribute hal_ir_server false;
attribute hal_keymaster;
expandattribute hal_keymaster true;
attribute hal_keymaster_client;
expandattribute hal_keymaster_client true;
attribute hal_keymaster_server;
expandattribute hal_keymaster_server false;
attribute hal_light;
expandattribute hal_light true;
attribute hal_light_client;
expandattribute hal_light_client true;
attribute hal_light_server;
expandattribute hal_light_server false;
attribute hal_memtrack;
expandattribute hal_memtrack true;
attribute hal_memtrack_client;
expandattribute hal_memtrack_client true;
attribute hal_memtrack_server;
expandattribute hal_memtrack_server false;
attribute hal_neuralnetworks;
expandattribute hal_neuralnetworks true;
attribute hal_neuralnetworks_client;
expandattribute hal_neuralnetworks_client true;
attribute hal_neuralnetworks_server;
expandattribute hal_neuralnetworks_server false;
attribute hal_nfc;
expandattribute hal_nfc true;
attribute hal_nfc_client;
expandattribute hal_nfc_client true;
attribute hal_nfc_server;
expandattribute hal_nfc_server false;
attribute hal_oemlock;
expandattribute hal_oemlock true;
attribute hal_oemlock_client;
expandattribute hal_oemlock_client true;
attribute hal_oemlock_server;
expandattribute hal_oemlock_server false;
attribute hal_power;
expandattribute hal_power true;
attribute hal_power_client;
expandattribute hal_power_client true;
attribute hal_power_server;
expandattribute hal_power_server false;
attribute hal_sensors;
expandattribute hal_sensors true;
attribute hal_sensors_client;
expandattribute hal_sensors_client true;
attribute hal_sensors_server;
expandattribute hal_sensors_server false;
attribute hal_telephony;
expandattribute hal_telephony true;
attribute hal_telephony_client;
expandattribute hal_telephony_client true;
attribute hal_telephony_server;
expandattribute hal_telephony_server false;
attribute hal_tetheroffload;
expandattribute hal_tetheroffload true;
attribute hal_tetheroffload_client;
expandattribute hal_tetheroffload_client true;
attribute hal_tetheroffload_server;
expandattribute hal_tetheroffload_server false;
attribute hal_thermal;
expandattribute hal_thermal true;
attribute hal_thermal_client;
expandattribute hal_thermal_client true;
attribute hal_thermal_server;
expandattribute hal_thermal_server false;
attribute hal_tv_cec;
expandattribute hal_tv_cec true;
attribute hal_tv_cec_client;
expandattribute hal_tv_cec_client true;
attribute hal_tv_cec_server;
expandattribute hal_tv_cec_server false;
attribute hal_tv_input;
expandattribute hal_tv_input true;
attribute hal_tv_input_client;
expandattribute hal_tv_input_client true;
attribute hal_tv_input_server;
expandattribute hal_tv_input_server false;
attribute hal_usb;
expandattribute hal_usb true;
attribute hal_usb_client;
expandattribute hal_usb_client true;
attribute hal_usb_server;
expandattribute hal_usb_server false;
attribute hal_vibrator;
expandattribute hal_vibrator true;
attribute hal_vibrator_client;
expandattribute hal_vibrator_client true;
attribute hal_vibrator_server;
expandattribute hal_vibrator_server false;
attribute hal_vr;
expandattribute hal_vr true;
attribute hal_vr_client;
expandattribute hal_vr_client true;
attribute hal_vr_server;
expandattribute hal_vr_server false;
attribute hal_weaver;
expandattribute hal_weaver true;
attribute hal_weaver_client;
expandattribute hal_weaver_client true;
attribute hal_weaver_server;
expandattribute hal_weaver_server false;
attribute hal_wifi;
expandattribute hal_wifi true;
attribute hal_wifi_client;
expandattribute hal_wifi_client true;
attribute hal_wifi_server;
expandattribute hal_wifi_server false;
attribute hal_wifi_offload;
expandattribute hal_wifi_offload true;
attribute hal_wifi_offload_client;
expandattribute hal_wifi_offload_client true;
attribute hal_wifi_offload_server;
expandattribute hal_wifi_offload_server false;
attribute hal_wifi_supplicant;
expandattribute hal_wifi_supplicant true;
attribute hal_wifi_supplicant_client;
expandattribute hal_wifi_supplicant_client true;
attribute hal_wifi_supplicant_server;
expandattribute hal_wifi_supplicant_server false;

# HwBinder services offered across the core-vendor boundary
#
# We annotate server domains with x_server  to loosen the coupling between
# system and vendor images. For example, it should be possible to move a service
# from one core domain to another, without having to update the vendor image
# which contains clients of this service.

attribute display_service_server;
attribute wifi_keystore_service_server;
#line 1 "system/sepolicy/private/attributes"
# Temporary attribute used for migrating permissions out of domain.
# Motivation: Domain is overly permissive. Start removing permissions
# from domain and assign them to the domain_deprecated attribute.
# Domain_deprecated and domain can initially be assigned to all
# domains. The goal is to not assign domain_deprecated to new domains
# and to start removing domain_deprecated where it's not required or
# reassigning the appropriate permissions to the inheriting domain
# when necessary.
attribute domain_deprecated;
#line 1 "system/sepolicy/public/ioctl_defines"






































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1 "system/sepolicy/public/ioctl_macros"
# socket ioctls allowed to unprivileged apps
#line 12


# socket ioctls never allowed to unprivileged apps
#line 42


# commonly used ioctls on unix sockets
#line 47


# commonly used TTY ioctls
# merge with unpriv_unix_sock_ioctls?
#line 54


# point to point ioctls
#line 68

#line 1 "system/sepolicy/public/adbd.te"
# adbd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type adbd, domain;
type adbd_exec, exec_type, file_type;
#line 1 "system/sepolicy/public/asan_extract.te"
# asan_extract
#
# This command set moves the artifact corresponding to the current slot
# from /data/ota to /data/dalvik-cache.

#line 36

#line 1 "system/sepolicy/public/audioserver.te"
# audioserver - audio services daemon
type audioserver, domain;
#line 1 "system/sepolicy/public/blkid.te"
# blkid called from vold
type blkid, domain;
#line 1 "system/sepolicy/public/blkid_untrusted.te"
# blkid for untrusted block devices
type blkid_untrusted, domain;
#line 1 "system/sepolicy/public/bluetooth.te"
# bluetooth subsystem
type bluetooth, domain;
#line 1 "system/sepolicy/public/bootanim.te"
# bootanimation oneshot service
type bootanim, domain;
type bootanim_exec, exec_type, file_type;


#line 5
typeattribute bootanim halclientdomain;
#line 5
typeattribute bootanim hal_configstore_client;
#line 5

#line 5
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 5
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 5
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 5

#line 5
typeattribute bootanim hal_configstore;
#line 5
# Find passthrough HAL implementations
#line 5
allow hal_configstore system_file:dir { open getattr read search ioctl lock };
#line 5
allow hal_configstore vendor_file:dir { open getattr read search ioctl lock };
#line 5
allow hal_configstore vendor_file:file { read open getattr execute map };
#line 5

#line 5


#line 6
typeattribute bootanim halclientdomain;
#line 6
typeattribute bootanim hal_graphics_allocator_client;
#line 6

#line 6
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 6
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 6
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 6

#line 6
typeattribute bootanim hal_graphics_allocator;
#line 6
# Find passthrough HAL implementations
#line 6
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 6
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 6
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 6

#line 6


#line 7
typeattribute bootanim halclientdomain;
#line 7
typeattribute bootanim hal_graphics_composer_client;
#line 7

#line 7
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 7
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 7
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 7

#line 7
typeattribute bootanim hal_graphics_composer;
#line 7
# Find passthrough HAL implementations
#line 7
allow hal_graphics_composer system_file:dir { open getattr read search ioctl lock };
#line 7
allow hal_graphics_composer vendor_file:dir { open getattr read search ioctl lock };
#line 7
allow hal_graphics_composer vendor_file:file { read open getattr execute map };
#line 7

#line 7



#line 9
# Call the servicemanager and transfer references to it.
#line 9
allow bootanim servicemanager:binder { call transfer };
#line 9
# servicemanager performs getpidcon on clients.
#line 9
allow servicemanager bootanim:dir search;
#line 9
allow servicemanager bootanim:file { read open };
#line 9
allow servicemanager bootanim:process getattr;
#line 9
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 9
# all domains in domain.te.
#line 9


#line 10
# Call the server domain and optionally transfer references to it.
#line 10
allow bootanim surfaceflinger:binder { call transfer };
#line 10
# Allow the serverdomain to transfer references to the client on the reply.
#line 10
allow surfaceflinger bootanim:binder transfer;
#line 10
# Receive and use open files from the server.
#line 10
allow bootanim surfaceflinger:fd use;
#line 10


#line 11
# Call the server domain and optionally transfer references to it.
#line 11
allow bootanim audioserver:binder { call transfer };
#line 11
# Allow the serverdomain to transfer references to the client on the reply.
#line 11
allow audioserver bootanim:binder transfer;
#line 11
# Receive and use open files from the server.
#line 11
allow bootanim audioserver:fd use;
#line 11



#line 13
# Call the hwservicemanager and transfer references to it.
#line 13
allow bootanim hwservicemanager:binder { call transfer };
#line 13
# Allow hwservicemanager to send out callbacks
#line 13
allow hwservicemanager bootanim:binder { call transfer };
#line 13
# hwservicemanager performs getpidcon on clients.
#line 13
allow hwservicemanager bootanim:dir search;
#line 13
allow hwservicemanager bootanim:file { read open };
#line 13
allow hwservicemanager bootanim:process getattr;
#line 13
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 13
# all domains in domain.te.
#line 13


allow bootanim gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# /oem access
allow bootanim oemfs:dir search;
allow bootanim oemfs:file { getattr open read ioctl lock map };

allow bootanim audio_device:dir { open getattr read search ioctl lock };
allow bootanim audio_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

allow bootanim audioserver_service:service_manager find;
allow bootanim surfaceflinger_service:service_manager find;

# Allow access to ion memory allocation device
allow bootanim ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow bootanim hal_graphics_allocator:fd use;

# Fences
allow bootanim hal_graphics_composer:fd use;

# Read access to pseudo filesystems.

#line 35
allow bootanim proc:dir { open getattr read search ioctl lock };
#line 35
allow bootanim proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 35

allow bootanim proc_meminfo:file { getattr open read ioctl lock map };

#line 37
allow bootanim sysfs:dir { open getattr read search ioctl lock };
#line 37
allow bootanim sysfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 37


#line 38
allow bootanim cgroup:dir { open getattr read search ioctl lock };
#line 38
allow bootanim cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 38


# System file accesses.
allow bootanim system_file:dir { open getattr read search ioctl lock };
#line 1 "system/sepolicy/public/bootstat.te"
# bootstat command
type bootstat, domain;
type bootstat_exec, exec_type, file_type;


#line 5
allow bootstat runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 5


# Allow persistent storage in /data/misc/bootstat.
allow bootstat bootstat_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow bootstat bootstat_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Read access to pseudo filesystems (for /proc/uptime).

#line 12
allow bootstat proc:dir { open getattr read search ioctl lock };
#line 12
allow bootstat proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 12


# Collect metrics on boot time created by init

#line 15
allow bootstat boottime_prop:file { getattr open read ioctl lock map };
#line 15

#line 1 "system/sepolicy/public/bufferhubd.te"
# bufferhubd
type bufferhubd, domain, mlstrustedsubject;
type bufferhubd_exec, exec_type, file_type;


#line 5
typeattribute bufferhubd halclientdomain;
#line 5
typeattribute bufferhubd hal_graphics_allocator_client;
#line 5

#line 5
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 5
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 5
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 5

#line 5
typeattribute bufferhubd hal_graphics_allocator;
#line 5
# Find passthrough HAL implementations
#line 5
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 5
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 5
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 5

#line 5



#line 7
# Mark the server domain as a PDX server.
#line 7
typeattribute bufferhubd pdx_bufferhub_client_server_type;
#line 7
# Allow the init process to create the initial endpoint socket.
#line 7
allow init pdx_bufferhub_client_endpoint_socket_type:unix_stream_socket { create bind };
#line 7
# Allow the server domain to use the endpoint socket and accept connections on it.
#line 7
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 7
# than we need (e.g. we don"t need "bind" or "connect").
#line 7
allow bufferhubd pdx_bufferhub_client_endpoint_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown listen accept };
#line 7
# Allow the server domain to apply security context label to the channel socket pair (allow process to use setsockcreatecon_raw()).
#line 7
allow bufferhubd self:process setsockcreate;
#line 7
# Allow the server domain to create a client channel socket.
#line 7
allow bufferhubd pdx_bufferhub_client_channel_socket_type:unix_stream_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
#line 7
# Prevent other processes from claiming to be a server for the same service.
#line 7
neverallow {domain -bufferhubd} pdx_bufferhub_client_endpoint_socket_type:unix_stream_socket { listen accept };
#line 7


#line 8

#line 8
# Allow client to open the service endpoint file.
#line 8
allow bufferhubd pdx_performance_client_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 8
allow bufferhubd pdx_performance_client_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 8
# Allow the client to connect to endpoint socket.
#line 8
allow bufferhubd pdx_performance_client_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 8

#line 8

#line 8
# Allow the client to use the PDX channel socket.
#line 8
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 8
# than we need (e.g. we don"t need "bind" or "connect").
#line 8
allow bufferhubd pdx_performance_client_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 8
# Client needs to use an channel event fd from the server.
#line 8
allow bufferhubd pdx_performance_client_server_type:fd use;
#line 8
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 8
# This could be tightened on a per-server basis, but keeping track of service
#line 8
# clients is error prone.
#line 8
allow pdx_performance_client_server_type bufferhubd:fd use;
#line 8

#line 8


# Access the GPU.
allow bufferhubd gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Access /dev/ion
allow bufferhubd ion_device:chr_file { getattr open read ioctl lock map };

# Receive sync fence FDs from mediacodec. Note that mediacodec never directly
# connects to bufferhubd via PDX. Instead, a VR app acts as a bridge between
# those two: it talks to mediacodec via Binder and talks to bufferhubd via PDX.
# Thus, there is no need to use pdx_client macro.
allow bufferhubd mediacodec:fd use;
#line 1 "system/sepolicy/public/cameraserver.te"
# cameraserver - camera daemon
type cameraserver, domain;
type cameraserver_exec, exec_type, file_type;


#line 5
# Call the servicemanager and transfer references to it.
#line 5
allow cameraserver servicemanager:binder { call transfer };
#line 5
# servicemanager performs getpidcon on clients.
#line 5
allow servicemanager cameraserver:dir search;
#line 5
allow servicemanager cameraserver:file { read open };
#line 5
allow servicemanager cameraserver:process getattr;
#line 5
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 5
# all domains in domain.te.
#line 5


#line 6
# Call the server domain and optionally transfer references to it.
#line 6
allow cameraserver binderservicedomain:binder { call transfer };
#line 6
# Allow the serverdomain to transfer references to the client on the reply.
#line 6
allow binderservicedomain cameraserver:binder transfer;
#line 6
# Receive and use open files from the server.
#line 6
allow cameraserver binderservicedomain:fd use;
#line 6


#line 7
# Call the server domain and optionally transfer references to it.
#line 7
allow cameraserver appdomain:binder { call transfer };
#line 7
# Allow the serverdomain to transfer references to the client on the reply.
#line 7
allow appdomain cameraserver:binder transfer;
#line 7
# Receive and use open files from the server.
#line 7
allow cameraserver appdomain:fd use;
#line 7


#line 8
typeattribute cameraserver binderservicedomain;
#line 8



#line 10
typeattribute cameraserver halclientdomain;
#line 10
typeattribute cameraserver hal_camera_client;
#line 10

#line 10
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 10
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 10
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 10

#line 10
typeattribute cameraserver hal_camera;
#line 10
# Find passthrough HAL implementations
#line 10
allow hal_camera system_file:dir { open getattr read search ioctl lock };
#line 10
allow hal_camera vendor_file:dir { open getattr read search ioctl lock };
#line 10
allow hal_camera vendor_file:file { read open getattr execute map };
#line 10

#line 10



#line 12
typeattribute cameraserver halclientdomain;
#line 12
typeattribute cameraserver hal_graphics_allocator_client;
#line 12

#line 12
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 12
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 12
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 12

#line 12
typeattribute cameraserver hal_graphics_allocator;
#line 12
# Find passthrough HAL implementations
#line 12
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 12
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 12
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 12

#line 12


allow cameraserver ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Talk with graphics composer fences
allow cameraserver hal_graphics_composer:fd use;


#line 19
  allow cameraserver cameraserver_service:service_manager { add find };
#line 19
  neverallow { domain -cameraserver } cameraserver_service:service_manager add;
#line 19

allow cameraserver appops_service:service_manager find;
allow cameraserver audioserver_service:service_manager find;
allow cameraserver batterystats_service:service_manager find;
allow cameraserver cameraproxy_service:service_manager find;
allow cameraserver mediaserver_service:service_manager find;
allow cameraserver processinfo_service:service_manager find;
allow cameraserver scheduling_policy_service:service_manager find;
allow cameraserver surfaceflinger_service:service_manager find;

allow cameraserver hidl_token_hwservice:hwservice_manager find;

###
### neverallow rules
###

# cameraserver should never execute any executable without a
# domain transition
neverallow cameraserver { file_type fs_type }:file execute_no_trans;

# The goal of the mediaserver split is to place media processing code into
# restrictive sandboxes with limited responsibilities and thus limited
# permissions. Example: Audioserver is only responsible for controlling audio
# hardware and processing audio content. Cameraserver does the same for camera
# hardware/content. Etc.
#
# Media processing code is inherently risky and thus should have limited
# permissions and be isolated from the rest of the system and network.
# Lengthier explanation here:
# https://android-developers.googleblog.com/2016/05/hardening-media-stack.html
neverallow cameraserver domain:{ tcp_socket udp_socket rawip_socket } *;
#line 1 "system/sepolicy/public/charger.te"
# charger seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type charger, domain;

# Write to /dev/kmsg
allow charger kmsg_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Read access to pseudo filesystems.

#line 9
allow charger sysfs_type:dir { open getattr read search ioctl lock };
#line 9
allow charger sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 9


#line 10
allow charger rootfs:dir { open getattr read search ioctl lock };
#line 10
allow charger rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 10


#line 11
allow charger cgroup:dir { open getattr read search ioctl lock };
#line 11
allow charger cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 11


allow charger self:capability { sys_tty_config };
allow charger self:capability sys_boot;


#line 16
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 16
allow charger sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 16
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 16
allow charger self:capability2 block_suspend;
#line 16


allow charger self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Write to /sys/power/state
# TODO:  Split into a separate type?
allow charger sysfs:file write;

allow charger sysfs_batteryinfo:file { getattr open read ioctl lock map };

# Read /sys/fs/pstore/console-ramoops
# Don't worry about overly broad permissions for now, as there's
# only one file in /sys/fs/pstore
allow charger pstorefs:dir { open getattr read search ioctl lock };
allow charger pstorefs:file { getattr open read ioctl lock map };

allow charger graphics_device:dir { open getattr read search ioctl lock };
allow charger graphics_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow charger input_device:dir { open getattr read search ioctl lock };
allow charger input_device:chr_file { getattr open read ioctl lock map };
allow charger tty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow charger proc_sysrq:file { { getattr open read ioctl lock map } { open append write lock map } };

# charger needs to tell init to continue the boot
# process when running in charger mode.

#line 41

#line 41
allow charger property_socket:sock_file write;
#line 41
allow charger init:unix_stream_socket connectto;
#line 41

#line 41
allow charger system_prop:property_service set;
#line 41

#line 41
allow charger system_prop:file { getattr open read ioctl lock map };
#line 41

#line 41

#line 1 "system/sepolicy/public/clatd.te"
# 464xlat daemon
type clatd, domain;
type clatd_exec, exec_type, file_type;


#line 5
typeattribute clatd netdomain;
#line 5



#line 7
allow clatd proc_net:dir { open getattr read search ioctl lock };
#line 7
allow clatd proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 7


# Access objects inherited from netd.
allow clatd netd:fd use;
allow clatd netd:fifo_file { read write };
# TODO: Check whether some or all of these sockets should be close-on-exec.
allow clatd netd:netlink_kobject_uevent_socket { read write };
allow clatd netd:netlink_nflog_socket { read write };
allow clatd netd:netlink_route_socket { read write };
allow clatd netd:udp_socket { read write };
allow clatd netd:unix_stream_socket { read write };
allow clatd netd:unix_dgram_socket { read write };

allow clatd self:capability { net_admin net_raw setuid setgid };

# clatd calls mmap(MAP_LOCKED) with a 1M buffer. MAP_LOCKED first checks
# capable(CAP_IPC_LOCK), and then checks to see the requested amount is
# under RLIMIT_MEMLOCK. If the latter check succeeds clatd won't have
# needed CAP_IPC_LOCK. But this is not guaranteed to succeed on all devices
# so we permit any requests we see from clatd asking for this capability.
# See https://android-review.googlesource.com/127940 and
# https://b.corp.google.com/issues/21736319
allow clatd self:capability ipc_lock;

allow clatd self:netlink_route_socket nlmsg_write;
allow clatd self:{ packet_socket rawip_socket tun_socket } { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow clatd tun_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 1 "system/sepolicy/public/cppreopts.te"
# cppreopts
#
# This command copies preopted files from the system_b partition to the data
# partition. This domain ensures that we are only copying into specific
# directories.

type cppreopts, domain, mlstrustedsubject;
type cppreopts_exec, exec_type, file_type;

# Allow cppreopts copy files into the dalvik-cache
allow cppreopts dalvikcache_data_file:dir { add_name remove_name search write };
allow cppreopts dalvikcache_data_file:file { create getattr open read rename write };

# Allow cppreopts to execute itself using #!/system/bin/sh
allow cppreopts shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Allow us to run find on /postinstall
allow cppreopts system_file:dir { open read };

# Allow running the cp command using cppreopts permissions. Needed so we can
# write into dalvik-cache
allow cppreopts toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 1 "system/sepolicy/public/crash_dump.te"
type crash_dump, domain;
type crash_dump_exec, exec_type, file_type;

allow crash_dump {
  domain
  -init
  -crash_dump
  -keystore
  -logd
}:process { ptrace signal sigchld sigstop sigkill };

# crash_dump might inherit CAP_SYS_PTRACE from a privileged process,
# which will result in an audit log even when it's allowed to trace.
dontaudit crash_dump self:capability { sys_ptrace };


#line 16
  allow crash_dump logd:process { ptrace signal sigchld sigstop sigkill };
#line 16

#line 16
  # Let crash_dump write to /dev/kmsg_debug crashes that happen before logd comes up.
#line 16
  allow crash_dump kmsg_debug_device:chr_file { open append };
#line 21


# Use inherited file descriptors
allow crash_dump domain:fd use;

# Write to the IPC pipe inherited from crashing processes.
# Append to pipes given to us by processes requesting dumps (e.g. dumpstate)
allow crash_dump domain:fifo_file { write append };


#line 30
allow crash_dump domain:dir { open getattr read search ioctl lock };
#line 30
allow crash_dump domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 30

allow crash_dump exec_type:file { getattr open read ioctl lock map };

# Read /data/dalvik-cache.
allow crash_dump dalvikcache_data_file:dir { search getattr };
allow crash_dump dalvikcache_data_file:file { getattr open read ioctl lock map };

# Read APK files.

#line 38
allow crash_dump apk_data_file:dir { open getattr read search ioctl lock };
#line 38
allow crash_dump apk_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 38
;

# Read all /vendor

#line 41
allow crash_dump { vendor_file same_process_hal_file }:dir { open getattr read search ioctl lock };
#line 41
allow crash_dump { vendor_file same_process_hal_file }:{ file lnk_file } { getattr open read ioctl lock map };
#line 41


# Talk to tombstoned

#line 44

#line 44

#line 44
allow crash_dump tombstoned_crash_socket:sock_file write;
#line 44
allow crash_dump tombstoned:unix_stream_socket connectto;
#line 44

#line 44


# Talk to ActivityManager.

#line 47

#line 47

#line 47
allow crash_dump system_ndebug_socket:sock_file write;
#line 47
allow crash_dump system_server:unix_stream_socket connectto;
#line 47

#line 47


# Append to ANR files.
allow crash_dump anr_data_file:file { append getattr };

# Append to tombstone files.
allow crash_dump tombstone_data_file:file { append getattr };


#line 55
allow crash_dump logcat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 55

#line 55

#line 55

#line 55
allow crash_dump logdr_socket:sock_file write;
#line 55
allow crash_dump logd:unix_stream_socket connectto;
#line 55

#line 55

#line 55


###
### neverallow assertions
###

# A domain transition must occur for crash_dump to get the privileges needed to trace the process.
# Do not allow the execution of crash_dump without a domain transition.
neverallow domain crash_dump_exec:file execute_no_trans;
#line 1 "system/sepolicy/public/device.te"
# Device types
type device, dev_type, fs_type;
type alarm_device, dev_type, mlstrustedobject;
type ashmem_device, dev_type, mlstrustedobject;
type audio_device, dev_type;
type audio_timer_device, dev_type;
type audio_seq_device, dev_type;
type binder_device, dev_type, mlstrustedobject;
type hwbinder_device, dev_type, mlstrustedobject;
type vndbinder_device, dev_type;
type block_device, dev_type;
type camera_device, dev_type;
type dm_device, dev_type;
type keychord_device, dev_type;
type loop_control_device, dev_type;
type loop_device, dev_type;
type pmsg_device, dev_type, mlstrustedobject;
type radio_device, dev_type;
type ram_device, dev_type;
type rtc_device, dev_type;
type vold_device, dev_type;
type console_device, dev_type;
type cpuctl_device, dev_type;
type fscklogs, dev_type;
type full_device, dev_type;
# GPU (used by most UI apps)
type gpu_device, dev_type, mlstrustedobject;
type graphics_device, dev_type;
type hw_random_device, dev_type;
type input_device, dev_type;
type kmem_device, dev_type;
type port_device, dev_type;
type mtd_device, dev_type;
type mtp_device, dev_type, mlstrustedobject;
type nfc_device, dev_type;
type ptmx_device, dev_type, mlstrustedobject;
type kmsg_device, dev_type;
type kmsg_debug_device, dev_type;
type null_device, dev_type, mlstrustedobject;
type random_device, dev_type, mlstrustedobject;
type sensors_device, dev_type;
type serial_device, dev_type;
type socket_device, dev_type;
type owntty_device, dev_type, mlstrustedobject;
type tty_device, dev_type;
type video_device, dev_type;
type vcs_device, dev_type;
type zero_device, dev_type, mlstrustedobject;
type fuse_device, dev_type, mlstrustedobject;
type iio_device, dev_type;
type ion_device, dev_type, mlstrustedobject;
type qtaguid_device, dev_type;
type watchdog_device, dev_type;
type uhid_device, dev_type;
type uio_device, dev_type;
type tun_device, dev_type, mlstrustedobject;
type usbaccessory_device, dev_type, mlstrustedobject;
type usb_device, dev_type, mlstrustedobject;
type properties_device, dev_type;
type properties_serial, dev_type;
type i2c_device, dev_type;

# All devices have a uart for the hci
# attach service. The uart dev node
# varies per device. This type
# is used in per device policy
type hci_attach_dev, dev_type;

# All devices have a rpmsg device for
# achieving remoteproc and rpmsg modules
type rpmsg_device, dev_type;

# Partition layout block device
type root_block_device, dev_type;

# factory reset protection block device
type frp_block_device, dev_type;

# System block device mounted on /system.
type system_block_device, dev_type;

# Recovery block device.
type recovery_block_device, dev_type;

# boot block device.
type boot_block_device, dev_type;

# Userdata block device mounted on /data.
type userdata_block_device, dev_type;

# Cache block device mounted on /cache.
type cache_block_device, dev_type;

# Block device for any swap partition.
type swap_block_device, dev_type;

# Metadata block device used for encryption metadata.
# Assign this type to the partition specified by the encryptable=
# mount option in your fstab file in the entry for userdata.
type metadata_block_device, dev_type;

# The 'misc' partition used by recovery and A/B.
type misc_block_device, dev_type;
#line 1 "system/sepolicy/public/dex2oat.te"
# dex2oat
type dex2oat, domain;
type dex2oat_exec, exec_type, file_type;


#line 5
allow dex2oat apk_data_file:dir { open getattr read search ioctl lock };
#line 5
allow dex2oat apk_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 5

# Access to /vendor/app

#line 7
allow dex2oat vendor_app_file:dir { open getattr read search ioctl lock };
#line 7
allow dex2oat vendor_app_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 7

# Access /vendor/framework
allow dex2oat vendor_framework_file:dir { getattr search };
allow dex2oat vendor_framework_file:file { getattr open read };

allow dex2oat tmpfs:file { read getattr };


#line 14
allow dex2oat dalvikcache_data_file:dir { open getattr read search ioctl lock };
#line 14
allow dex2oat dalvikcache_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 14

allow dex2oat dalvikcache_data_file:file write;
# Read symlinks in /data/dalvik-cache. This is required for PIC mode boot images, where
# the oat file is symlinked to the original file in /system.
allow dex2oat dalvikcache_data_file:lnk_file read;
allow dex2oat installd:fd use;

# Acquire advisory lock on /system/framework/arm/*
allow dex2oat system_file:file lock;

# Read already open asec_apk_file file descriptors passed by installd.
# Also allow reading unlabeled files, to allow for upgrading forward
# locked APKs.
allow dex2oat asec_apk_file:file read;
allow dex2oat unlabeled:file read;
allow dex2oat oemfs:file read;
allow dex2oat apk_tmp_file:dir search;
allow dex2oat apk_tmp_file:file { getattr open read ioctl lock map };
allow dex2oat user_profile_data_file:file { getattr read lock };

# Allow dex2oat to compile app's secondary dex files which were reported back to
# the framework.
allow dex2oat app_data_file:file { getattr read write lock };

##################
# A/B OTA Dexopt #
##################

# Allow dex2oat to use file descriptors from otapreopt.
allow dex2oat postinstall_dexopt:fd use;

allow dex2oat postinstall_file:dir { getattr search };
allow dex2oat postinstall_file:filesystem getattr;
allow dex2oat postinstall_file:lnk_file read;

# Allow dex2oat access to files in /data/ota.
allow dex2oat ota_data_file:dir { { open getattr read search ioctl lock } add_name write };
allow dex2oat ota_data_file:file { getattr open read ioctl lock map };

# Create and read symlinks in /data/ota/dalvik-cache. This is required for PIC mode boot images,
# where the oat file is symlinked to the original file in /system.
allow dex2oat ota_data_file:lnk_file { create read };

# It would be nice to tie this down, but currently, because of how images are written, we can't
# pass file descriptors for the preopted boot image to dex2oat. So dex2oat needs to be able to
# create them itself (and make them world-readable).
allow dex2oat ota_data_file:file { create { open append write lock map } setattr };

##############
# Neverallow #
##############

neverallow dex2oat app_data_file:{ file lnk_file sock_file fifo_file } open;
#line 1 "system/sepolicy/public/dhcp.te"
type dhcp, domain;
type dhcp_exec, exec_type, file_type;


#line 4
typeattribute dhcp netdomain;
#line 4


allow dhcp cgroup:dir { create write add_name };
allow dhcp self:capability { setgid setuid net_admin net_raw net_bind_service };
allow dhcp self:packet_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow dhcp self:netlink_route_socket nlmsg_write;
allow dhcp shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow dhcp system_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow dhcp vendor_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# dhcpcd runs dhcpcd-hooks/*, which runs getprop / setprop (toolbox_exec)
allow dhcp toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# For /proc/sys/net/ipv4/conf/*/promote_secondaries
allow dhcp proc_net:file write;


#line 20

#line 20
allow dhcp property_socket:sock_file write;
#line 20
allow dhcp init:unix_stream_socket connectto;
#line 20

#line 20
allow dhcp dhcp_prop:property_service set;
#line 20

#line 20
allow dhcp dhcp_prop:file { getattr open read ioctl lock map };
#line 20

#line 20


#line 21

#line 21
allow dhcp property_socket:sock_file write;
#line 21
allow dhcp init:unix_stream_socket connectto;
#line 21

#line 21
allow dhcp pan_result_prop:property_service set;
#line 21

#line 21
allow dhcp pan_result_prop:file { getattr open read ioctl lock map };
#line 21

#line 21


allow dhcp dhcp_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow dhcp dhcp_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# PAN connections
allow dhcp netd:fd use;
allow dhcp netd:fifo_file { { getattr open read ioctl lock map } { open append write lock map } };
allow dhcp netd:{ { udp_socket unix_dgram_socket } unix_stream_socket } { read write };
allow dhcp netd:{ netlink_kobject_uevent_socket netlink_route_socket netlink_nflog_socket } { read write };
#line 1 "system/sepolicy/public/display_service_server.te"

#line 1
  allow display_service_server fwk_display_hwservice:hwservice_manager { add find };
#line 1
  allow display_service_server hidl_base_hwservice:hwservice_manager add;
#line 1
  neverallow { domain -display_service_server } fwk_display_hwservice:hwservice_manager add;
#line 1

#line 1 "system/sepolicy/public/dnsmasq.te"
# DNS, DHCP services
type dnsmasq, domain;
type dnsmasq_exec, exec_type, file_type;


#line 5
typeattribute dnsmasq netdomain;
#line 5

allowxperm dnsmasq self:udp_socket ioctl 
#line 6
{
#line 6
# qualcomm rmnet ioctls
#line 6
0x00006900 0x00006902
#line 6
# socket ioctls
#line 6
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 6
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 6
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 6
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 6
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 6
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 6
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 6
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 6
0x00008991 0x00008992 0x00008993 0x00008994
#line 6
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 6
# device and protocol specific ioctls
#line 6
0x000089f0-0x000089ff
#line 6
0x000089e0-0x000089ef
#line 6
# Wireless extension ioctls
#line 6
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 6
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 6
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 6
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 6
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 6
0x00008b34 0x00008b35 0x00008b36
#line 6
# Dev private ioctl i.e. hardware specific ioctls
#line 6
0x00008be0-0x00008bff
#line 6
};

# TODO:  Run with dhcp group to avoid need for dac_override.
allow dnsmasq self:capability dac_override;

allow dnsmasq self:capability { net_admin net_raw net_bind_service setgid setuid };

allow dnsmasq dhcp_data_file:dir { open search write add_name remove_name lock };
allow dnsmasq dhcp_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Inherit and use open files from netd.
allow dnsmasq netd:fd use;
allow dnsmasq netd:fifo_file { read write };
# TODO: Investigate whether these inherited sockets should be closed on exec.
allow dnsmasq netd:netlink_kobject_uevent_socket { read write };
allow dnsmasq netd:netlink_nflog_socket { read write };
allow dnsmasq netd:netlink_route_socket { read write };
allow dnsmasq netd:unix_stream_socket { read write };
allow dnsmasq netd:unix_dgram_socket { read write };
allow dnsmasq netd:udp_socket { read write };
#line 1 "system/sepolicy/public/domain.te"
# Rules for all domains.

# Allow reaping by init.
allow domain init:process sigchld;

# Intra-domain accesses.
allow domain self:process {
    fork
    sigchld
    sigkill
    sigstop
    signull
    signal
    getsched
    setsched
    getsession
    getpgid
    setpgid
    getcap
    setcap
    getattr
    setrlimit
};
allow domain self:fd use;
allow domain proc:dir { open getattr read search ioctl lock };
allow domain proc_net:dir search;

#line 27
allow domain self:dir { open getattr read search ioctl lock };
#line 27
allow domain self:{ file lnk_file } { getattr open read ioctl lock map };
#line 27

allow domain self:{ fifo_file file } { { getattr open read ioctl lock map } { open append write lock map } };
allow domain self:unix_dgram_socket { { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } } sendto };
allow domain self:unix_stream_socket { { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } } connectto };

# Inherit or receive open files from others.
allow domain init:fd use;


#line 35
  # Same as adbd rules above, except allow su to do the same thing
#line 35
  allow domain su:unix_stream_socket connectto;
#line 35
  allow domain su:fd use;
#line 35
  allow domain su:unix_stream_socket { getattr getopt read write shutdown };
#line 35

#line 35
  allow { domain -init } su:binder { call transfer };
#line 35
  allow { domain -init } su:fd use;
#line 35

#line 35
  # Running something like "pm dump com.android.bluetooth" requires
#line 35
  # fifo writes
#line 35
  allow domain su:fifo_file { write getattr };
#line 35

#line 35
  # allow "gdbserver --attach" to work for su.
#line 35
  allow domain su:process sigchld;
#line 35

#line 35
  # Allow writing coredumps to /cores/*
#line 35
  allow domain coredump_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 35
  allow domain coredump_file:dir { { open getattr read search ioctl lock } add_name write };
#line 54


# Root fs.
allow domain rootfs:dir search;
allow domain rootfs:lnk_file { read getattr };

# Device accesses.
allow domain device:dir search;
allow domain dev_type:lnk_file { getattr open read ioctl lock map };
allow domain devpts:dir search;
allow domain socket_device:dir { open getattr read search ioctl lock };
allow domain owntty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow domain null_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow domain zero_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow domain ashmem_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
# /dev/binder can be accessed by non-vendor domains and by apps
allow {
  coredomain
  appdomain
  binder_in_vendor_violators # TODO(b/35870313): Remove once all violations are gone
  -hwservicemanager
} binder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
# Devices which are not full TREBLE have fewer restrictions on access to /dev/binder
allow { domain -hwservicemanager -vndservicemanager } binder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow { domain -servicemanager -vndservicemanager -isolated_app } hwbinder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow domain ptmx_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow domain alarm_device:chr_file { getattr open read ioctl lock map };
allow domain random_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow domain properties_device:dir { search getattr };
allow domain properties_serial:file { getattr open read ioctl lock map };

# For now, everyone can access core property files
# Device specific properties are not granted by default

#line 87
allow domain core_property_type:file { getattr open read ioctl lock map };
#line 87

# Let everyone read log properties, so that liblog can avoid sending unloggable
# messages to logd.

#line 90
allow domain log_property_type:file { getattr open read ioctl lock map };
#line 90

dontaudit domain property_type:file audit_access;
allow domain property_contexts_file:file { getattr open read ioctl lock map };

allow domain init:key search;
allow domain vold:key search;

# logd access

#line 98

#line 98
allow domain logdw_socket:sock_file write;
#line 98
allow domain logd:unix_dgram_socket sendto;
#line 98

#line 98
allow domain pmsg_device:chr_file { open append write lock map };
#line 98


# System file accesses.
allow domain system_file:dir { search getattr };
allow domain system_file:file { execute read open getattr map };
allow domain system_file:lnk_file { getattr read };

# Make sure system/vendor split doesn not affect non-treble
# devices

#line 107
    allow domain vendor_file_type:dir { search getattr };
#line 107
    allow domain vendor_file_type:file { execute read open getattr map };
#line 107
    allow domain vendor_file_type:lnk_file { getattr read };
#line 111


# All domains are allowed to open and read directories
# that contain HAL implementations (e.g. passthrough
# HALs require clients to have these permissions)
allow domain vendor_hal_file:dir { open getattr read search ioctl lock };

# Everyone can read and execute all same process HALs
allow domain same_process_hal_file:dir { open getattr read search ioctl lock };
allow domain same_process_hal_file:file { execute read open getattr map };

# Any process can load vndk-sp libraries, which are system libraries
# used by same process HALs
allow domain vndk_sp_file:dir { open getattr read search ioctl lock };
allow domain vndk_sp_file:file { execute read open getattr map };

# All domains get access to /vendor/etc
allow domain vendor_configs_file:dir { open getattr read search ioctl lock };
allow domain vendor_configs_file:file { read open getattr };

# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 131

#line 131
    # Allow all domains to be able to follow /system/vendor symlink
#line 131
    allow domain vendor_file:lnk_file { getattr open read };
#line 131

#line 131
    # This is required to be able to search & read /vendor/lib64
#line 131
    # in order to lookup vendor libraries. The execute permission
#line 131
    # for coredomains is granted *only* for same process HALs
#line 131
    allow domain vendor_file:dir { getattr search };
#line 131

#line 131
    # Allow reading and executing out of /vendor to all vendor domains
#line 131
    allow { domain -coredomain } vendor_file_type:dir { open getattr read search ioctl lock };
#line 131
    allow { domain -coredomain } vendor_file_type:file { read open getattr execute map };
#line 131
    allow { domain -coredomain } vendor_file_type:lnk_file { getattr read };
#line 131

#line 131
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 144


# read and stat any sysfs symlinks
allow domain sysfs:lnk_file { getattr read };

# libc references /data/misc/zoneinfo for timezone related information
# This directory is considered to be a VNDK-stable

#line 151
allow domain zoneinfo_data_file:dir { open getattr read search ioctl lock };
#line 151
allow domain zoneinfo_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 151


# Lots of processes access current CPU information

#line 154
allow domain sysfs_devices_system_cpu:dir { open getattr read search ioctl lock };
#line 154
allow domain sysfs_devices_system_cpu:{ file lnk_file } { getattr open read ioctl lock map };
#line 154



#line 156
allow domain sysfs_usb:dir { open getattr read search ioctl lock };
#line 156
allow domain sysfs_usb:{ file lnk_file } { getattr open read ioctl lock map };
#line 156
;

# files under /data.
allow domain system_data_file:dir getattr;
allow { coredomain appdomain } system_data_file:dir getattr;
# /data has the label system_data_file. Vendor components need the search
# permission on system_data_file for path traversal to /data/vendor.
allow domain system_data_file:dir search;

# required by the dynamic linker
allow domain proc:lnk_file { getattr read };

# /proc/cpuinfo
allow domain proc_cpuinfo:file { getattr open read ioctl lock map };

# jemalloc needs to read /proc/sys/vm/overcommit_memory
allow domain proc_overcommit_memory:file { getattr open read ioctl lock map };

# profiling needs to read /proc/sys/kernel/perf_event_max_sample_rate
allow domain proc_perf:file { getattr open read ioctl lock map };

# toybox loads libselinux which stats /sys/fs/selinux/
allow domain selinuxfs:dir search;
allow domain selinuxfs:file getattr;
allow domain sysfs:dir search;
allow domain selinuxfs:filesystem getattr;

# For /acct/uid/*/tasks.
allow domain cgroup:dir { search write };
allow domain cgroup:file { open append write lock map };

# Almost all processes log tracing information to
# /sys/kernel/debug/tracing/trace_marker
# The reason behind this is documented in b/6513400
allow domain debugfs:dir search;
allow domain debugfs_tracing:dir search;
allow domain debugfs_trace_marker:file { open append write lock map };

# Filesystem access.
allow domain fs_type:filesystem getattr;
allow domain fs_type:dir getattr;

# Restrict all domains to a whitelist for common socket types. Additional
# ioctl commands may be added to individual domains, but this sets safe
# defaults for all processes. Note that granting this whitelist to domain does
# not grant the ioctl permission on these socket types. That must be granted
# separately.
allowxperm domain domain:{ rawip_socket tcp_socket udp_socket }
  ioctl { 
#line 204
{
#line 204
# Socket ioctls for gathering information about the interface
#line 204
0x00008906 0x00008907
#line 204
0x00008910 0x00008912 0x00008913 0x00008915 0x00008917 0x00008919
#line 204
0x0000891b 0x00008921 0x00008933 0x00008938 0x00008942
#line 204
# Wireless extension ioctls. Primarily get functions.
#line 204
0x00008b01 0x00008b05 0x00008b07 0x00008b09 0x00008b0b 0x00008b0d
#line 204
0x00008b0f 0x00008b11 0x00008b12 0x00008b13 0x00008b21 0x00008b23
#line 204
0x00008b25 0x00008b27 0x00008b29 0x00008b2d
#line 204
} {
#line 204
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 204
  0x0000540b 0x00005410 0x0000540f
#line 204
} };
# default whitelist for unix sockets.
allowxperm domain domain:{ unix_dgram_socket unix_stream_socket }
  ioctl {
#line 207
  0x00005411 0x00005451 0x00005401 0x00005413 0x00005414 0x0000541b
#line 207
};

# Restrict PTYs to only whitelisted ioctls.
# Note that granting this whitelist to domain does
# not grant the wider ioctl permission. That must be granted
# separately.
allowxperm domain devpts:chr_file ioctl {
#line 213
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 213
  0x0000540b 0x00005410 0x0000540f
#line 213
};

# Workaround for policy compiler being too aggressive and removing hwservice_manager_type
# when it's not explicitly used in allow rules
allow { domain -domain } hwservice_manager_type:hwservice_manager { add find };
# Workaround for policy compiler being too aggressive and removing vndservice_manager_type
# when it's not explicitly used in allow rules
allow { domain -domain } vndservice_manager_type:service_manager { add find };

# Under ASAN, processes will try to read /data, as the sanitized libraries are there.


###
### neverallow rules
###

# All socket ioctls must be restricted to a whitelist.
neverallowxperm domain domain:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket } ioctl { 0 };

# TIOCSTI is only ever used for exploits. Block it.
# b/33073072, b/7530569
# http://www.openwall.com/lists/oss-security/2016/09/26/14
neverallowxperm * devpts:chr_file ioctl 0x00005412;

# Do not allow any domain other than init or recovery to create unlabeled files.
neverallow { domain -init -recovery } unlabeled:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } create;

# Limit device node creation to these whitelisted domains.
neverallow {
  domain
  -kernel
  -init
  -ueventd
  -vold
} self:capability mknod;

# Limit raw I/O to these whitelisted domains. Do not apply to debug builds.
neverallow {
  domain
  -domain
  -kernel
  -init
  -recovery
  -ueventd
  -healthd
  -uncrypt
  -tee
} self:capability sys_rawio;

# No process can map low memory (< CONFIG_LSM_MMAP_MIN_ADDR).
neverallow * self:memprotect mmap_zero;

# No domain needs mac_override as it is unused by SELinux.
neverallow * self:capability2 mac_override;

# Only recovery needs mac_admin to set contexts not defined in current policy.
neverallow { domain -recovery } self:capability2 mac_admin;

# Once the policy has been loaded there shall be none to modify the policy.
# It is sealed.
neverallow * kernel:security load_policy;

# Only init prior to switching context should be able to set enforcing mode.
# init starts in kernel domain and switches to init domain via setcon in
# the init.rc, so the setenforce occurs while still in kernel. After
# switching domains, there is never any need to setenforce again by init.
neverallow * kernel:security setenforce;
neverallow { domain -kernel } kernel:security setcheckreqprot;

# No booleans in AOSP policy, so no need to ever set them.
neverallow * kernel:security setbool;

# Adjusting the AVC cache threshold.
# Not presently allowed to anything in policy, but possibly something
# that could be set from init.rc.
neverallow { domain -init } kernel:security setsecparam;

# Only init, ueventd, shell and system_server should be able to access HW RNG
neverallow {
  domain
  -init
  -shell # For CTS and is restricted to getattr in shell.te
  -system_server
  -ueventd
} hw_random_device:chr_file *;

# Ensure that all entrypoint executables are in exec_type or postinstall_file.
neverallow * { file_type -exec_type -postinstall_file }:file entrypoint;

# Ensure that nothing in userspace can access /dev/mem or /dev/kmem
neverallow {
  domain
  -shell # For CTS and is restricted to getattr in shell.te
  -ueventd # Further restricted in ueventd.te
} kmem_device:chr_file *;
neverallow * kmem_device:chr_file ~{ create relabelto unlink setattr getattr };

#Ensure that nothing in userspace can access /dev/port
neverallow {
  domain
  -shell # Shell user should not have any abilities outside of getattr
  -ueventd
} port_device:chr_file *;
neverallow * port_device:chr_file ~{ create relabelto unlink setattr getattr };
# Only init should be able to configure kernel usermodehelpers or
# security-sensitive proc settings.
neverallow { domain -init } usermodehelper:file { append write };
neverallow { domain -init -ueventd } sysfs_usermodehelper:file { append write };
neverallow { domain -init } proc_security:file { append open read write };

# No domain should be allowed to ptrace init.
neverallow * init:process ptrace;

# Init can't do anything with binder calls. If this neverallow rule is being
# triggered, it's probably due to a service with no SELinux domain.
neverallow * init:binder *;

# Don't allow raw read/write/open access to block_device
# Rather force a relabel to a more specific type
neverallow { domain -kernel -init -recovery } block_device:blk_file { open read write };

# Do not allow renaming of block files or character files
# Ability to do so can lead to possible use in an exploit chain
# e.g. https://googleprojectzero.blogspot.com/2016/12/chrome-os-exploit-one-byte-overflow-and.html
neverallow * *:{ blk_file chr_file } rename;

# Don't allow raw read/write/open access to generic devices.
# Rather force a relabel to a more specific type.
neverallow domain device:chr_file { open read write };

# Limit what domains can mount filesystems or change their mount flags.
# sdcard_type / vfat is exempt as a larger set of domains need
# this capability, including device-specific domains.
neverallow { domain -kernel -init -recovery -vold -zygote -update_engine -otapreopt_chroot } { fs_type -sdcard_type }:filesystem { mount remount relabelfrom relabelto };

#
# Assert that, to the extent possible, we're not loading executable content from
# outside the rootfs or /system partition except for a few whitelisted domains.
#
neverallow {
    domain
    -appdomain
    
    -dumpstate
    -shell
    -su
    -webview_zygote
    -zygote
} {
    file_type
    -system_file
    -vendor_file_type
    -exec_type
    -postinstall_file
}:file execute;

neverallow {
    domain
    -appdomain # for oemfs
    -recovery # for /tmp/update_binary in tmpfs
} { fs_type -rootfs }:file execute;
# Files from cache should never be executed
neverallow domain { cache_file cache_backup_file cache_private_backup_file cache_recovery_file }:file execute;

# Protect most domains from executing arbitrary content from /data.
neverallow {
  domain
  -appdomain
} {
  data_file_type
  -dalvikcache_data_file
  -system_data_file # shared libs in apks
  -apk_data_file
}:file { execute execute_no_trans };

neverallow { domain -shell } nativetest_data_file:file { execute execute_no_trans };

# Only the init property service should write to /data/property and /dev/__properties__
neverallow { domain -init } property_data_file:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };
neverallow { domain -init } property_data_file:file { { append create link unlink relabelfrom rename setattr write } { execute execute_no_trans } };
neverallow { domain -init } property_type:file { { append create link unlink relabelfrom rename setattr write } { execute execute_no_trans } };
neverallow { domain -init } properties_device:file { { append create link unlink relabelfrom rename setattr write } { execute execute_no_trans } };
neverallow { domain -init } properties_serial:file { { append create link unlink relabelfrom rename setattr write } { execute execute_no_trans } };

# Only recovery should be doing writes to /system & /vendor
neverallow {
    domain
    -recovery
    
} {
    system_file
    vendor_file_type
    exec_type
}:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { create write setattr relabelfrom append unlink link rename };

neverallow { domain -recovery -kernel  } { system_file vendor_file_type exec_type }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } relabelto;

# Don't allow mounting on top of /system files or directories
neverallow * exec_type:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } mounton;
neverallow { domain -init } { system_file vendor_file_type }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } mounton;

# Nothing should be writing to files in the rootfs.
neverallow * rootfs:file { create write setattr relabelto append unlink link rename };

# Restrict context mounts to specific types marked with
# the contextmount_type attribute.
neverallow * {fs_type -contextmount_type}:filesystem relabelto;

# Ensure that context mount types are not writable, to ensure that
# the write to /system restriction above is not bypassed via context=
# mount to another type.
neverallow { domain -recovery } contextmount_type:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Do not allow service_manager add for default service labels.
# Instead domains should use a more specific type such as
# system_app_service rather than the generic type.
# New service_types are defined in {,hw,vnd}service.te and new mappings
# from service name to service_type are defined in {,hw,vnd}service_contexts.
neverallow * default_android_service:service_manager add;
neverallow * default_android_vndservice:service_manager { add find };
neverallow * default_android_hwservice:hwservice_manager { add find };

# Looking up the base class/interface of all HwBinder services is a bad idea.
# hwservicemanager currently offer such lookups only to make it so that security
# decisions are expressed in SELinux policy. However, it's unclear whether this
# lookup has security implications. If it doesn't, hwservicemanager should be
# modified to not offer this lookup.
# This rule can be removed if hwservicemanager is modified to not permit these
# lookups.
neverallow * hidl_base_hwservice:hwservice_manager find;

# Require that domains explicitly label unknown properties, and do not allow
# anyone but init to modify unknown properties.
neverallow { domain -init } default_prop:property_service set;
neverallow { domain -init } mmc_prop:property_service set;

# Do not allow reading device's serial number from system properties except form
# a few whitelisted domains.
neverallow {
  domain
  -adbd
  -dumpstate
  -hal_drm
  -hal_cas
  -init
  -mediadrmserver
  -recovery
  -shell
  -system_server
} serialno_prop:file { getattr open read ioctl lock map };

# Do not allow reading the last boot timestamp from system properties
neverallow { domain -init -system_server } firstboot_prop:file { getattr open read ioctl lock map };

neverallow {
  domain
  -init
  -recovery
  -system_server
  -shell # Shell is further restricted in shell.te
  -ueventd # Further restricted in ueventd.te
} frp_block_device:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# The metadata block device is set aside for device encryption and
# verified boot metadata. It may be reset at will and should not
# be used by other domains.
neverallow { domain -init -recovery -vold } metadata_block_device:blk_file
  { append link rename write open read ioctl lock };

# No domain other than recovery and update_engine can write to system partition(s).
neverallow { domain -recovery -update_engine } system_block_device:blk_file write;

# No domains other than install_recovery or recovery can write to recovery.
neverallow { domain -install_recovery -recovery } recovery_block_device:blk_file write;

# No domains other than a select few can access the misc_block_device. This
# block device is reserved for OTA use.
# Do not assert this rule on userdebug/eng builds, due to some devices using
# this partition for testing purposes.
neverallow {
  domain
  -domain # exclude debuggable builds
  -hal_bootctl
  -init
  -uncrypt
  -update_engine
  -vold
  -recovery
  -ueventd
} misc_block_device:blk_file { append link relabelfrom rename write open read ioctl lock };

# Only (hw|vnd|)servicemanager should be able to register with binder as the context manager
neverallow { domain -servicemanager -hwservicemanager -vndservicemanager } *:binder set_context_mgr;
# The service managers are only allowed to access their own device node
neverallow servicemanager hwbinder_device:chr_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
neverallow servicemanager vndbinder_device:chr_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
neverallow hwservicemanager binder_device:chr_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
neverallow hwservicemanager vndbinder_device:chr_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
neverallow vndservicemanager binder_device:chr_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
neverallow vndservicemanager hwbinder_device:chr_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# On full TREBLE devices, only core components and apps can use Binder and servicemanager. Non-core
# domain apps need this because Android framework offers many of its services to apps as Binder
# services.
# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 518

#line 518
  neverallow {
#line 518
    domain
#line 518
    -coredomain
#line 518
    -appdomain
#line 518
    -binder_in_vendor_violators # TODO(b/35870313): Remove once all violations are gone
#line 518
  } binder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 518
  neverallow {
#line 518
    domain
#line 518
    -coredomain
#line 518
    -appdomain # restrictions for vendor apps are declared lower down
#line 518
    -binder_in_vendor_violators # TODO(b/35870313): Remove once all violations are gone
#line 518
  } service_manager_type:service_manager find;
#line 518
  # Vendor apps are permited to use only stable public services. If they were to use arbitrary
#line 518
  # services which can change any time framework/core is updated, breakage is likely.
#line 518
  neverallow {
#line 518
    appdomain
#line 518
    -coredomain
#line 518
  } {
#line 518
    service_manager_type
#line 518
    -app_api_service
#line 518
    -ephemeral_app_api_service
#line 518
    -audioserver_service # TODO(b/36783122) remove exemptions below once app_api_service is fixed
#line 518
    -cameraserver_service
#line 518
    -drmserver_service
#line 518
    -keystore_service
#line 518
    -mediadrmserver_service
#line 518
    -mediaextractor_service
#line 518
    -mediametrics_service
#line 518
    -mediaserver_service
#line 518
    -nfc_service
#line 518
    -radio_service
#line 518
    -surfaceflinger_service
#line 518
    -virtual_touchpad_service
#line 518
    -vr_hwc_service
#line 518
    -vr_manager_service
#line 518
  }:service_manager find;
#line 518
  neverallow {
#line 518
    domain
#line 518
    -coredomain
#line 518
    -appdomain
#line 518
    -binder_in_vendor_violators # TODO(b/35870313): Remove once all violations are gone
#line 518
  } servicemanager:binder { call transfer };
#line 518

#line 518
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 561


# On full TREBLE devices, only vendor components, shell, and su can use VendorBinder.
# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 564

#line 564
  neverallow {
#line 564
    coredomain
#line 564
    -shell
#line 564
    -su
#line 564
    -ueventd # uevent is granted create for this device, but we still neverallow I/O below
#line 564
  } vndbinder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 564
  neverallow ueventd vndbinder_device:chr_file { read write append ioctl };
#line 564
  neverallow {
#line 564
    coredomain
#line 564
    -shell
#line 564
    -su
#line 564
  } vndservice_manager_type:service_manager *;
#line 564
  neverallow {
#line 564
    coredomain
#line 564
    -shell
#line 564
    -su
#line 564
  } vndservicemanager:binder *;
#line 564

#line 564
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 582


# On full TREBLE devices, socket communications between core components and vendor components are
# not permitted.
# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 586

#line 586
  # Most general rules first, more specific rules below.
#line 586

#line 586
  # Core domains are not permitted to initiate communications to vendor domain sockets.
#line 586
  # We are not restricting the use of already established sockets because it is fine for a process
#line 586
  # to obtain an already established socket via some public/official/stable API and then exchange
#line 586
  # data with its peer over that socket. The wire format in this scenario is dicatated by the API
#line 586
  # and thus does not break the core-vendor separation.
#line 586
  
#line 586
  neverallow {
#line 586
    coredomain
#line 586
    -init
#line 586
    -adbd
#line 586
  } {
#line 586
    domain
#line 586
    -coredomain
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  }:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket } { connect sendto };
#line 586
  neverallow {
#line 586
    coredomain
#line 586
    -init
#line 586
    -adbd
#line 586
  } {
#line 586
    domain
#line 586
    -coredomain
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  }:unix_stream_socket connectto;
#line 586
;
#line 586
  # Vendor domains are not permitted to initiate communications to core domain sockets
#line 586
  
#line 586
  neverallow {
#line 586
    domain
#line 586
    -coredomain
#line 586
    -appdomain
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  } {
#line 586
    coredomain
#line 586
    -logd # Logging by writing to logd Unix domain socket is public API
#line 586
    -netd # netdomain needs this
#line 586
    -mdnsd # netdomain needs this
#line 586
    -su # communications with su are permitted only on userdebug or eng builds
#line 586
    -init
#line 586
    -incidentd # TODO(b/35870313): Remove incidentd from this list once vendor domains no longer declare Binder services
#line 586
    -tombstoned # TODO(b/36604251): Remove tombstoned from this list once mediacodec (OMX HAL) no longer declares Binder services
#line 586
  }:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket } { connect sendto };
#line 586
  neverallow {
#line 586
    domain
#line 586
    -coredomain
#line 586
    -appdomain
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  } {
#line 586
    coredomain
#line 586
    -logd # Logging by writing to logd Unix domain socket is public API
#line 586
    -netd # netdomain needs this
#line 586
    -mdnsd # netdomain needs this
#line 586
    -su # communications with su are permitted only on userdebug or eng builds
#line 586
    -init
#line 586
    -incidentd # TODO(b/35870313): Remove incidentd from this list once vendor domains no longer declare Binder services
#line 586
    -tombstoned # TODO(b/36604251): Remove tombstoned from this list once mediacodec (OMX HAL) no longer declares Binder services
#line 586
  }:unix_stream_socket connectto;
#line 586
;
#line 586

#line 586
  # Vendor domains (except netdomain) are not permitted to initiate communications to netd sockets
#line 586
  
#line 586
  neverallow {
#line 586
    domain
#line 586
    -coredomain
#line 586
    -netdomain
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  } netd:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket } { connect sendto };
#line 586
  neverallow {
#line 586
    domain
#line 586
    -coredomain
#line 586
    -netdomain
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  } netd:unix_stream_socket connectto;
#line 586
;
#line 586

#line 586
  # Vendor domains are not permitted to initiate create/open sockets owned by core domains
#line 586
  neverallow {
#line 586
    domain
#line 586
    -coredomain
#line 586
    -appdomain # appdomain restrictions below
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  } {
#line 586
    coredomain_socket
#line 586
    core_data_file_type
#line 586
    unlabeled # used only by core domains
#line 586
  }:sock_file ~{ append getattr ioctl read write };
#line 586
  neverallow {
#line 586
    appdomain
#line 586
    -coredomain
#line 586
  } {
#line 586
    coredomain_socket
#line 586
    unlabeled # used only by core domains
#line 586
    core_data_file_type
#line 586
    -app_data_file
#line 586
    -pdx_endpoint_socket_type # used by VR layer
#line 586
    -pdx_channel_socket_type # used by VR layer
#line 586
  }:sock_file ~{ append getattr ioctl read write };
#line 586

#line 586
  # Core domains are not permitted to create/open sockets owned by vendor domains
#line 586
  neverallow {
#line 586
    coredomain
#line 586
    -init
#line 586
    -ueventd
#line 586
    -socket_between_core_and_vendor_violators
#line 586
  } {
#line 586
    file_type
#line 586
    dev_type
#line 586
    -coredomain_socket
#line 586
    -core_data_file_type
#line 586
    -unlabeled
#line 586
  }:sock_file ~{ append getattr ioctl read write };
#line 586

#line 586
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 664


# On TREBLE devices, a limited set of files in /vendor are accessible to
# only a few whitelisted coredomains to keep system/vendor separation.
# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 668

#line 668
    # Limit access to /vendor/app
#line 668
    neverallow {
#line 668
        coredomain
#line 668
        -appdomain
#line 668
        -dex2oat
#line 668
        -idmap
#line 668
        -init
#line 668
        -installd
#line 668
        -postinstall_dexopt
#line 668
        -system_server
#line 668
    } vendor_app_file:dir { open read getattr search };
#line 668

#line 668
    neverallow {
#line 668
        coredomain
#line 668
        -appdomain
#line 668
        -dex2oat
#line 668
        -idmap
#line 668
        -init
#line 668
        -installd
#line 668
        -postinstall_dexopt
#line 668
        -system_server
#line 668
    } vendor_app_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 668

#line 668
    # Limit access to /vendor/overlay
#line 668
    neverallow {
#line 668
        coredomain
#line 668
        -appdomain
#line 668
        -idmap
#line 668
        -init
#line 668
        -installd
#line 668
        -system_server
#line 668
        -zygote
#line 668
    } vendor_overlay_file:dir { getattr open read search };
#line 668

#line 668
    neverallow {
#line 668
        coredomain
#line 668
        -appdomain
#line 668
        -idmap
#line 668
        -init
#line 668
        -installd
#line 668
        -system_server
#line 668
        -zygote
#line 668
    } vendor_overlay_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 668

#line 668
    # Non-vendor domains are not allowed to file execute shell
#line 668
    # from vendor
#line 668
    neverallow {
#line 668
        coredomain
#line 668
        -init
#line 668
    } vendor_shell_exec:file { execute execute_no_trans };
#line 668

#line 668
    # Do not allow vendor components to execute files from system
#line 668
    # except for the ones whitelist here.
#line 668
    neverallow {
#line 668
        domain
#line 668
        -coredomain
#line 668
        -appdomain
#line 668
        -rild
#line 668
        -vendor_executes_system_violators
#line 668
    } {
#line 668
        exec_type
#line 668
        -vendor_file_type
#line 668
        -crash_dump_exec
#line 668
        -netutils_wrapper_exec
#line 668
    }:file { entrypoint execute execute_no_trans };
#line 668

#line 668
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 734


# Only authorized processes should be writing to files in /data/dalvik-cache
neverallow {
  domain
  -init # TODO: limit init to relabelfrom for files
  -zygote
  -installd
  -postinstall_dexopt
  -cppreopts
  -dex2oat
  -otapreopt_slot
} dalvikcache_data_file:file { append create link unlink relabelfrom rename setattr write };

neverallow {
  domain
  -init
  -installd
  -postinstall_dexopt
  -cppreopts
  -dex2oat
  -zygote
  -otapreopt_slot
} dalvikcache_data_file:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };

# Only system_server should be able to send commands via the zygote socket
neverallow { domain -zygote -system_server } zygote:unix_stream_socket connectto;
neverallow { domain -system_server } zygote_socket:sock_file write;

neverallow { domain -system_server -webview_zygote } webview_zygote:unix_stream_socket connectto;
neverallow { domain -system_server } webview_zygote_socket:sock_file write;

neverallow {
  domain
  -tombstoned
  -crash_dump
  -dumpstate
  -system_server

  # Processes that can't exec crash_dump
  -mediacodec
  -mediaextractor
} tombstoned_crash_socket:unix_stream_socket connectto;

# Never allow anyone except dumpstate or the system server to connect or write to
# the tombstoned intercept socket.
neverallow { domain -dumpstate -system_server } tombstoned_intercept_socket:sock_file write;
neverallow { domain -dumpstate -system_server } tombstoned_intercept_socket:unix_stream_socket connectto;

# Android does not support System V IPCs.
#
# The reason for this is due to the fact that, by design, they lead to global
# kernel resource leakage.
#
# For example, there is no way to automatically release a SysV semaphore
# allocated in the kernel when:
#
# - a buggy or malicious process exits
# - a non-buggy and non-malicious process crashes or is explicitly killed.
#
# Killing processes automatically to make room for new ones is an
# important part of Android's application lifecycle implementation. This means
# that, even assuming only non-buggy and non-malicious code, it is very likely
# that over time, the kernel global tables used to implement SysV IPCs will fill
# up.
neverallow * *:{ shm sem msg msgq } *;

# Do not mount on top of symlinks, fifos, or sockets.
# Feature parity with Chromium LSM.
neverallow * { file_type fs_type dev_type }:{ lnk_file fifo_file sock_file } mounton;

# Nobody should be able to execute su on user builds.
# On userdebug/eng builds, only dumpstate, shell, and
# su itself execute su.
neverallow { domain -dumpstate -shell -su } su_exec:file { execute execute_no_trans };

# Do not allow the introduction of new execmod rules. Text relocations
# and modification of executable pages are unsafe.
# The only exceptions are for NDK text relocations associated with
# https://code.google.com/p/android/issues/detail?id=23203
# which, long term, need to go away.
neverallow * {
  file_type
  -apk_data_file
  -app_data_file
  -asec_public_file
}:file execmod;

# Do not allow making the stack or heap executable.
# We would also like to minimize execmem but it seems to be
# required by some device-specific service domains.
neverallow * self:process { execstack execheap };

# prohibit non-zygote spawned processes from using shared libraries
# with text relocations. b/20013628 .
neverallow { domain -untrusted_app_all } file_type:file execmod;

neverallow { domain -init } proc:{ file dir } mounton;

# Ensure that all types assigned to processes are included
# in the domain attribute, so that all allow and neverallow rules
# written on domain are applied to all processes.
# This is achieved by ensuring that it is impossible to transition
# from a domain to a non-domain type and vice versa.
# TODO - rework this: neverallow domain ~domain:process { transition dyntransition };
neverallow ~domain domain:process { transition dyntransition };

#
# Only system_app and system_server should be creating or writing
# their files. The proper way to share files is to setup
# type transitions to a more specific type or assigning a type
# to its parent directory via a file_contexts entry.
# Example type transition:
#  mydomain.te:file_type_auto_trans(mydomain, system_data_file, new_file_type)
#
neverallow {
  domain
  -system_server
  -system_app
  -init
  -installd # for relabelfrom and unlink, check for this in explicit neverallow
  
} system_data_file:file { append create link unlink relabelfrom rename setattr write };
# do not grant anything greater than r_file_perms and relabelfrom unlink
# to installd
neverallow installd system_data_file:file ~{ { getattr open read ioctl lock map } relabelfrom unlink };

# respect system_app sandboxes
neverallow {
  domain
  -appdomain # finer-grained rules for appdomain are listed below
  -system_server #populate com.android.providers.settings/databases/settings.db.
  -installd # creation of app sandbox
} system_app_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { create unlink open };
neverallow {
  isolated_app
  untrusted_app_all # finer-grained rules for appdomain are listed below
  ephemeral_app
  priv_app
} system_app_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { create unlink open };


# Services should respect app sandboxes
neverallow {
  domain
  -appdomain
  -installd # creation of sandbox
} app_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { create unlink };

#
# Only these domains should transition to shell domain. This domain is
# permissible for the "shell user". If you need a process to exec a shell
# script with differing privilege, define a domain and set up a transition.
#
neverallow {
  domain
  -adbd
  -init
  -runas
  -zygote
} shell:process { transition dyntransition };

# Only domains spawned from zygote and runas may have the appdomain attribute.
neverallow { domain -runas -webview_zygote -zygote } {
  appdomain -shell -su
}:process { transition dyntransition };

# Minimize read access to shell- or app-writable symlinks.
# This is to prevent malicious symlink attacks.
neverallow {
  domain
  -appdomain
  -installd
  -uncrypt  # TODO: see if we can remove
} app_data_file:lnk_file read;

neverallow {
  domain
  -shell
  -uncrypt
  -installd
} shell_data_file:lnk_file read;

# In addition to the symlink reading restrictions above, restrict
# write access to shell owned directories. The /data/local/tmp
# directory is untrustworthy, and non-whitelisted domains should
# not be trusting any content in those directories.
neverallow {
  domain
  -adbd
  -dumpstate
  -installd
  -init
  -shell
  -vold
} shell_data_file:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };

neverallow {
  domain
  -adbd
  -appdomain
  -dumpstate
  -init
  -installd
  -system_server # why?
  -uncrypt
} shell_data_file:dir { open search };

# Same as above for /data/local/tmp files. We allow shell files
# to be passed around by file descriptor, but not directly opened.
neverallow {
  domain
  -adbd
  -appdomain
  -dumpstate
  -installd
  -uncrypt
} shell_data_file:file open;


# servicemanager and vndservicemanager are the only processes which handle the
# service_manager list request
neverallow * ~{
    servicemanager
    vndservicemanager
    }:service_manager list;

# hwservicemanager is the only process which handles hw list requests
neverallow * ~{
    hwservicemanager
    }:hwservice_manager list;

# only service_manager_types can be added to service_manager
# TODO - rework this: neverallow * ~service_manager_type:service_manager { add find };

# Prevent assigning non property types to properties
# TODO - rework this: neverallow * ~property_type:property_service set;

# Domain types should never be assigned to any files other
# than the /proc/pid files associated with a process. The
# executable file used to enter a domain should be labeled
# with its own _exec type, not with the domain type.
# Conventionally, this looks something like:
# $ cat mydaemon.te
# type mydaemon, domain;
# type mydaemon_exec, exec_type, file_type;
# init_daemon_domain(mydaemon)
# $ grep mydaemon file_contexts
# /system/bin/mydaemon -- u:object_r:mydaemon_exec:s0
neverallow * domain:file { execute execute_no_trans entrypoint };

# Do not allow access to the generic debugfs label. This is too broad.
# Instead, if access to part of debugfs is desired, it should have a
# more specific label.
# TODO: fix system_server and dumpstate
neverallow { domain -init -system_server -dumpstate } debugfs:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Profiles contain untrusted data and profman parses that. We should only run
# in from installd forked processes.
neverallow {
  domain
  -installd
  -profman
} profman_exec:file { execute execute_no_trans };

# Enforce restrictions on kernel module origin.
# Do not allow kernel module loading except from system,
# vendor, and boot partitions.
neverallow * ~{ system_file vendor_file rootfs }:system module_load;

# Only allow filesystem caps to be set at build time or
# during upgrade by recovery.
neverallow {
  domain
  -recovery
} self:capability setfcap;

# Enforce AT_SECURE for executing crash_dump.
neverallow domain crash_dump:process noatsecure;

# Do not permit non-core domains to register HwBinder services which are
# guaranteed to be provided by core domains only.
neverallow ~coredomain coredomain_hwservice:hwservice_manager add;

# Do not permit the registeration of HwBinder services which are guaranteed to
# be passthrough only (i.e., run in the process of their clients instead of a
# separate server process).
neverallow * same_process_hwservice:hwservice_manager add;
#line 1 "system/sepolicy/public/drmserver.te"
# drmserver - DRM service
type drmserver, domain;
type drmserver_exec, exec_type, file_type;

typeattribute drmserver mlstrustedsubject;


#line 7
typeattribute drmserver netdomain;
#line 7


# Perform Binder IPC to system server.

#line 10
# Call the servicemanager and transfer references to it.
#line 10
allow drmserver servicemanager:binder { call transfer };
#line 10
# servicemanager performs getpidcon on clients.
#line 10
allow servicemanager drmserver:dir search;
#line 10
allow servicemanager drmserver:file { read open };
#line 10
allow servicemanager drmserver:process getattr;
#line 10
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 10
# all domains in domain.te.
#line 10


#line 11
# Call the server domain and optionally transfer references to it.
#line 11
allow drmserver system_server:binder { call transfer };
#line 11
# Allow the serverdomain to transfer references to the client on the reply.
#line 11
allow system_server drmserver:binder transfer;
#line 11
# Receive and use open files from the server.
#line 11
allow drmserver system_server:fd use;
#line 11


#line 12
# Call the server domain and optionally transfer references to it.
#line 12
allow drmserver appdomain:binder { call transfer };
#line 12
# Allow the serverdomain to transfer references to the client on the reply.
#line 12
allow appdomain drmserver:binder transfer;
#line 12
# Receive and use open files from the server.
#line 12
allow drmserver appdomain:fd use;
#line 12


#line 13
typeattribute drmserver binderservicedomain;
#line 13

# Inherit or receive open files from system_server.
allow drmserver system_server:fd use;

# Perform Binder IPC to mediaserver

#line 18
# Call the server domain and optionally transfer references to it.
#line 18
allow drmserver mediaserver:binder { call transfer };
#line 18
# Allow the serverdomain to transfer references to the client on the reply.
#line 18
allow mediaserver drmserver:binder transfer;
#line 18
# Receive and use open files from the server.
#line 18
allow drmserver mediaserver:fd use;
#line 18


allow drmserver sdcard_type:dir search;
allow drmserver drm_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow drmserver drm_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow drmserver tee_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow drmserver app_data_file:file { read write getattr };
allow drmserver sdcard_type:file { read write getattr };

#line 26
allow drmserver efs_file:dir { open getattr read search ioctl lock };
#line 26
allow drmserver efs_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 26


type drmserver_socket, file_type;

# /data/app/tlcd_sock socket file.
# Clearly, /data/app is the most logical place to create a socket.  Not.
allow drmserver apk_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow drmserver drmserver_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
# Delete old socket file if present.
allow drmserver apk_data_file:sock_file unlink;

# After taking a video, drmserver looks at the video file.

#line 38
allow drmserver media_rw_data_file:dir { open getattr read search ioctl lock };
#line 38
allow drmserver media_rw_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 38


# Read resources from open apk files passed over Binder.
allow drmserver apk_data_file:file { read getattr };
allow drmserver asec_apk_file:file { read getattr };
allow drmserver ringtone_file:file { read getattr };

# Read /data/data/com.android.providers.telephony files passed over Binder.
allow drmserver radio_data_file:file { read getattr };

# /oem access
allow drmserver oemfs:dir search;
allow drmserver oemfs:file { getattr open read ioctl lock map };


#line 52
  allow drmserver drmserver_service:service_manager { add find };
#line 52
  neverallow { domain -drmserver } drmserver_service:service_manager add;
#line 52

allow drmserver permission_service:service_manager find;


#line 55

#line 55
allow drmserver selinuxfs:dir { open getattr read search ioctl lock };
#line 55
allow drmserver selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 55

#line 55
allow drmserver selinuxfs:file { open append write lock map };
#line 55
allow drmserver kernel:security compute_av;
#line 55
allow drmserver self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 55



#line 57
allow drmserver cgroup:dir { open getattr read search ioctl lock };
#line 57
allow drmserver cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 57


#line 58
allow drmserver system_file:dir { open getattr read search ioctl lock };
#line 58
allow drmserver system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 58

#line 1 "system/sepolicy/public/dumpstate.te"
# dumpstate
type dumpstate, domain, mlstrustedsubject;
type dumpstate_exec, exec_type, file_type;


#line 5
typeattribute dumpstate netdomain;
#line 5


#line 6
# Call the servicemanager and transfer references to it.
#line 6
allow dumpstate servicemanager:binder { call transfer };
#line 6
# servicemanager performs getpidcon on clients.
#line 6
allow servicemanager dumpstate:dir search;
#line 6
allow servicemanager dumpstate:file { read open };
#line 6
allow servicemanager dumpstate:process getattr;
#line 6
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 6
# all domains in domain.te.
#line 6


#line 7
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 7
allow dumpstate sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 7
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 7
allow dumpstate self:capability2 block_suspend;
#line 7


# Allow setting process priority, protect from OOM killer, and dropping
# privileges by switching UID / GID
allow dumpstate self:capability { setuid setgid sys_resource };

# Allow dumpstate to scan through /proc/pid for all processes

#line 14
allow dumpstate domain:dir { open getattr read search ioctl lock };
#line 14
allow dumpstate domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 14


allow dumpstate self:capability {
    # Send signals to processes
    kill
    # Run iptables
    net_raw
    net_admin
};

# Allow executing files on system, such as:
#   /system/bin/toolbox
#   /system/bin/logcat
#   /system/bin/dumpsys
allow dumpstate system_file:file execute_no_trans;
allow dumpstate vendor_file:file execute_no_trans;
allow dumpstate toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# hidl searches for files in /system/lib(64)/hw/
allow dumpstate system_file:dir { open getattr read search ioctl lock };

# Create and write into /data/anr/
allow dumpstate self:capability { dac_override chown fowner fsetid };
allow dumpstate anr_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow dumpstate anr_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Allow reading /data/system/uiderrors.txt
# TODO: scope this down.
allow dumpstate system_data_file:file { getattr open read ioctl lock map };

# Read dmesg
allow dumpstate self:capability2 syslog;
allow dumpstate kernel:system syslog_read;

# Read /sys/fs/pstore/console-ramoops
allow dumpstate pstorefs:dir { open getattr read search ioctl lock };
allow dumpstate pstorefs:file { getattr open read ioctl lock map };

# Get process attributes
allow dumpstate domain:process getattr;

# Signal java processes to dump their stack
allow dumpstate { appdomain system_server }:process signal;

# Signal native processes to dump their stack.
allow dumpstate {
  # This list comes from native_processes_to_dump in dumpstate/utils.c
  audioserver
  cameraserver
  drmserver
  inputflinger
  mediadrmserver
  mediaextractor
  mediaserver
  sdcardd
  surfaceflinger

  # This list comes from hal_interfaces_to_dump in dumpstate/utils.c
  hal_audio_server
  hal_bluetooth_server
  hal_camera_server
  hal_graphics_composer_server
  hal_sensors_server
  hal_vr_server
  mediacodec # TODO(b/36375899): hal_omx_server
}:process signal;

# Connect to tombstoned to intercept dumps.

#line 82

#line 82

#line 82
allow dumpstate tombstoned_intercept_socket:sock_file write;
#line 82
allow dumpstate tombstoned:unix_stream_socket connectto;
#line 82

#line 82


# TODO: added to match above sysfs rule. Remove me?
allow dumpstate sysfs_usb:file { open append write lock map };

# Other random bits of data we want to collect
allow dumpstate qtaguid_proc:file { getattr open read ioctl lock map };
allow dumpstate debugfs:file { getattr open read ioctl lock map };

# df for
allow dumpstate {
  block_device
  cache_file
  rootfs
  selinuxfs
  storage_file
  tmpfs
}:dir { search getattr };
allow dumpstate fuse_device:chr_file getattr;
allow dumpstate { dm_device cache_block_device }:blk_file getattr;
allow dumpstate { cache_file rootfs }:lnk_file { getattr read };

# Read /dev/cpuctl and /dev/cpuset

#line 105
allow dumpstate cgroup:dir { open getattr read search ioctl lock };
#line 105
allow dumpstate cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 105


# Allow dumpstate to make binder calls to any binder service

#line 108
# Call the server domain and optionally transfer references to it.
#line 108
allow dumpstate binderservicedomain:binder { call transfer };
#line 108
# Allow the serverdomain to transfer references to the client on the reply.
#line 108
allow binderservicedomain dumpstate:binder transfer;
#line 108
# Receive and use open files from the server.
#line 108
allow dumpstate binderservicedomain:fd use;
#line 108


#line 109
# Call the server domain and optionally transfer references to it.
#line 109
allow dumpstate { appdomain netd wificond }:binder { call transfer };
#line 109
# Allow the serverdomain to transfer references to the client on the reply.
#line 109
allow { appdomain netd wificond } dumpstate:binder transfer;
#line 109
# Receive and use open files from the server.
#line 109
allow dumpstate { appdomain netd wificond }:fd use;
#line 109



#line 111
typeattribute dumpstate halclientdomain;
#line 111
typeattribute dumpstate hal_dumpstate_client;
#line 111

#line 111
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 111
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 111
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 111

#line 111
typeattribute dumpstate hal_dumpstate;
#line 111
# Find passthrough HAL implementations
#line 111
allow hal_dumpstate system_file:dir { open getattr read search ioctl lock };
#line 111
allow hal_dumpstate vendor_file:dir { open getattr read search ioctl lock };
#line 111
allow hal_dumpstate vendor_file:file { read open getattr execute map };
#line 111

#line 111


#line 112
typeattribute dumpstate halclientdomain;
#line 112
typeattribute dumpstate hal_graphics_allocator_client;
#line 112

#line 112
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 112
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 112
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 112

#line 112
typeattribute dumpstate hal_graphics_allocator;
#line 112
# Find passthrough HAL implementations
#line 112
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 112
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 112
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 112

#line 112

# Vibrate the device after we are done collecting the bugreport

#line 114
typeattribute dumpstate halclientdomain;
#line 114
typeattribute dumpstate hal_vibrator_client;
#line 114

#line 114
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 114
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 114
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 114

#line 114
typeattribute dumpstate hal_vibrator;
#line 114
# Find passthrough HAL implementations
#line 114
allow hal_vibrator system_file:dir { open getattr read search ioctl lock };
#line 114
allow hal_vibrator vendor_file:dir { open getattr read search ioctl lock };
#line 114
allow hal_vibrator vendor_file:file { read open getattr execute map };
#line 114

#line 114

# For passthrough mode:
allow dumpstate sysfs_vibrator:file { { { getattr open read ioctl lock map } { open append write lock map } } getattr };

# Reading /proc/PID/maps of other processes
allow dumpstate self:capability sys_ptrace;

# Allow the bugreport service to create a file in
# /data/data/com.android.shell/files/bugreports/bugreport
allow dumpstate shell_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow dumpstate shell_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Run a shell.
allow dumpstate shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# For running am and similar framework commands.
# Run /system/bin/app_process.
allow dumpstate zygote_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
# Dalvik Compiler JIT.
allow dumpstate ashmem_device:chr_file execute;
allow dumpstate self:process execmem;
# For art.
allow dumpstate dalvikcache_data_file:dir { search getattr };
allow dumpstate dalvikcache_data_file:file { { getattr open read ioctl lock map } execute };
allow dumpstate dalvikcache_data_file:lnk_file { getattr open read ioctl lock map };

# For Bluetooth
allow dumpstate bluetooth_data_file:dir search;
allow dumpstate bluetooth_logs_data_file:dir { open getattr read search ioctl lock };
allow dumpstate bluetooth_logs_data_file:file { getattr open read ioctl lock map };

# Dumpstate calls screencap, which grabs a screenshot. Needs gpu access
allow dumpstate gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# logd access

#line 149
allow dumpstate logcat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 149

#line 149

#line 149

#line 149
allow dumpstate logdr_socket:sock_file write;
#line 149
allow dumpstate logd:unix_stream_socket connectto;
#line 149

#line 149

#line 149


#line 150
# Group AID_LOG checked by filesystem & logd
#line 150
# to permit control commands
#line 150

#line 150

#line 150

#line 150
allow dumpstate logd_socket:sock_file write;
#line 150
allow dumpstate logd:unix_stream_socket connectto;
#line 150

#line 150

#line 150


#line 151
allow dumpstate runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 151


# Read files in /proc
allow dumpstate proc_meminfo:file { getattr open read ioctl lock map };
allow dumpstate proc_net:file { getattr open read ioctl lock map };

#line 156
allow dumpstate proc:dir { open getattr read search ioctl lock };
#line 156
allow dumpstate proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 156


# Read network state info files.
allow dumpstate net_data_file:dir search;
allow dumpstate net_data_file:file { getattr open read ioctl lock map };

# List sockets via ss.
allow dumpstate self:netlink_tcpdiag_socket { { create { read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_read };

# Access /data/tombstones.
allow dumpstate tombstone_data_file:dir { open getattr read search ioctl lock };
allow dumpstate tombstone_data_file:file { getattr open read ioctl lock map };

# Access /cache/recovery
allow dumpstate cache_recovery_file:dir { open getattr read search ioctl lock };
allow dumpstate cache_recovery_file:file { getattr open read ioctl lock map };

# Access /data/misc/recovery
allow dumpstate recovery_data_file:dir { open getattr read search ioctl lock };
allow dumpstate recovery_data_file:file { getattr open read ioctl lock map };

# Access /data/misc/profiles/{cur,ref}/

#line 178
  allow dumpstate user_profile_data_file:dir { open getattr read search ioctl lock };
#line 178
  allow dumpstate user_profile_data_file:file { getattr open read ioctl lock map };
#line 181


# Access /data/misc/logd

#line 184
  allow dumpstate misc_logd_file:dir { open getattr read search ioctl lock };
#line 184
  allow dumpstate misc_logd_file:file { getattr open read ioctl lock map };
#line 187


allow dumpstate { service_manager_type -gatekeeper_service -dumpstate_service -incident_service -virtual_touchpad_service -vr_hwc_service }:service_manager find;
allow dumpstate servicemanager:service_manager list;
allow dumpstate hwservicemanager:hwservice_manager list;

allow dumpstate devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Set properties.
# dumpstate_prop is used to share state with the Shell app.

#line 197

#line 197
allow dumpstate property_socket:sock_file write;
#line 197
allow dumpstate init:unix_stream_socket connectto;
#line 197

#line 197
allow dumpstate dumpstate_prop:property_service set;
#line 197

#line 197
allow dumpstate dumpstate_prop:file { getattr open read ioctl lock map };
#line 197

#line 197

# dumpstate_options_prop is used to pass extra command-line args.

#line 199

#line 199
allow dumpstate property_socket:sock_file write;
#line 199
allow dumpstate init:unix_stream_socket connectto;
#line 199

#line 199
allow dumpstate dumpstate_options_prop:property_service set;
#line 199

#line 199
allow dumpstate dumpstate_options_prop:file { getattr open read ioctl lock map };
#line 199

#line 199


# Read device's serial number from system properties

#line 202
allow dumpstate serialno_prop:file { getattr open read ioctl lock map };
#line 202


# Read state of logging-related properties

#line 205
allow dumpstate device_logging_prop:file { getattr open read ioctl lock map };
#line 205


# Access to /data/media.
# This should be removed if sdcardfs is modified to alter the secontext for its
# accesses to the underlying FS.
allow dumpstate media_rw_data_file:dir getattr;
allow dumpstate proc_interrupts:file { getattr open read ioctl lock map };
allow dumpstate proc_zoneinfo:file { getattr open read ioctl lock map };

# Create a service for talking back to system_server

#line 215
  allow dumpstate dumpstate_service:service_manager { add find };
#line 215
  neverallow { domain -dumpstate } dumpstate_service:service_manager add;
#line 215


# use /dev/ion for screen capture
allow dumpstate ion_device:chr_file { getattr open read ioctl lock map };

# read default labeled files in /sys

#line 221
allow dumpstate sysfs:dir { open getattr read search ioctl lock };
#line 221
allow dumpstate sysfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 221


# Allow dumpstate to run top
allow dumpstate proc_stat:file { getattr open read ioctl lock map };

# Allow dumpstate to read backlight details
allow dumpstate sysfs_leds:lnk_file { getattr open read ioctl lock map };
allow dumpstate sysfs_leds:file { getattr open read ioctl lock map };
allow dumpstate sysfs_leds:dir search;

# Allow dumpstate to talk to installd over binder

#line 232
# Call the server domain and optionally transfer references to it.
#line 232
allow dumpstate installd:binder { call transfer };
#line 232
# Allow the serverdomain to transfer references to the client on the reply.
#line 232
allow installd dumpstate:binder transfer;
#line 232
# Receive and use open files from the server.
#line 232
allow dumpstate installd:fd use;
#line 232
;

# Allow dumpstate to run ip xfrm policy
allow dumpstate self:netlink_xfrm_socket { { create { read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_read };

###
### neverallow rules
###

# dumpstate has capability sys_ptrace, but should only use that capability for
# accessing sensitive /proc/PID files, never for using ptrace attach.
neverallow dumpstate *:process ptrace;

# only system_server, dumpstate and shell can find the dumpstate service
neverallow { domain -system_server -shell -dumpstate } dumpstate_service:service_manager find;

# Dumpstate should not be writing to any generically labeled sysfs files.
# Create a specific label for the file type
neverallow dumpstate sysfs:file { append create link unlink relabelfrom rename setattr write };
#line 1 "system/sepolicy/public/e2fs.te"
type e2fs, domain, coredomain;
type e2fs_exec, exec_type, file_type;

allow e2fs block_device:blk_file getattr;
allow e2fs block_device:dir search;
allow e2fs userdata_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# access /proc/filesystems
allow e2fs proc:file { getattr open read ioctl lock map };

# access /sys/fs/ext4/features
allow e2fs sysfs_fs_ext4_features:file { getattr open read ioctl lock map };

# access sselinux context files
allow e2fs file_contexts_file:file { getattr open read };
#line 1 "system/sepolicy/public/ephemeral_app.te"
###
### Ephemeral apps.
###
### This file defines the security policy for apps with the ephemeral
### feature.
###
### The ephemeral_app domain is a reduced permissions sandbox allowing
### ephemeral applications to be safely installed and run. Non ephemeral
### applications may also opt-in to ephemeral to take advantage of the
### additional security features.
###
### PackageManager flags an app as ephemeral at install time.

type ephemeral_app, domain;
#line 1 "system/sepolicy/public/file.te"
# Filesystem types
type labeledfs, fs_type;
type pipefs, fs_type;
type sockfs, fs_type;
type rootfs, fs_type;
type proc, fs_type;
# Security-sensitive proc nodes that should not be writable to most.
type proc_security, fs_type;
type proc_drop_caches, fs_type;
type proc_overcommit_memory, fs_type;
# proc, sysfs, or other nodes that permit configuration of kernel usermodehelpers.
type usermodehelper, fs_type;
type sysfs_usermodehelper, fs_type, sysfs_type;
type qtaguid_proc, fs_type, mlstrustedobject;
type proc_bluetooth_writable, fs_type;
type proc_cpuinfo, fs_type;
type proc_interrupts, fs_type;
type proc_iomem, fs_type;
type proc_meminfo, fs_type;
type proc_misc, fs_type;
type proc_modules, fs_type;
type proc_net, fs_type;
type proc_perf, fs_type;
type proc_stat, fs_type;
type proc_sysrq, fs_type;
type proc_timer, fs_type;
type proc_tty_drivers, fs_type;
type proc_uid_cputime_showstat, fs_type;
type proc_uid_cputime_removeuid, fs_type;
type proc_uid_io_stats, fs_type;
type proc_uid_procstat_set, fs_type;
type proc_uid_time_in_state, fs_type;
type proc_zoneinfo, fs_type;
type selinuxfs, fs_type, mlstrustedobject;
type cgroup, fs_type, mlstrustedobject;
type sysfs, fs_type, sysfs_type, mlstrustedobject;
type sysfs_uio, sysfs_type, fs_type;
type sysfs_batteryinfo, fs_type, sysfs_type;
type sysfs_bluetooth_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_leds, fs_type, sysfs_type;
type sysfs_hwrandom, fs_type, sysfs_type;
type sysfs_nfc_power_writable, fs_type, sysfs_type, mlstrustedobject;
type sysfs_wake_lock, fs_type, sysfs_type;
type sysfs_mac_address, fs_type, sysfs_type;
type sysfs_usb, sysfs_type, file_type, mlstrustedobject;
type sysfs_fs_ext4_features, sysfs_type, fs_type;
type configfs, fs_type;
# /sys/devices/system/cpu
type sysfs_devices_system_cpu, fs_type, sysfs_type;
# /sys/module/lowmemorykiller
type sysfs_lowmemorykiller, fs_type, sysfs_type;
# /sys/module/wlan/parameters/fwpath
type sysfs_wlan_fwpath, fs_type, sysfs_type;
type sysfs_vibrator, fs_type, sysfs_type;

type sysfs_thermal, sysfs_type, fs_type;

type sysfs_zram, fs_type, sysfs_type;
type sysfs_zram_uevent, fs_type, sysfs_type;
type inotify, fs_type, mlstrustedobject;
type devpts, fs_type, mlstrustedobject;
type tmpfs, fs_type;
type shm, fs_type;
type mqueue, fs_type;
type fuse, sdcard_type, fs_type, mlstrustedobject;
type sdcardfs, sdcard_type, fs_type, mlstrustedobject;
type vfat, sdcard_type, fs_type, mlstrustedobject;
type debugfs, fs_type, debugfs_type;
type debugfs_mmc, fs_type, debugfs_type;
type debugfs_trace_marker, fs_type, debugfs_type, mlstrustedobject;
type debugfs_tracing, fs_type, debugfs_type;
type debugfs_tracing_debug, fs_type, debugfs_type;
type debugfs_tracing_instances, fs_type, debugfs_type;
type debugfs_wifi_tracing, fs_type, debugfs_type;

type pstorefs, fs_type;
type functionfs, fs_type, mlstrustedobject;
type oemfs, fs_type, contextmount_type;
type usbfs, fs_type;
type binfmt_miscfs, fs_type;
type app_fusefs, fs_type, contextmount_type;

# File types
type unlabeled, file_type;

# Default type for anything under /system.
type system_file, file_type;

# Default type for directories search for
# HAL implementations
type vendor_hal_file, vendor_file_type, file_type;
# Default type for under /vendor or /system/vendor
type vendor_file, vendor_file_type, file_type;
# Default type for everything in /vendor/app
type vendor_app_file, vendor_file_type, file_type;
# Default type for everything under /vendor/etc/
type vendor_configs_file, vendor_file_type, file_type;
# Default type for all *same process* HALs.
# e.g. libEGL_xxx.so, android.hardware.graphics.mapper@2.0-impl.so
type same_process_hal_file, vendor_file_type, file_type;
# Default type for vndk-sp libs. /vendor/lib/vndk-sp
type vndk_sp_file, vendor_file_type, file_type;
# Default type for everything in /vendor/framework
type vendor_framework_file, vendor_file_type, file_type;
# Default type for everything in /vendor/overlay
type vendor_overlay_file, vendor_file_type, file_type;

# Speedup access for trusted applications to the runtime event tags
type runtime_event_log_tags_file, file_type;
# Type for /system/bin/logcat.
type logcat_exec, exec_type, file_type;
# /cores for coredumps on userdebug / eng builds
type coredump_file, file_type;
# Default type for anything under /data.
type system_data_file, file_type, data_file_type, core_data_file_type;
# Unencrypted data
type unencrypted_data_file, file_type, data_file_type, core_data_file_type;
# /data/.layout_version or other installd-created files that
# are created in a system_data_file directory.
type install_data_file, file_type, data_file_type, core_data_file_type;
# /data/drm - DRM plugin data
type drm_data_file, file_type, data_file_type, core_data_file_type;
# /data/adb - adb debugging files
type adb_data_file, file_type, data_file_type, core_data_file_type;
# /data/anr - ANR traces
type anr_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/tombstones - core dumps
type tombstone_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/app - user-installed apps
type apk_data_file, file_type, data_file_type, core_data_file_type;
type apk_tmp_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/app-private - forward-locked apps
type apk_private_data_file, file_type, data_file_type, core_data_file_type;
type apk_private_tmp_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/dalvik-cache
type dalvikcache_data_file, file_type, data_file_type, core_data_file_type;
# /data/ota
type ota_data_file, file_type, data_file_type, core_data_file_type;
# /data/ota_package
type ota_package_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/misc/profiles
type user_profile_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/misc/profman
type profman_dump_data_file, file_type, data_file_type, core_data_file_type;
# /data/resource-cache
type resourcecache_data_file, file_type, data_file_type, core_data_file_type;
# /data/local - writable by shell
type shell_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/property
type property_data_file, file_type, data_file_type, core_data_file_type;
# /data/bootchart
type bootchart_data_file, file_type, data_file_type, core_data_file_type;
# /data/system/heapdump
type heapdump_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/nativetest
type nativetest_data_file, file_type, data_file_type, core_data_file_type;
# /data/system_de/0/ringtones
type ringtone_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# /data/preloads
type preloads_data_file, file_type, data_file_type, core_data_file_type;
# /data/preloads/media
type preloads_media_file, file_type, data_file_type, core_data_file_type;
# /data/misc/dhcp and /data/misc/dhcp-6.8.2
type dhcp_data_file, file_type, data_file_type, core_data_file_type;

# Mount locations managed by vold
type mnt_media_rw_file, file_type;
type mnt_user_file, file_type;
type mnt_expand_file, file_type;
type storage_file, file_type;

# Label for storage dirs which are just mount stubs
type mnt_media_rw_stub_file, file_type;
type storage_stub_file, file_type;

# /postinstall: Mount point used by update_engine to run postinstall.
type postinstall_mnt_dir, file_type;
# Files inside the /postinstall mountpoint are all labeled as postinstall_file.
type postinstall_file, file_type;

# /data/misc subdirectories
type adb_keys_file, file_type, data_file_type, core_data_file_type;
type audio_data_file, file_type, data_file_type, core_data_file_type;
type audiohal_data_file, file_type, data_file_type, core_data_file_type;
type audioserver_data_file, file_type, data_file_type, core_data_file_type;
type bluetooth_data_file, file_type, data_file_type, core_data_file_type;
type bluetooth_logs_data_file, file_type, data_file_type, core_data_file_type;
type bootstat_data_file, file_type, data_file_type, core_data_file_type;
type boottrace_data_file, file_type, data_file_type, core_data_file_type;
type camera_data_file, file_type, data_file_type, core_data_file_type;
type gatekeeper_data_file, file_type, data_file_type, core_data_file_type;
type incident_data_file, file_type, data_file_type, core_data_file_type;
type keychain_data_file, file_type, data_file_type, core_data_file_type;
type keystore_data_file, file_type, data_file_type, core_data_file_type;
type media_data_file, file_type, data_file_type, core_data_file_type;
type media_rw_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
type misc_user_data_file, file_type, data_file_type, core_data_file_type;
type net_data_file, file_type, data_file_type, core_data_file_type;
type nfc_data_file, file_type, data_file_type, core_data_file_type;
type radio_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
type reboot_data_file, file_type, data_file_type, core_data_file_type;
type recovery_data_file, file_type, data_file_type, core_data_file_type;
type shared_relro_file, file_type, data_file_type, core_data_file_type;
type systemkeys_data_file, file_type, data_file_type, core_data_file_type;
type textclassifier_data_file, file_type, data_file_type, core_data_file_type;
type vpn_data_file, file_type, data_file_type, core_data_file_type;
type wifi_data_file, file_type, data_file_type, core_data_file_type;
type zoneinfo_data_file, file_type, data_file_type, core_data_file_type;
type vold_data_file, file_type, data_file_type, core_data_file_type;
type perfprofd_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
type tee_data_file, file_type, data_file_type;
type update_engine_data_file, file_type, data_file_type, core_data_file_type;
# /data/misc/trace for method traces on userdebug / eng builds
type method_trace_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;

# /data/data subdirectories - app sandboxes
type app_data_file, file_type, data_file_type, core_data_file_type;
# /data/data subdirectory for system UID apps.
type system_app_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# Compatibility with type name used in Android 4.3 and 4.4.
# Default type for anything under /cache
type cache_file, file_type, data_file_type, mlstrustedobject;
# Type for /cache/backup_stage/* (fd interchange with apps)
type cache_backup_file, file_type, data_file_type, mlstrustedobject;
# type for anything under /cache/backup (local transport storage)
type cache_private_backup_file, file_type, data_file_type;
# Type for anything under /cache/recovery
type cache_recovery_file, file_type, data_file_type, mlstrustedobject;
# Default type for anything under /efs
type efs_file, file_type;
# Type for wallpaper file.
type wallpaper_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# Type for shortcut manager icon file.
type shortcut_manager_icons, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# Type for user icon file.
type icon_file, file_type, data_file_type, core_data_file_type;
# /mnt/asec
type asec_apk_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# Elements of asec files (/mnt/asec) that are world readable
type asec_public_file, file_type, data_file_type, core_data_file_type;
# /data/app-asec
type asec_image_file, file_type, data_file_type, core_data_file_type;
# /data/backup and /data/secure/backup
type backup_data_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;
# All devices have bluetooth efs files. But they
# vary per device, so this type is used in per
# device policy
type bluetooth_efs_file, file_type;
# Type for fingerprint template file
type fingerprintd_data_file, file_type, data_file_type, core_data_file_type;
# Type for appfuse file.
type app_fuse_file, file_type, data_file_type, core_data_file_type, mlstrustedobject;

# Socket types
type adbd_socket, file_type, coredomain_socket;
type bluetooth_socket, file_type, data_file_type, coredomain_socket;
type dnsproxyd_socket, file_type, coredomain_socket, mlstrustedobject;
type dumpstate_socket, file_type, coredomain_socket;
type fwmarkd_socket, file_type, coredomain_socket, mlstrustedobject;
type lmkd_socket, file_type, coredomain_socket;
type logd_socket, file_type, coredomain_socket, mlstrustedobject;
type logdr_socket, file_type, coredomain_socket, mlstrustedobject;
type logdw_socket, file_type, coredomain_socket, mlstrustedobject;
type mdns_socket, file_type, coredomain_socket;
type mdnsd_socket, file_type, coredomain_socket, mlstrustedobject;
type misc_logd_file, coredomain_socket, file_type, data_file_type;
type mtpd_socket, file_type, coredomain_socket;
type netd_socket, file_type, coredomain_socket;
type property_socket, file_type, coredomain_socket, mlstrustedobject;
type racoon_socket, file_type, coredomain_socket;
type rild_socket, file_type;
type rild_debug_socket, file_type;
type system_wpa_socket, file_type, data_file_type, coredomain_socket;
type system_ndebug_socket, file_type, data_file_type, coredomain_socket, mlstrustedobject;
type tombstoned_crash_socket, file_type, coredomain_socket, mlstrustedobject;
type tombstoned_java_trace_socket, file_type, mlstrustedobject;
type tombstoned_intercept_socket, file_type, coredomain_socket;
type uncrypt_socket, file_type, coredomain_socket;
type vold_socket, file_type, coredomain_socket;
type webview_zygote_socket, file_type, coredomain_socket;
type wpa_socket, file_type, data_file_type;
type zygote_socket, file_type, coredomain_socket;
# UART (for GPS) control proc file
type gps_control, file_type;

# PDX endpoint types
type pdx_display_dir, pdx_endpoint_dir_type, file_type;
type pdx_performance_dir, pdx_endpoint_dir_type, file_type;
type pdx_bufferhub_dir, pdx_endpoint_dir_type, file_type;


#line 291
typeattribute pdx_display_dir pdx_display_client_endpoint_dir_type;
#line 291
type pdx_display_client_endpoint_socket, pdx_display_client_endpoint_socket_type, pdx_endpoint_socket_type, file_type, coredomain_socket, mlstrustedobject, mlstrustedsubject;
#line 291
type pdx_display_client_channel_socket, pdx_display_client_channel_socket_type, pdx_channel_socket_type, coredomain_socket;
#line 291

#line 291
dontaudit su pdx_display_client_endpoint_socket:unix_stream_socket *;
#line 291
dontaudit su pdx_display_client_channel_socket:unix_stream_socket *;
#line 291

#line 291


#line 292
typeattribute pdx_display_dir pdx_display_manager_endpoint_dir_type;
#line 292
type pdx_display_manager_endpoint_socket, pdx_display_manager_endpoint_socket_type, pdx_endpoint_socket_type, file_type, coredomain_socket, mlstrustedobject, mlstrustedsubject;
#line 292
type pdx_display_manager_channel_socket, pdx_display_manager_channel_socket_type, pdx_channel_socket_type, coredomain_socket;
#line 292

#line 292
dontaudit su pdx_display_manager_endpoint_socket:unix_stream_socket *;
#line 292
dontaudit su pdx_display_manager_channel_socket:unix_stream_socket *;
#line 292

#line 292


#line 293
typeattribute pdx_display_dir pdx_display_screenshot_endpoint_dir_type;
#line 293
type pdx_display_screenshot_endpoint_socket, pdx_display_screenshot_endpoint_socket_type, pdx_endpoint_socket_type, file_type, coredomain_socket, mlstrustedobject, mlstrustedsubject;
#line 293
type pdx_display_screenshot_channel_socket, pdx_display_screenshot_channel_socket_type, pdx_channel_socket_type, coredomain_socket;
#line 293

#line 293
dontaudit su pdx_display_screenshot_endpoint_socket:unix_stream_socket *;
#line 293
dontaudit su pdx_display_screenshot_channel_socket:unix_stream_socket *;
#line 293

#line 293


#line 294
typeattribute pdx_display_dir pdx_display_vsync_endpoint_dir_type;
#line 294
type pdx_display_vsync_endpoint_socket, pdx_display_vsync_endpoint_socket_type, pdx_endpoint_socket_type, file_type, coredomain_socket, mlstrustedobject, mlstrustedsubject;
#line 294
type pdx_display_vsync_channel_socket, pdx_display_vsync_channel_socket_type, pdx_channel_socket_type, coredomain_socket;
#line 294

#line 294
dontaudit su pdx_display_vsync_endpoint_socket:unix_stream_socket *;
#line 294
dontaudit su pdx_display_vsync_channel_socket:unix_stream_socket *;
#line 294

#line 294


#line 295
typeattribute pdx_performance_dir pdx_performance_client_endpoint_dir_type;
#line 295
type pdx_performance_client_endpoint_socket, pdx_performance_client_endpoint_socket_type, pdx_endpoint_socket_type, file_type, coredomain_socket, mlstrustedobject, mlstrustedsubject;
#line 295
type pdx_performance_client_channel_socket, pdx_performance_client_channel_socket_type, pdx_channel_socket_type, coredomain_socket;
#line 295

#line 295
dontaudit su pdx_performance_client_endpoint_socket:unix_stream_socket *;
#line 295
dontaudit su pdx_performance_client_channel_socket:unix_stream_socket *;
#line 295

#line 295


#line 296
typeattribute pdx_bufferhub_dir pdx_bufferhub_client_endpoint_dir_type;
#line 296
type pdx_bufferhub_client_endpoint_socket, pdx_bufferhub_client_endpoint_socket_type, pdx_endpoint_socket_type, file_type, coredomain_socket, mlstrustedobject, mlstrustedsubject;
#line 296
type pdx_bufferhub_client_channel_socket, pdx_bufferhub_client_channel_socket_type, pdx_channel_socket_type, coredomain_socket;
#line 296

#line 296
dontaudit su pdx_bufferhub_client_endpoint_socket:unix_stream_socket *;
#line 296
dontaudit su pdx_bufferhub_client_channel_socket:unix_stream_socket *;
#line 296

#line 296


# file_contexts files
type file_contexts_file, file_type;

# mac_permissions file
type mac_perms_file, file_type;

# property_contexts file
type property_contexts_file, file_type;

# seapp_contexts file
type seapp_contexts_file, file_type;

# sepolicy files binary and others
type sepolicy_file, file_type;

# service_contexts file
type service_contexts_file, file_type;

# nonplat service_contexts file (only accessible on non full-treble devices)
type nonplat_service_contexts_file, file_type;

# hwservice_contexts file
type hwservice_contexts_file, file_type;

# vndservice_contexts file
type vndservice_contexts_file, file_type;

# Allow files to be created in their appropriate filesystems.
allow fs_type self:filesystem associate;
allow cgroup tmpfs:filesystem associate;
allow sysfs_type sysfs:filesystem associate;
allow debugfs_type { debugfs debugfs_tracing }:filesystem associate;
allow file_type labeledfs:filesystem associate;
allow file_type tmpfs:filesystem associate;
allow file_type rootfs:filesystem associate;
allow dev_type tmpfs:filesystem associate;
allow app_fuse_file app_fusefs:filesystem associate;
allow postinstall_file self:filesystem associate;

# asanwrapper (run a sanitized app_process, to be used with wrap properties)


# It's a bug to assign the file_type attribute and fs_type attribute
# to any type. Do not allow it.
#
# For example, the following is a bug:
#   type apk_data_file, file_type, data_file_type, fs_type;
# Should be:
#   type apk_data_file, file_type, data_file_type;
neverallow fs_type file_type:filesystem associate;
#line 1 "system/sepolicy/public/fingerprintd.te"
type fingerprintd, domain;
type fingerprintd_exec, exec_type, file_type;


#line 4
# Call the servicemanager and transfer references to it.
#line 4
allow fingerprintd servicemanager:binder { call transfer };
#line 4
# servicemanager performs getpidcon on clients.
#line 4
allow servicemanager fingerprintd:dir search;
#line 4
allow servicemanager fingerprintd:file { read open };
#line 4
allow servicemanager fingerprintd:process getattr;
#line 4
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 4
# all domains in domain.te.
#line 4


# Scan through /system/lib64/hw looking for installed HALs
allow fingerprintd system_file:dir { open getattr read search ioctl lock };

# need to find KeyStore and add self

#line 10
  allow fingerprintd fingerprintd_service:service_manager { add find };
#line 10
  neverallow { domain -fingerprintd } fingerprintd_service:service_manager add;
#line 10


# allow HAL module to read dir contents
allow fingerprintd fingerprintd_data_file:file { { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } };

# allow HAL module to read/write/unlink contents of this dir
allow fingerprintd fingerprintd_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };

# Need to add auth tokens to KeyStore

#line 19
  allow keystore fingerprintd:dir search;
#line 19
  allow keystore fingerprintd:file { read open };
#line 19
  allow keystore fingerprintd:process getattr;
#line 19
  allow fingerprintd keystore_service:service_manager find;
#line 19
  
#line 19
# Call the server domain and optionally transfer references to it.
#line 19
allow fingerprintd keystore:binder { call transfer };
#line 19
# Allow the serverdomain to transfer references to the client on the reply.
#line 19
allow keystore fingerprintd:binder transfer;
#line 19
# Receive and use open files from the server.
#line 19
allow fingerprintd keystore:fd use;
#line 19

#line 19

allow fingerprintd keystore:keystore_key { add_auth };

# For permissions checking

#line 23
# Call the server domain and optionally transfer references to it.
#line 23
allow fingerprintd system_server:binder { call transfer };
#line 23
# Allow the serverdomain to transfer references to the client on the reply.
#line 23
allow system_server fingerprintd:binder transfer;
#line 23
# Receive and use open files from the server.
#line 23
allow fingerprintd system_server:fd use;
#line 23
;
allow fingerprintd permission_service:service_manager find;


#line 26
allow fingerprintd cgroup:dir { open getattr read search ioctl lock };
#line 26
allow fingerprintd cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 26


#line 27
allow fingerprintd sysfs_type:dir { open getattr read search ioctl lock };
#line 27
allow fingerprintd sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 27

allow fingerprintd ion_device:chr_file { getattr open read ioctl lock map };
#line 1 "system/sepolicy/public/fsck.te"
# Any fsck program run by init
type fsck, domain;
type fsck_exec, exec_type, file_type;

# /dev/__null__ created by init prior to policy load,
# open fd inherited by fsck.
allow fsck tmpfs:chr_file { read write ioctl };

# Inherit and use pty created by android_fork_execvp_ext().
allow fsck devpts:chr_file { read write ioctl getattr };

# Allow stdin/out back to vold
allow fsck vold:fd use;
allow fsck vold:fifo_file { read write getattr };

# Run fsck on certain block devices
allow fsck block_device:dir search;
allow fsck userdata_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };
allow fsck cache_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };
allow fsck dm_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# To determine if it is safe to run fsck on a filesystem, e2fsck
# must first determine if the filesystem is mounted. To do that,
# e2fsck scans through /proc/mounts and collects all the mounted
# block devices. With that information, it runs stat() on each block
# device, comparing the major and minor numbers to the filesystem
# passed in on the command line. If there is a match, then the filesystem
# is currently mounted and running fsck is dangerous.
# Allow stat access to all block devices so that fsck can compare
# major/minor values.
allow fsck dev_type:blk_file getattr;


#line 33
allow fsck proc:dir { open getattr read search ioctl lock };
#line 33
allow fsck proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 33

allow fsck rootfs:dir { open getattr read search ioctl lock };

###
### neverallow rules
###

# fsck should never be run on these block devices
neverallow fsck {
  boot_block_device
  frp_block_device
  metadata_block_device
  recovery_block_device
  root_block_device
  swap_block_device
  system_block_device
  vold_device
}:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Only allow entry from init or vold via fsck binaries
neverallow { domain -init -vold } fsck:process transition;
neverallow * fsck:process dyntransition;
neverallow fsck { file_type fs_type -fsck_exec }:file entrypoint;
#line 1 "system/sepolicy/public/fsck_untrusted.te"
# Any fsck program run on untrusted block devices
type fsck_untrusted, domain;

# Inherit and use pty created by android_fork_execvp_ext().
allow fsck_untrusted devpts:chr_file { read write ioctl getattr };

# Allow stdin/out back to vold
allow fsck_untrusted vold:fd use;
allow fsck_untrusted vold:fifo_file { read write getattr };

# Run fsck on vold block devices
allow fsck_untrusted block_device:dir search;
allow fsck_untrusted vold_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };


#line 15
allow fsck_untrusted proc:dir { open getattr read search ioctl lock };
#line 15
allow fsck_untrusted proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 15


# To determine if it is safe to run fsck on a filesystem, e2fsck
# must first determine if the filesystem is mounted. To do that,
# e2fsck scans through /proc/mounts and collects all the mounted
# block devices. With that information, it runs stat() on each block
# device, comparing the major and minor numbers to the filesystem
# passed in on the command line. If there is a match, then the filesystem
# is currently mounted and running fsck is dangerous.
# Allow stat access to all block devices so that fsck can compare
# major/minor values.
allow fsck_untrusted dev_type:blk_file getattr;

###
### neverallow rules
###

# Untrusted fsck should never be run on block devices holding sensitive data
neverallow fsck_untrusted {
  boot_block_device
  frp_block_device
  metadata_block_device
  recovery_block_device
  root_block_device
  swap_block_device
  system_block_device
  userdata_block_device
  cache_block_device
  dm_device
}:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Only allow entry from vold via fsck binaries
neverallow { domain -vold } fsck_untrusted:process transition;
neverallow * fsck_untrusted:process dyntransition;
neverallow fsck_untrusted { file_type fs_type -fsck_exec }:file entrypoint;
#line 1 "system/sepolicy/public/gatekeeperd.te"
type gatekeeperd, domain;
type gatekeeperd_exec, exec_type, file_type;

# gatekeeperd

#line 5
typeattribute gatekeeperd binderservicedomain;
#line 5


#line 6
# Call the servicemanager and transfer references to it.
#line 6
allow gatekeeperd servicemanager:binder { call transfer };
#line 6
# servicemanager performs getpidcon on clients.
#line 6
allow servicemanager gatekeeperd:dir search;
#line 6
allow servicemanager gatekeeperd:file { read open };
#line 6
allow servicemanager gatekeeperd:process getattr;
#line 6
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 6
# all domains in domain.te.
#line 6


### Rules needed when Gatekeeper HAL runs inside gatekeeperd process.
### These rules should eventually be granted only when needed.
allow gatekeeperd tee_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow gatekeeperd ion_device:chr_file { getattr open read ioctl lock map };
# Load HAL implementation
allow gatekeeperd system_file:dir { open getattr read search ioctl lock };
###

### Rules needed when Gatekeeper HAL runs outside of gatekeeperd process.
### These rules should eventually be granted only when needed.

#line 18
typeattribute gatekeeperd halclientdomain;
#line 18
typeattribute gatekeeperd hal_gatekeeper_client;
#line 18

#line 18
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 18
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 18
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 18

#line 18
typeattribute gatekeeperd hal_gatekeeper;
#line 18
# Find passthrough HAL implementations
#line 18
allow hal_gatekeeper system_file:dir { open getattr read search ioctl lock };
#line 18
allow hal_gatekeeper vendor_file:dir { open getattr read search ioctl lock };
#line 18
allow hal_gatekeeper vendor_file:file { read open getattr execute map };
#line 18

#line 18

###

# need to find KeyStore and add self

#line 22
  allow gatekeeperd gatekeeper_service:service_manager { add find };
#line 22
  neverallow { domain -gatekeeperd } gatekeeper_service:service_manager add;
#line 22


# Need to add auth tokens to KeyStore

#line 25
  allow keystore gatekeeperd:dir search;
#line 25
  allow keystore gatekeeperd:file { read open };
#line 25
  allow keystore gatekeeperd:process getattr;
#line 25
  allow gatekeeperd keystore_service:service_manager find;
#line 25
  
#line 25
# Call the server domain and optionally transfer references to it.
#line 25
allow gatekeeperd keystore:binder { call transfer };
#line 25
# Allow the serverdomain to transfer references to the client on the reply.
#line 25
allow keystore gatekeeperd:binder transfer;
#line 25
# Receive and use open files from the server.
#line 25
allow gatekeeperd keystore:fd use;
#line 25

#line 25

allow gatekeeperd keystore:keystore_key { add_auth };

# For permissions checking
allow gatekeeperd system_server:binder call;
allow gatekeeperd permission_service:service_manager find;

# for SID file access
allow gatekeeperd gatekeeper_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow gatekeeperd gatekeeper_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# For hardware properties retrieval
allow gatekeeperd hardware_properties_service:service_manager find;


#line 39
allow gatekeeperd cgroup:dir { open getattr read search ioctl lock };
#line 39
allow gatekeeperd cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 39

#line 1 "system/sepolicy/public/hal_allocator.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_allocator_client hal_allocator_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_allocator_server hal_allocator_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_allocator_client hal_allocator_server:fd use;
#line 2



#line 4
  allow hal_allocator_server hidl_allocator_hwservice:hwservice_manager { add find };
#line 4
  allow hal_allocator_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_allocator_server } hidl_allocator_hwservice:hwservice_manager add;
#line 4

allow hal_allocator_client hidl_allocator_hwservice:hwservice_manager find;
allow hal_allocator_client hidl_memory_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_audio.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_audio_client hal_audio_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_audio_server hal_audio_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_audio_client hal_audio_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_audio_server hal_audio_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_audio_client hal_audio_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_audio_server hal_audio_client:fd use;
#line 3



#line 5
  allow hal_audio_server hal_audio_hwservice:hwservice_manager { add find };
#line 5
  allow hal_audio_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_audio_server } hal_audio_hwservice:hwservice_manager add;
#line 5

allow hal_audio_client hal_audio_hwservice:hwservice_manager find;

allow hal_audio ion_device:chr_file { getattr open read ioctl lock map };


#line 10
  # used for pcm capture for debug.
#line 10
  allow hal_audio audiohal_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
#line 10
  allow hal_audio audiohal_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 14



#line 16
allow hal_audio proc:dir { open getattr read search ioctl lock };
#line 16
allow hal_audio proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 16

allow hal_audio audio_device:dir { open getattr read search ioctl lock };
allow hal_audio audio_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Needed to provide debug dump output via dumpsys' pipes.
allow hal_audio shell:fd use;
allow hal_audio shell:fifo_file write;
allow hal_audio dumpstate:fd use;
allow hal_audio dumpstate:fifo_file write;

###
### neverallow rules
###

# Should never execute any executable without a domain transition
neverallow hal_audio { file_type fs_type }:file execute_no_trans;

# Should never need network access.
# Disallow network sockets.
neverallow hal_audio domain:{ tcp_socket udp_socket rawip_socket } *;

# Only audio HAL may directly access the audio hardware
neverallow { halserverdomain -hal_audio_server } audio_device:chr_file *;
#line 1 "system/sepolicy/public/hal_bluetooth.te"
# HwBinder IPC from clients into server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_bluetooth_client hal_bluetooth_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_bluetooth_server hal_bluetooth_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_bluetooth_client hal_bluetooth_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_bluetooth_server hal_bluetooth_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_bluetooth_client hal_bluetooth_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_bluetooth_server hal_bluetooth_client:fd use;
#line 3



#line 5
  allow hal_bluetooth_server hal_bluetooth_hwservice:hwservice_manager { add find };
#line 5
  allow hal_bluetooth_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_bluetooth_server } hal_bluetooth_hwservice:hwservice_manager add;
#line 5

allow hal_bluetooth_client hal_bluetooth_hwservice:hwservice_manager find;


#line 8
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 8
allow hal_bluetooth sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 8
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 8
allow hal_bluetooth self:capability2 block_suspend;
#line 8
;

# The HAL toggles rfkill to power the chip off/on.
allow hal_bluetooth self:capability net_admin;

# bluetooth factory file accesses.

#line 14
allow hal_bluetooth bluetooth_efs_file:dir { open getattr read search ioctl lock };
#line 14
allow hal_bluetooth bluetooth_efs_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 14


allow hal_bluetooth { uhid_device hci_attach_dev }:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# sysfs access.

#line 19
allow hal_bluetooth sysfs_type:dir { open getattr read search ioctl lock };
#line 19
allow hal_bluetooth sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 19

allow hal_bluetooth sysfs_bluetooth_writable:file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_bluetooth self:capability2 wake_alarm;

# Allow write access to bluetooth-specific properties

#line 24

#line 24
allow hal_bluetooth property_socket:sock_file write;
#line 24
allow hal_bluetooth init:unix_stream_socket connectto;
#line 24

#line 24
allow hal_bluetooth bluetooth_prop:property_service set;
#line 24

#line 24
allow hal_bluetooth bluetooth_prop:file { getattr open read ioctl lock map };
#line 24

#line 24


# /proc access (bluesleep etc.).
allow hal_bluetooth proc_bluetooth_writable:file { { getattr open read ioctl lock map } { open append write lock map } };

# allow to run with real-time scheduling policy
allow hal_bluetooth self:capability sys_nice;
#line 1 "system/sepolicy/public/hal_bootctl.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_bootctl_client hal_bootctl_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_bootctl_server hal_bootctl_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_bootctl_client hal_bootctl_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_bootctl_server hal_bootctl_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_bootctl_client hal_bootctl_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_bootctl_server hal_bootctl_client:fd use;
#line 3



#line 5
  allow hal_bootctl_server hal_bootctl_hwservice:hwservice_manager { add find };
#line 5
  allow hal_bootctl_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_bootctl_server } hal_bootctl_hwservice:hwservice_manager add;
#line 5

allow hal_bootctl_client hal_bootctl_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_broadcastradio.te"

#line 1
# Call the server domain and optionally transfer references to it.
#line 1
allow hal_broadcastradio_client hal_broadcastradio_server:binder { call transfer };
#line 1
# Allow the serverdomain to transfer references to the client on the reply.
#line 1
allow hal_broadcastradio_server hal_broadcastradio_client:binder transfer;
#line 1
# Receive and use open files from the server.
#line 1
allow hal_broadcastradio_client hal_broadcastradio_server:fd use;
#line 1



#line 3
  allow hal_broadcastradio_server hal_broadcastradio_hwservice:hwservice_manager { add find };
#line 3
  allow hal_broadcastradio_server hidl_base_hwservice:hwservice_manager add;
#line 3
  neverallow { domain -hal_broadcastradio_server } hal_broadcastradio_hwservice:hwservice_manager add;
#line 3

allow hal_broadcastradio_client hal_broadcastradio_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_camera.te"
# HwBinder IPC from clients to server and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_camera_client hal_camera_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_camera_server hal_camera_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_camera_client hal_camera_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_camera_server hal_camera_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_camera_client hal_camera_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_camera_server hal_camera_client:fd use;
#line 3



#line 5
  allow hal_camera_server hal_camera_hwservice:hwservice_manager { add find };
#line 5
  allow hal_camera_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_camera_server } hal_camera_hwservice:hwservice_manager add;
#line 5

allow hal_camera_client hal_camera_hwservice:hwservice_manager find;

# access /data/misc/camera
allow hal_camera camera_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow hal_camera camera_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

allow hal_camera video_device:dir { open getattr read search ioctl lock };
allow hal_camera video_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_camera camera_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_camera ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
# Both the client and the server need to use the graphics allocator
allow { hal_camera_client hal_camera_server } hal_graphics_allocator:fd use;

# Allow hal_camera to use fd from app,gralloc,and ashmem HAL
allow hal_camera { appdomain -isolated_app }:fd use;
allow hal_camera surfaceflinger:fd use;
allow hal_camera hal_allocator_server:fd use;

###
### neverallow rules
###

# hal_camera should never execute any executable without a
# domain transition
neverallow hal_camera { file_type fs_type }:file execute_no_trans;

# hal_camera should never need network access. Disallow network sockets.
neverallow hal_camera domain:{ tcp_socket udp_socket rawip_socket } *;

# Only camera HAL may directly access the camera hardware
neverallow { halserverdomain -hal_camera_server } camera_device:chr_file *;
#line 1 "system/sepolicy/public/hal_cas.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_cas_client hal_cas_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_cas_server hal_cas_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_cas_client hal_cas_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_cas_server hal_cas_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_cas_client hal_cas_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_cas_server hal_cas_client:fd use;
#line 3



#line 5
  allow hal_cas_server hal_cas_hwservice:hwservice_manager { add find };
#line 5
  allow hal_cas_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_cas_server } hal_cas_hwservice:hwservice_manager add;
#line 5

allow hal_cas_client hal_cas_hwservice:hwservice_manager find;
allow hal_cas_server hidl_memory_hwservice:hwservice_manager find;

# Permit reading device's serial number from system properties

#line 10
allow hal_cas serialno_prop:file { getattr open read ioctl lock map };
#line 10


# Read files already opened under /data
allow hal_cas system_data_file:dir { search getattr };
allow hal_cas system_data_file:file { getattr read };
allow hal_cas system_data_file:lnk_file { getattr open read ioctl lock map };

# Read access to pseudo filesystems

#line 18
allow hal_cas cgroup:dir { open getattr read search ioctl lock };
#line 18
allow hal_cas cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 18

allow hal_cas cgroup:dir { search write };
allow hal_cas cgroup:file { open append write lock map };

# Allow access to ion memory allocation device
allow hal_cas ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_cas hal_graphics_allocator:fd use;

allow hal_cas tee_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

###
### neverallow rules
###

# hal_cas should never execute any executable without a
# domain transition
neverallow hal_cas { file_type fs_type }:file execute_no_trans;

# do not allow privileged socket ioctl commands
neverallowxperm hal_cas domain:{ rawip_socket tcp_socket udp_socket } ioctl 
#line 37
{
#line 37
# qualcomm rmnet ioctls
#line 37
0x00006900 0x00006902
#line 37
# socket ioctls
#line 37
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 37
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 37
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 37
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 37
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 37
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 37
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 37
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 37
0x00008991 0x00008992 0x00008993 0x00008994
#line 37
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 37
# device and protocol specific ioctls
#line 37
0x000089f0-0x000089ff
#line 37
0x000089e0-0x000089ef
#line 37
# Wireless extension ioctls
#line 37
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 37
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 37
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 37
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 37
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 37
0x00008b34 0x00008b35 0x00008b36
#line 37
# Dev private ioctl i.e. hardware specific ioctls
#line 37
0x00008be0-0x00008bff
#line 37
};
#line 1 "system/sepolicy/public/hal_configstore.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_configstore_client hal_configstore_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_configstore_server hal_configstore_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_configstore_client hal_configstore_server:fd use;
#line 2


allow hal_configstore_client hal_configstore_ISurfaceFlingerConfigs:hwservice_manager find;


#line 6
  allow hal_configstore_server hal_configstore_ISurfaceFlingerConfigs:hwservice_manager { add find };
#line 6
  allow hal_configstore_server hidl_base_hwservice:hwservice_manager add;
#line 6
  neverallow { domain -hal_configstore_server } hal_configstore_ISurfaceFlingerConfigs:hwservice_manager add;
#line 6

# As opposed to the rules of most other HALs, the different services exposed by
# this HAL should be restricted to different clients. Thus, the allow rules for
# clients are defined in the .te files of the clients.

# hal_configstore runs with a strict seccomp filter. Use crash_dump's
# fallback path to collect crash data.

#line 13

#line 13
  allow hal_configstore_server su:fifo_file append;
#line 13

#line 13
allow hal_configstore_server anr_data_file:file append;
#line 13
allow hal_configstore_server dumpstate:fd use;
#line 13
# TODO: Figure out why write is needed.
#line 13
allow hal_configstore_server dumpstate:fifo_file { append write };
#line 13
allow hal_configstore_server system_server:fifo_file { append write };
#line 13
allow hal_configstore_server tombstoned:unix_stream_socket connectto;
#line 13
allow hal_configstore_server tombstoned:fd use;
#line 13
allow hal_configstore_server tombstoned_crash_socket:sock_file write;
#line 13
allow hal_configstore_server tombstone_data_file:file append;
#line 13


###
### neverallow rules
###

# Should never execute an executable without a domain transition
neverallow hal_configstore_server { file_type fs_type }:file execute_no_trans;

# Should never need network access. Disallow sockets except for
# for unix stream/dgram sockets used for logging/debugging.
neverallow hal_configstore_server domain:{
  rawip_socket tcp_socket udp_socket
  netlink_route_socket netlink_selinux_socket
  socket netlink_socket packet_socket key_socket appletalk_socket
  netlink_tcpdiag_socket netlink_nflog_socket
  netlink_xfrm_socket netlink_audit_socket
  netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket
  netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket
  netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket
  netlink_rdma_socket netlink_crypto_socket
} *;
neverallow hal_configstore_server {
  domain
  -hal_configstore_server
  -logd
  -su
  -tombstoned
}:{ unix_dgram_socket unix_stream_socket } *;

# Should never need access to anything on /data
neverallow hal_configstore_server {
  data_file_type
  -anr_data_file # for crash dump collection
  -tombstone_data_file # for crash dump collection
  -zoneinfo_data_file # granted to domain
}:{ file fifo_file sock_file } *;

# Should never need sdcard access
neverallow hal_configstore_server { fuse sdcardfs vfat }:file *;

# Do not permit access to service_manager and vndservice_manager
neverallow hal_configstore_server *:service_manager *;

# No privileged capabilities
neverallow hal_configstore_server self:{ capability capability2 } *;

# No ptracing other processes
neverallow hal_configstore_server *:process ptrace;

# no relabeling
neverallow hal_configstore_server *:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { relabelfrom relabelto };
#line 1 "system/sepolicy/public/hal_contexthub.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_contexthub_client hal_contexthub_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_contexthub_server hal_contexthub_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_contexthub_client hal_contexthub_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_contexthub_server hal_contexthub_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_contexthub_client hal_contexthub_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_contexthub_server hal_contexthub_client:fd use;
#line 3



#line 5
  allow hal_contexthub_server hal_contexthub_hwservice:hwservice_manager { add find };
#line 5
  allow hal_contexthub_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_contexthub_server } hal_contexthub_hwservice:hwservice_manager add;
#line 5

allow hal_contexthub_client hal_contexthub_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_drm.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_drm_client hal_drm_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_drm_server hal_drm_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_drm_client hal_drm_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_drm_server hal_drm_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_drm_client hal_drm_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_drm_server hal_drm_client:fd use;
#line 3



#line 5
  allow hal_drm_server hal_drm_hwservice:hwservice_manager { add find };
#line 5
  allow hal_drm_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_drm_server } hal_drm_hwservice:hwservice_manager add;
#line 5

allow hal_drm_client hal_drm_hwservice:hwservice_manager find;

allow hal_drm hidl_memory_hwservice:hwservice_manager find;

# Required by Widevine DRM (b/22990512)
allow hal_drm self:process execmem;

# Permit reading device's serial number from system properties

#line 14
allow hal_drm serialno_prop:file { getattr open read ioctl lock map };
#line 14


# System file accesses
allow hal_drm system_file:dir { open getattr read search ioctl lock };
allow hal_drm system_file:file { getattr open read ioctl lock map };
allow hal_drm system_file:lnk_file { getattr open read ioctl lock map };

# Read files already opened under /data
allow hal_drm system_data_file:dir { search getattr };
allow hal_drm system_data_file:file { getattr read };
allow hal_drm system_data_file:lnk_file { getattr open read ioctl lock map };

# Read access to pseudo filesystems

#line 27
allow hal_drm cgroup:dir { open getattr read search ioctl lock };
#line 27
allow hal_drm cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 27

allow hal_drm cgroup:dir { search write };
allow hal_drm cgroup:file { open append write lock map };

# Allow access to ion memory allocation device
allow hal_drm ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_drm hal_graphics_allocator:fd use;

# Allow access to fds allocated by mediaserver
allow hal_drm mediaserver:fd use;

# Allow access to app_data and media_data_files
allow hal_drm media_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow hal_drm media_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow hal_drm media_data_file:file { getattr read };

allow hal_drm sysfs:file { getattr open read ioctl lock map };

allow hal_drm tee_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# only allow unprivileged socket ioctl commands
allowxperm hal_drm self:{ rawip_socket tcp_socket udp_socket }
  ioctl { 
#line 49
{
#line 49
# Socket ioctls for gathering information about the interface
#line 49
0x00008906 0x00008907
#line 49
0x00008910 0x00008912 0x00008913 0x00008915 0x00008917 0x00008919
#line 49
0x0000891b 0x00008921 0x00008933 0x00008938 0x00008942
#line 49
# Wireless extension ioctls. Primarily get functions.
#line 49
0x00008b01 0x00008b05 0x00008b07 0x00008b09 0x00008b0b 0x00008b0d
#line 49
0x00008b0f 0x00008b11 0x00008b12 0x00008b13 0x00008b21 0x00008b23
#line 49
0x00008b25 0x00008b27 0x00008b29 0x00008b2d
#line 49
} {
#line 49
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 49
  0x0000540b 0x00005410 0x0000540f
#line 49
} };

###
### neverallow rules
###

# hal_drm should never execute any executable without a
# domain transition
neverallow hal_drm { file_type fs_type }:file execute_no_trans;

# do not allow privileged socket ioctl commands
neverallowxperm hal_drm domain:{ rawip_socket tcp_socket udp_socket } ioctl 
#line 60
{
#line 60
# qualcomm rmnet ioctls
#line 60
0x00006900 0x00006902
#line 60
# socket ioctls
#line 60
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 60
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 60
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 60
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 60
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 60
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 60
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 60
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 60
0x00008991 0x00008992 0x00008993 0x00008994
#line 60
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 60
# device and protocol specific ioctls
#line 60
0x000089f0-0x000089ff
#line 60
0x000089e0-0x000089ef
#line 60
# Wireless extension ioctls
#line 60
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 60
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 60
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 60
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 60
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 60
0x00008b34 0x00008b35 0x00008b36
#line 60
# Dev private ioctl i.e. hardware specific ioctls
#line 60
0x00008be0-0x00008bff
#line 60
};
#line 1 "system/sepolicy/public/hal_dumpstate.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_dumpstate_client hal_dumpstate_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_dumpstate_server hal_dumpstate_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_dumpstate_client hal_dumpstate_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_dumpstate_server hal_dumpstate_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_dumpstate_client hal_dumpstate_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_dumpstate_server hal_dumpstate_client:fd use;
#line 3



#line 5
  allow hal_dumpstate_server hal_dumpstate_hwservice:hwservice_manager { add find };
#line 5
  allow hal_dumpstate_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_dumpstate_server } hal_dumpstate_hwservice:hwservice_manager add;
#line 5

allow hal_dumpstate_client hal_dumpstate_hwservice:hwservice_manager find;

# write bug reports in /data/data/com.android.shell/files/bugreports/bugreport
allow hal_dumpstate shell_data_file:file write;
# allow reading /proc/interrupts for all hal impls
allow hal_dumpstate proc_interrupts:file { getattr open read ioctl lock map };
#line 1 "system/sepolicy/public/hal_fingerprint.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_fingerprint_client hal_fingerprint_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_fingerprint_server hal_fingerprint_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_fingerprint_client hal_fingerprint_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_fingerprint_server hal_fingerprint_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_fingerprint_client hal_fingerprint_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_fingerprint_server hal_fingerprint_client:fd use;
#line 3



#line 5
  allow hal_fingerprint_server hal_fingerprint_hwservice:hwservice_manager { add find };
#line 5
  allow hal_fingerprint_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_fingerprint_server } hal_fingerprint_hwservice:hwservice_manager add;
#line 5

allow hal_fingerprint_client hal_fingerprint_hwservice:hwservice_manager find;

# allow HAL module to read dir contents
allow hal_fingerprint fingerprintd_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# allow HAL module to read/write/unlink contents of this dir
allow hal_fingerprint fingerprintd_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };

# For memory allocation
allow hal_fingerprint ion_device:chr_file { getattr open read ioctl lock map };


#line 17
allow hal_fingerprint cgroup:dir { open getattr read search ioctl lock };
#line 17
allow hal_fingerprint cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 17


#line 18
allow hal_fingerprint sysfs:dir { open getattr read search ioctl lock };
#line 18
allow hal_fingerprint sysfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 18

#line 1 "system/sepolicy/public/hal_gatekeeper.te"

#line 1
# Call the server domain and optionally transfer references to it.
#line 1
allow hal_gatekeeper_client hal_gatekeeper_server:binder { call transfer };
#line 1
# Allow the serverdomain to transfer references to the client on the reply.
#line 1
allow hal_gatekeeper_server hal_gatekeeper_client:binder transfer;
#line 1
# Receive and use open files from the server.
#line 1
allow hal_gatekeeper_client hal_gatekeeper_server:fd use;
#line 1



#line 3
  allow hal_gatekeeper_server hal_gatekeeper_hwservice:hwservice_manager { add find };
#line 3
  allow hal_gatekeeper_server hidl_base_hwservice:hwservice_manager add;
#line 3
  neverallow { domain -hal_gatekeeper_server } hal_gatekeeper_hwservice:hwservice_manager add;
#line 3

allow hal_gatekeeper_client hal_gatekeeper_hwservice:hwservice_manager find;

# TEE access.
allow hal_gatekeeper tee_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_gatekeeper ion_device:chr_file { getattr open read ioctl lock map };
#line 1 "system/sepolicy/public/hal_gnss.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_gnss_client hal_gnss_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_gnss_server hal_gnss_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_gnss_client hal_gnss_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_gnss_server hal_gnss_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_gnss_client hal_gnss_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_gnss_server hal_gnss_client:fd use;
#line 3



#line 5
  allow hal_gnss_server hal_gnss_hwservice:hwservice_manager { add find };
#line 5
  allow hal_gnss_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_gnss_server } hal_gnss_hwservice:hwservice_manager add;
#line 5

allow hal_gnss_client hal_gnss_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_graphics_allocator.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_graphics_allocator_client hal_graphics_allocator_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_graphics_allocator_server hal_graphics_allocator_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_graphics_allocator_client hal_graphics_allocator_server:fd use;
#line 2



#line 4
  allow hal_graphics_allocator_server hal_graphics_allocator_hwservice:hwservice_manager { add find };
#line 4
  allow hal_graphics_allocator_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_graphics_allocator_server } hal_graphics_allocator_hwservice:hwservice_manager add;
#line 4

allow hal_graphics_allocator_client hal_graphics_allocator_hwservice:hwservice_manager find;
allow hal_graphics_allocator_client hal_graphics_mapper_hwservice:hwservice_manager find;

# GPU device access
allow hal_graphics_allocator gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_graphics_allocator ion_device:chr_file { getattr open read ioctl lock map };

# allow to run with real-time scheduling policy
allow hal_graphics_allocator self:capability sys_nice;
#line 1 "system/sepolicy/public/hal_graphics_composer.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_graphics_composer_client hal_graphics_composer_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_graphics_composer_server hal_graphics_composer_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_graphics_composer_client hal_graphics_composer_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_graphics_composer_server hal_graphics_composer_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_graphics_composer_client hal_graphics_composer_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_graphics_composer_server hal_graphics_composer_client:fd use;
#line 3



#line 5
  allow hal_graphics_composer_server hal_graphics_composer_hwservice:hwservice_manager { add find };
#line 5
  allow hal_graphics_composer_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_graphics_composer_server } hal_graphics_composer_hwservice:hwservice_manager add;
#line 5

allow hal_graphics_composer_client hal_graphics_composer_hwservice:hwservice_manager find;

# Coordinate with hal_graphics_mapper
allow hal_graphics_composer_server hal_graphics_mapper_hwservice:hwservice_manager find;

# GPU device access
allow hal_graphics_composer gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_graphics_composer ion_device:chr_file { getattr open read ioctl lock map };
allow hal_graphics_composer hal_graphics_allocator:fd use;

# Access /dev/graphics/fb0.
allow hal_graphics_composer graphics_device:dir search;
allow hal_graphics_composer graphics_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Fences
allow hal_graphics_composer system_server:fd use;
allow hal_graphics_composer bootanim:fd use;
allow hal_graphics_composer appdomain:fd use;

# allow self to set SCHED_FIFO
allow hal_graphics_composer self:capability sys_nice;
#line 1 "system/sepolicy/public/hal_health.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_health_client hal_health_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_health_server hal_health_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_health_client hal_health_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_health_server hal_health_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_health_client hal_health_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_health_server hal_health_client:fd use;
#line 3



#line 5
  allow hal_health_server hal_health_hwservice:hwservice_manager { add find };
#line 5
  allow hal_health_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_health_server } hal_health_hwservice:hwservice_manager add;
#line 5

allow hal_health_client hal_health_hwservice:hwservice_manager find;

# Read access to system files for HALs in
# /{system,vendor,odm}/lib[64]/hw/ in order
# to be able to open the hal implementation .so files

#line 11
allow hal_health system_file:dir { open getattr read search ioctl lock };
#line 11
allow hal_health system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 11

#line 1 "system/sepolicy/public/hal_ir.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_ir_client hal_ir_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_ir_server hal_ir_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_ir_client hal_ir_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_ir_server hal_ir_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_ir_client hal_ir_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_ir_server hal_ir_client:fd use;
#line 3



#line 5
  allow hal_ir_server hal_ir_hwservice:hwservice_manager { add find };
#line 5
  allow hal_ir_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_ir_server } hal_ir_hwservice:hwservice_manager add;
#line 5

allow hal_ir_client hal_ir_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_keymaster.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_keymaster_client hal_keymaster_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_keymaster_server hal_keymaster_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_keymaster_client hal_keymaster_server:fd use;
#line 2



#line 4
  allow hal_keymaster_server hal_keymaster_hwservice:hwservice_manager { add find };
#line 4
  allow hal_keymaster_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_keymaster_server } hal_keymaster_hwservice:hwservice_manager add;
#line 4

allow hal_keymaster_client hal_keymaster_hwservice:hwservice_manager find;

allow hal_keymaster tee_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_keymaster ion_device:chr_file { getattr open read ioctl lock map };
#line 1 "system/sepolicy/public/hal_light.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_light_client hal_light_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_light_server hal_light_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_light_client hal_light_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_light_server hal_light_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_light_client hal_light_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_light_server hal_light_client:fd use;
#line 3



#line 5
  allow hal_light_server hal_light_hwservice:hwservice_manager { add find };
#line 5
  allow hal_light_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_light_server } hal_light_hwservice:hwservice_manager add;
#line 5

allow hal_light_client hal_light_hwservice:hwservice_manager find;

allow hal_light sysfs_leds:lnk_file read;
allow hal_light sysfs_leds:file { { getattr open read ioctl lock map } { open append write lock map } };
allow hal_light sysfs_leds:dir { open getattr read search ioctl lock };
#line 1 "system/sepolicy/public/hal_memtrack.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_memtrack_client hal_memtrack_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_memtrack_server hal_memtrack_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_memtrack_client hal_memtrack_server:fd use;
#line 2



#line 4
  allow hal_memtrack_server hal_memtrack_hwservice:hwservice_manager { add find };
#line 4
  allow hal_memtrack_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_memtrack_server } hal_memtrack_hwservice:hwservice_manager add;
#line 4

allow hal_memtrack_client hal_memtrack_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_neuralnetworks.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_neuralnetworks_client hal_neuralnetworks_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_neuralnetworks_server hal_neuralnetworks_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_neuralnetworks_client hal_neuralnetworks_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_neuralnetworks_server hal_neuralnetworks_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_neuralnetworks_client hal_neuralnetworks_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_neuralnetworks_server hal_neuralnetworks_client:fd use;
#line 3



#line 5
  allow hal_neuralnetworks_server hal_neuralnetworks_hwservice:hwservice_manager { add find };
#line 5
  allow hal_neuralnetworks_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_neuralnetworks_server } hal_neuralnetworks_hwservice:hwservice_manager add;
#line 5

allow hal_neuralnetworks_client hal_neuralnetworks_hwservice:hwservice_manager find;
allow hal_neuralnetworks hidl_memory_hwservice:hwservice_manager find;
allow hal_neuralnetworks hal_allocator:fd use;
#line 1 "system/sepolicy/public/hal_neverallows.te"
# only HALs responsible for network hardware should have privileged
# network capabilities
neverallow {
  halserverdomain
  -hal_bluetooth_server
  -hal_wifi_server
  -hal_wifi_supplicant_server
  -rild
} self:capability { net_admin net_raw };

# Unless a HAL's job is to communicate over the network, or control network
# hardware, it should not be using network sockets.
neverallow {
  halserverdomain
  -hal_tetheroffload_server
  -hal_wifi_server
  -hal_wifi_supplicant_server
  -rild
} domain:{ tcp_socket udp_socket rawip_socket } *;

###
# HALs are defined as an attribute and so a given domain could hypothetically
# have multiple HALs in it (or even all of them) with the subsequent policy of
# the domain comprised of the union of all the HALs.
#
# This is a problem because
# 1) Security sensitive components should only be accessed by specific HALs.
# 2) hwbinder_call and the restrictions it provides cannot be reasoned about in
#    the platform.
# 3) The platform cannot reason about defense in depth if there are
#    monolithic domains etc.
#
# As an example, hal_keymaster and hal_gatekeeper can access the TEE and while
# its OK for them to share a process its not OK with them to share processes
# with other hals.
#
# The following neverallow rules, in conjuntion with CTS tests, assert that
# these security principles are adhered to.
#
# Do not allow a hal to exec another process without a domain transition.
# TODO remove exemptions.
neverallow {
  halserverdomain
  -hal_dumpstate_server
  -rild
} { file_type fs_type }:file execute_no_trans;
# Do not allow a process other than init to transition into a HAL domain.
neverallow { domain -init } halserverdomain:process transition;
# Only allow transitioning to a domain by running its executable. Do not
# allow transitioning into a HAL domain by use of seclabel in an
# init.*.rc script.
neverallow * halserverdomain:process dyntransition;
#line 1 "system/sepolicy/public/hal_nfc.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_nfc_client hal_nfc_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_nfc_server hal_nfc_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_nfc_client hal_nfc_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_nfc_server hal_nfc_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_nfc_client hal_nfc_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_nfc_server hal_nfc_client:fd use;
#line 3



#line 5
  allow hal_nfc_server hal_nfc_hwservice:hwservice_manager { add find };
#line 5
  allow hal_nfc_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_nfc_server } hal_nfc_hwservice:hwservice_manager add;
#line 5

allow hal_nfc_client hal_nfc_hwservice:hwservice_manager find;

# Set NFC properties (used by bcm2079x HAL).

#line 9

#line 9
allow hal_nfc property_socket:sock_file write;
#line 9
allow hal_nfc init:unix_stream_socket connectto;
#line 9

#line 9
allow hal_nfc nfc_prop:property_service set;
#line 9

#line 9
allow hal_nfc nfc_prop:file { getattr open read ioctl lock map };
#line 9

#line 9


# NFC device access.
allow hal_nfc nfc_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Data file accesses.
allow hal_nfc nfc_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow hal_nfc nfc_data_file:{ file lnk_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 1 "system/sepolicy/public/hal_oemlock.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_oemlock_client hal_oemlock_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_oemlock_server hal_oemlock_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_oemlock_client hal_oemlock_server:fd use;
#line 2



#line 4
  allow hal_oemlock_server hal_oemlock_hwservice:hwservice_manager { add find };
#line 4
  allow hal_oemlock_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_oemlock_server } hal_oemlock_hwservice:hwservice_manager add;
#line 4

allow hal_oemlock_client hal_oemlock_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_power.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_power_client hal_power_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_power_server hal_power_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_power_client hal_power_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_power_server hal_power_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_power_client hal_power_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_power_server hal_power_client:fd use;
#line 3



#line 5
  allow hal_power_server hal_power_hwservice:hwservice_manager { add find };
#line 5
  allow hal_power_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_power_server } hal_power_hwservice:hwservice_manager add;
#line 5

allow hal_power_client hal_power_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_sensors.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_sensors_client hal_sensors_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_sensors_server hal_sensors_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_sensors_client hal_sensors_server:fd use;
#line 2



#line 4
  allow hal_sensors_server hal_sensors_hwservice:hwservice_manager { add find };
#line 4
  allow hal_sensors_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_sensors_server } hal_sensors_hwservice:hwservice_manager add;
#line 4

allow hal_sensors_client hal_sensors_hwservice:hwservice_manager find;

# Allow sensor hals to access ashmem memory allocated by apps
allow hal_sensors { appdomain -isolated_app }:fd use;

# Allow sensor hals to access ashmem memory allocated by android.hidl.allocator
# fd is passed in from framework sensorservice HAL.
allow hal_sensors hal_allocator:fd use;

# allow to run with real-time scheduling policy
allow hal_sensors self:capability sys_nice;
#line 1 "system/sepolicy/public/hal_telephony.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_telephony_client hal_telephony_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_telephony_server hal_telephony_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_telephony_client hal_telephony_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_telephony_server hal_telephony_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_telephony_client hal_telephony_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_telephony_server hal_telephony_client:fd use;
#line 3



#line 5
  allow hal_telephony_server hal_telephony_hwservice:hwservice_manager { add find };
#line 5
  allow hal_telephony_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_telephony_server } hal_telephony_hwservice:hwservice_manager add;
#line 5

allow hal_telephony_client hal_telephony_hwservice:hwservice_manager find;

#line 1 "system/sepolicy/public/hal_tetheroffload.te"
## HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_tetheroffload_client hal_tetheroffload_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_tetheroffload_server hal_tetheroffload_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_tetheroffload_client hal_tetheroffload_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_tetheroffload_server hal_tetheroffload_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_tetheroffload_client hal_tetheroffload_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_tetheroffload_server hal_tetheroffload_client:fd use;
#line 3


allow hal_tetheroffload_client hal_tetheroffload_hwservice:hwservice_manager find;

# allow the client to pass the server already open netlink sockets
allow hal_tetheroffload_server hal_tetheroffload_client:netlink_netfilter_socket { getattr read setopt write };
#line 1 "system/sepolicy/public/hal_thermal.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_thermal_client hal_thermal_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_thermal_server hal_thermal_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_thermal_client hal_thermal_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_thermal_server hal_thermal_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_thermal_client hal_thermal_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_thermal_server hal_thermal_client:fd use;
#line 3



#line 5
  allow hal_thermal_server hal_thermal_hwservice:hwservice_manager { add find };
#line 5
  allow hal_thermal_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_thermal_server } hal_thermal_hwservice:hwservice_manager add;
#line 5

allow hal_thermal_client hal_thermal_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_tv_cec.te"
# HwBinder IPC from clients into server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_tv_cec_client hal_tv_cec_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_tv_cec_server hal_tv_cec_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_tv_cec_client hal_tv_cec_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_tv_cec_server hal_tv_cec_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_tv_cec_client hal_tv_cec_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_tv_cec_server hal_tv_cec_client:fd use;
#line 3



#line 5
  allow hal_tv_cec_server hal_tv_cec_hwservice:hwservice_manager { add find };
#line 5
  allow hal_tv_cec_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_tv_cec_server } hal_tv_cec_hwservice:hwservice_manager add;
#line 5

allow hal_tv_cec_client hal_tv_cec_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_tv_input.te"
# HwBinder IPC from clients into server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_tv_input_client hal_tv_input_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_tv_input_server hal_tv_input_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_tv_input_client hal_tv_input_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_tv_input_server hal_tv_input_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_tv_input_client hal_tv_input_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_tv_input_server hal_tv_input_client:fd use;
#line 3



#line 5
  allow hal_tv_input_server hal_tv_input_hwservice:hwservice_manager { add find };
#line 5
  allow hal_tv_input_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_tv_input_server } hal_tv_input_hwservice:hwservice_manager add;
#line 5

allow hal_tv_input_client hal_tv_input_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_usb.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_usb_client hal_usb_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_usb_server hal_usb_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_usb_client hal_usb_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_usb_server hal_usb_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_usb_client hal_usb_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_usb_server hal_usb_client:fd use;
#line 3



#line 5
  allow hal_usb_server hal_usb_hwservice:hwservice_manager { add find };
#line 5
  allow hal_usb_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_usb_server } hal_usb_hwservice:hwservice_manager add;
#line 5

allow hal_usb_client hal_usb_hwservice:hwservice_manager find;

allow hal_usb self:netlink_kobject_uevent_socket create;
allow hal_usb self:netlink_kobject_uevent_socket setopt;
allow hal_usb self:netlink_kobject_uevent_socket bind;
allow hal_usb self:netlink_kobject_uevent_socket read;
allow hal_usb sysfs:dir open;
allow hal_usb sysfs:dir read;
allow hal_usb sysfs:file read;
allow hal_usb sysfs:file open;
allow hal_usb sysfs:file write;
allow hal_usb sysfs:file getattr;

#line 1 "system/sepolicy/public/hal_vibrator.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_vibrator_client hal_vibrator_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_vibrator_server hal_vibrator_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_vibrator_client hal_vibrator_server:fd use;
#line 2



#line 4
  allow hal_vibrator_server hal_vibrator_hwservice:hwservice_manager { add find };
#line 4
  allow hal_vibrator_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_vibrator_server } hal_vibrator_hwservice:hwservice_manager add;
#line 4

allow hal_vibrator_client hal_vibrator_hwservice:hwservice_manager find;

# vibrator sysfs rw access
allow hal_vibrator sysfs_vibrator:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 1 "system/sepolicy/public/hal_vr.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_vr_client hal_vr_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_vr_server hal_vr_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_vr_client hal_vr_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_vr_server hal_vr_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_vr_client hal_vr_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_vr_server hal_vr_client:fd use;
#line 3



#line 5
  allow hal_vr_server hal_vr_hwservice:hwservice_manager { add find };
#line 5
  allow hal_vr_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_vr_server } hal_vr_hwservice:hwservice_manager add;
#line 5

allow hal_vr_client hal_vr_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_weaver.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_weaver_client hal_weaver_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_weaver_server hal_weaver_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_weaver_client hal_weaver_server:fd use;
#line 2



#line 4
  allow hal_weaver_server hal_weaver_hwservice:hwservice_manager { add find };
#line 4
  allow hal_weaver_server hidl_base_hwservice:hwservice_manager add;
#line 4
  neverallow { domain -hal_weaver_server } hal_weaver_hwservice:hwservice_manager add;
#line 4

allow hal_weaver_client hal_weaver_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/public/hal_wifi.te"
# HwBinder IPC from client to server, and callbacks

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_wifi_client hal_wifi_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_wifi_server hal_wifi_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_wifi_client hal_wifi_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_wifi_server hal_wifi_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_wifi_client hal_wifi_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_wifi_server hal_wifi_client:fd use;
#line 3



#line 5
  allow hal_wifi_server hal_wifi_hwservice:hwservice_manager { add find };
#line 5
  allow hal_wifi_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_wifi_server } hal_wifi_hwservice:hwservice_manager add;
#line 5

allow hal_wifi_client hal_wifi_hwservice:hwservice_manager find;


#line 8
allow hal_wifi proc_net:dir { open getattr read search ioctl lock };
#line 8
allow hal_wifi proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 8


#line 9
allow hal_wifi sysfs_type:dir { open getattr read search ioctl lock };
#line 9
allow hal_wifi sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 9



#line 11

#line 11
allow hal_wifi property_socket:sock_file write;
#line 11
allow hal_wifi init:unix_stream_socket connectto;
#line 11

#line 11
allow hal_wifi wifi_prop:property_service set;
#line 11

#line 11
allow hal_wifi wifi_prop:file { getattr open read ioctl lock map };
#line 11

#line 11


# allow hal wifi set interfaces up and down
allow hal_wifi self:udp_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allowxperm hal_wifi self:udp_socket ioctl { 0x00008914 };

allow hal_wifi self:capability { net_admin net_raw };
# allow hal_wifi to speak to nl80211 in the kernel
allow hal_wifi self:netlink_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
# newer kernels (e.g. 4.4 but not 4.1) have a new class for sockets
allow hal_wifi self:netlink_generic_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
# hal_wifi writes firmware paths to this file.
allow hal_wifi sysfs_wlan_fwpath:file { { open append write lock map } };
# allow hal_wifi to access /proc/modules to check if Wi-Fi driver is loaded
allow hal_wifi proc_modules:file { getattr open read };## HwBinder IPC from client to server, and callbacks
#line 2 "system/sepolicy/public/hal_wifi_offload.te"

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_wifi_offload_client hal_wifi_offload_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_wifi_offload_server hal_wifi_offload_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_wifi_offload_client hal_wifi_offload_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_wifi_offload_server hal_wifi_offload_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_wifi_offload_client hal_wifi_offload_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_wifi_offload_server hal_wifi_offload_client:fd use;
#line 3



#line 5
  allow hal_wifi_offload_server hal_wifi_offload_hwservice:hwservice_manager { add find };
#line 5
  allow hal_wifi_offload_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_wifi_offload_server } hal_wifi_offload_hwservice:hwservice_manager add;
#line 5

allow hal_wifi_offload_client hal_wifi_offload_hwservice:hwservice_manager find;


#line 8
allow hal_wifi_offload proc_net:dir { open getattr read search ioctl lock };
#line 8
allow hal_wifi_offload proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 8


#line 9
allow hal_wifi_offload sysfs_type:dir { open getattr read search ioctl lock };
#line 9
allow hal_wifi_offload sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 9

#line 1 "system/sepolicy/public/hal_wifi_supplicant.te"
# HwBinder IPC from client to server

#line 2
# Call the server domain and optionally transfer references to it.
#line 2
allow hal_wifi_supplicant_client hal_wifi_supplicant_server:binder { call transfer };
#line 2
# Allow the serverdomain to transfer references to the client on the reply.
#line 2
allow hal_wifi_supplicant_server hal_wifi_supplicant_client:binder transfer;
#line 2
# Receive and use open files from the server.
#line 2
allow hal_wifi_supplicant_client hal_wifi_supplicant_server:fd use;
#line 2


#line 3
# Call the server domain and optionally transfer references to it.
#line 3
allow hal_wifi_supplicant_server hal_wifi_supplicant_client:binder { call transfer };
#line 3
# Allow the serverdomain to transfer references to the client on the reply.
#line 3
allow hal_wifi_supplicant_client hal_wifi_supplicant_server:binder transfer;
#line 3
# Receive and use open files from the server.
#line 3
allow hal_wifi_supplicant_server hal_wifi_supplicant_client:fd use;
#line 3



#line 5
  allow hal_wifi_supplicant_server hal_wifi_supplicant_hwservice:hwservice_manager { add find };
#line 5
  allow hal_wifi_supplicant_server hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hal_wifi_supplicant_server } hal_wifi_supplicant_hwservice:hwservice_manager add;
#line 5

allow hal_wifi_supplicant_client hal_wifi_supplicant_hwservice:hwservice_manager find;

# in addition to ioctls whitelisted for all domains, grant hal_wifi_supplicant priv_sock_ioctls.
allowxperm hal_wifi_supplicant self:udp_socket ioctl 
#line 9
{
#line 9
# qualcomm rmnet ioctls
#line 9
0x00006900 0x00006902
#line 9
# socket ioctls
#line 9
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 9
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 9
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 9
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 9
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 9
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 9
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 9
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 9
0x00008991 0x00008992 0x00008993 0x00008994
#line 9
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 9
# device and protocol specific ioctls
#line 9
0x000089f0-0x000089ff
#line 9
0x000089e0-0x000089ef
#line 9
# Wireless extension ioctls
#line 9
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 9
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 9
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 9
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 9
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 9
0x00008b34 0x00008b35 0x00008b36
#line 9
# Dev private ioctl i.e. hardware specific ioctls
#line 9
0x00008be0-0x00008bff
#line 9
};


#line 11
allow hal_wifi_supplicant sysfs_type:dir { open getattr read search ioctl lock };
#line 11
allow hal_wifi_supplicant sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 11


#line 12
allow hal_wifi_supplicant proc_net:dir { open getattr read search ioctl lock };
#line 12
allow hal_wifi_supplicant proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 12


allow hal_wifi_supplicant kernel:system module_request;
allow hal_wifi_supplicant self:capability { setuid net_admin setgid net_raw };
allow hal_wifi_supplicant cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow hal_wifi_supplicant self:netlink_route_socket nlmsg_write;
allow hal_wifi_supplicant self:netlink_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow hal_wifi_supplicant self:netlink_generic_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow hal_wifi_supplicant self:packet_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allowxperm hal_wifi_supplicant self:packet_socket ioctl { 
#line 21
{
#line 21
# Socket ioctls for gathering information about the interface
#line 21
0x00008906 0x00008907
#line 21
0x00008910 0x00008912 0x00008913 0x00008915 0x00008917 0x00008919
#line 21
0x0000891b 0x00008921 0x00008933 0x00008938 0x00008942
#line 21
# Wireless extension ioctls. Primarily get functions.
#line 21
0x00008b01 0x00008b05 0x00008b07 0x00008b09 0x00008b0b 0x00008b0d
#line 21
0x00008b0f 0x00008b11 0x00008b12 0x00008b13 0x00008b21 0x00008b23
#line 21
0x00008b25 0x00008b27 0x00008b29 0x00008b2d
#line 21
} 
#line 21
{
#line 21
# qualcomm rmnet ioctls
#line 21
0x00006900 0x00006902
#line 21
# socket ioctls
#line 21
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 21
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 21
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 21
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 21
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 21
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 21
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 21
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 21
0x00008991 0x00008992 0x00008993 0x00008994
#line 21
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 21
# device and protocol specific ioctls
#line 21
0x000089f0-0x000089ff
#line 21
0x000089e0-0x000089ef
#line 21
# Wireless extension ioctls
#line 21
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 21
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 21
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 21
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 21
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 21
0x00008b34 0x00008b35 0x00008b36
#line 21
# Dev private ioctl i.e. hardware specific ioctls
#line 21
0x00008be0-0x00008bff
#line 21
} {
#line 21
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 21
  0x0000540b 0x00005410 0x0000540f
#line 21
} };
allow hal_wifi_supplicant wifi_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow hal_wifi_supplicant wifi_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Create a socket for receiving info from wpa
allow hal_wifi_supplicant wpa_socket:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow hal_wifi_supplicant wpa_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Allow wpa_cli to work. wpa_cli creates a socket in
# /data/misc/wifi/sockets which hal_wifi_supplicant supplicant communicates with.

#line 31
  
#line 31
allow hal_wifi_supplicant wpa_socket:sock_file write;
#line 31
allow hal_wifi_supplicant su:unix_dgram_socket sendto;
#line 31

#line 33


###
### neverallow rules
###

# wpa_supplicant should not trust any data from sdcards
neverallow hal_wifi_supplicant_server sdcard_type:dir ~getattr;
neverallow hal_wifi_supplicant_server sdcard_type:file *;
#line 1 "system/sepolicy/public/healthd.te"
# healthd - battery/charger monitoring service daemon
type healthd, domain;
type healthd_exec, exec_type, file_type;

# Write to /dev/kmsg
allow healthd kmsg_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Read access to pseudo filesystems.

#line 9
allow healthd sysfs_type:dir { open getattr read search ioctl lock };
#line 9
allow healthd sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 9


#line 10
allow healthd rootfs:dir { open getattr read search ioctl lock };
#line 10
allow healthd rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 10


#line 11
allow healthd cgroup:dir { open getattr read search ioctl lock };
#line 11
allow healthd cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 11


# Read access to system files for passthrough HALs in
# /{system,vendor,odm}/lib[64]/hw/

#line 15
allow healthd system_file:dir { open getattr read search ioctl lock };
#line 15
allow healthd system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 15


allow healthd self:capability { sys_tty_config };
allow healthd self:capability sys_boot;

allow healthd self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };


#line 22
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 22
allow healthd sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 22
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 22
allow healthd self:capability2 block_suspend;
#line 22



#line 24
# Call the servicemanager and transfer references to it.
#line 24
allow healthd servicemanager:binder { call transfer };
#line 24
# servicemanager performs getpidcon on clients.
#line 24
allow servicemanager healthd:dir search;
#line 24
allow servicemanager healthd:file { read open };
#line 24
allow servicemanager healthd:process getattr;
#line 24
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 24
# all domains in domain.te.
#line 24


#line 25
typeattribute healthd binderservicedomain;
#line 25


#line 26
# Call the server domain and optionally transfer references to it.
#line 26
allow healthd system_server:binder { call transfer };
#line 26
# Allow the serverdomain to transfer references to the client on the reply.
#line 26
allow system_server healthd:binder transfer;
#line 26
# Receive and use open files from the server.
#line 26
allow healthd system_server:fd use;
#line 26


#line 27
typeattribute healthd halclientdomain;
#line 27
typeattribute healthd hal_health_client;
#line 27

#line 27
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 27
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 27
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 27

#line 27
typeattribute healthd hal_health;
#line 27
# Find passthrough HAL implementations
#line 27
allow hal_health system_file:dir { open getattr read search ioctl lock };
#line 27
allow hal_health vendor_file:dir { open getattr read search ioctl lock };
#line 27
allow hal_health vendor_file:file { read open getattr execute map };
#line 27

#line 27


# Write to state file.
# TODO:  Split into a separate type?
allow healthd sysfs:file write;

# TODO: added to match above sysfs rule. Remove me?
allow healthd sysfs_usb:file write;

allow healthd sysfs_batteryinfo:file { getattr open read ioctl lock map };


#line 38
allow healthd sysfs_type:dir { open getattr read search ioctl lock };
#line 38
allow healthd sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 38


###
### healthd: charger mode
###

# Read /sys/fs/pstore/console-ramoops
# Don't worry about overly broad permissions for now, as there's
# only one file in /sys/fs/pstore
allow healthd pstorefs:dir { open getattr read search ioctl lock };
allow healthd pstorefs:file { getattr open read ioctl lock map };

allow healthd graphics_device:dir { open getattr read search ioctl lock };
allow healthd graphics_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow healthd input_device:dir { open getattr read search ioctl lock };
allow healthd input_device:chr_file { getattr open read ioctl lock map };
allow healthd tty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow healthd ashmem_device:chr_file execute;
allow healthd self:process execmem;
allow healthd proc_sysrq:file { { getattr open read ioctl lock map } { open append write lock map } };


#line 59
  allow healthd batteryproperties_service:service_manager { add find };
#line 59
  neverallow { domain -healthd } batteryproperties_service:service_manager add;
#line 59


# Healthd needs to tell init to continue the boot
# process when running in charger mode.

#line 63

#line 63
allow healthd property_socket:sock_file write;
#line 63
allow healthd init:unix_stream_socket connectto;
#line 63

#line 63
allow healthd system_prop:property_service set;
#line 63

#line 63
allow healthd system_prop:file { getattr open read ioctl lock map };
#line 63

#line 63

#line 1 "system/sepolicy/public/hwservice.te"
type default_android_hwservice, hwservice_manager_type;
type fwk_display_hwservice, hwservice_manager_type, coredomain_hwservice;
type fwk_scheduler_hwservice, hwservice_manager_type, coredomain_hwservice;
type fwk_sensor_hwservice, hwservice_manager_type, coredomain_hwservice;
type hal_audio_hwservice, hwservice_manager_type;
type hal_bluetooth_hwservice, hwservice_manager_type;
type hal_bootctl_hwservice, hwservice_manager_type;
type hal_broadcastradio_hwservice, hwservice_manager_type;
type hal_camera_hwservice, hwservice_manager_type;
type hal_configstore_ISurfaceFlingerConfigs, hwservice_manager_type;
type hal_contexthub_hwservice, hwservice_manager_type;
type hal_drm_hwservice, hwservice_manager_type;
type hal_cas_hwservice, hwservice_manager_type;
type hal_dumpstate_hwservice, hwservice_manager_type;
type hal_fingerprint_hwservice, hwservice_manager_type;
type hal_gatekeeper_hwservice, hwservice_manager_type;
type hal_gnss_hwservice, hwservice_manager_type;
type hal_graphics_allocator_hwservice, hwservice_manager_type;
type hal_graphics_composer_hwservice, hwservice_manager_type;
type hal_graphics_mapper_hwservice, hwservice_manager_type, same_process_hwservice;
type hal_health_hwservice, hwservice_manager_type;
type hal_ir_hwservice, hwservice_manager_type;
type hal_keymaster_hwservice, hwservice_manager_type;
type hal_light_hwservice, hwservice_manager_type;
type hal_memtrack_hwservice, hwservice_manager_type;
type hal_neuralnetworks_hwservice, hwservice_manager_type;
type hal_nfc_hwservice, hwservice_manager_type;
type hal_oemlock_hwservice, hwservice_manager_type;
type hal_omx_hwservice, hwservice_manager_type;
type hal_power_hwservice, hwservice_manager_type;
type hal_renderscript_hwservice, hwservice_manager_type, same_process_hwservice;
type hal_sensors_hwservice, hwservice_manager_type;
type hal_telephony_hwservice, hwservice_manager_type;
type hal_tetheroffload_hwservice, hwservice_manager_type;
type hal_thermal_hwservice, hwservice_manager_type;
type hal_tv_cec_hwservice, hwservice_manager_type;
type hal_tv_input_hwservice, hwservice_manager_type;
type hal_usb_hwservice, hwservice_manager_type;
type hal_vibrator_hwservice, hwservice_manager_type;
type hal_vr_hwservice, hwservice_manager_type;
type hal_weaver_hwservice, hwservice_manager_type;
type hal_wifi_hwservice, hwservice_manager_type;
type hal_wifi_offload_hwservice, hwservice_manager_type;
type hal_wifi_supplicant_hwservice, hwservice_manager_type;
type hidl_allocator_hwservice, hwservice_manager_type, coredomain_hwservice;
type hidl_base_hwservice, hwservice_manager_type;
type hidl_manager_hwservice, hwservice_manager_type, coredomain_hwservice;
type hidl_memory_hwservice, hwservice_manager_type, coredomain_hwservice;
type hidl_token_hwservice, hwservice_manager_type, coredomain_hwservice;
type system_net_netd_hwservice, hwservice_manager_type, coredomain_hwservice;
type system_wifi_keystore_hwservice, hwservice_manager_type, coredomain_hwservice;
type thermalcallback_hwservice, hwservice_manager_type;
#line 1 "system/sepolicy/public/hwservicemanager.te"
# hwservicemanager - the Binder context manager for HAL services
type hwservicemanager, domain, mlstrustedsubject;
type hwservicemanager_exec, exec_type, file_type;

# Note that we do not use the binder_* macros here.
# hwservicemanager provides name service (aka context manager)
# for hwbinder.
# Additionally, it initiates binder IPC calls to
# clients who request service notifications. The permission
# to do this is granted in the hwbinder_use macro.
allow hwservicemanager self:binder set_context_mgr;


#line 13

#line 13
allow hwservicemanager property_socket:sock_file write;
#line 13
allow hwservicemanager init:unix_stream_socket connectto;
#line 13

#line 13
allow hwservicemanager hwservicemanager_prop:property_service set;
#line 13

#line 13
allow hwservicemanager hwservicemanager_prop:file { getattr open read ioctl lock map };
#line 13

#line 13


# Scan through /system/lib64/hw looking for installed HALs
allow hwservicemanager system_file:dir { open getattr read search ioctl lock };

# Read hwservice_contexts
allow hwservicemanager hwservice_contexts_file:file { getattr open read ioctl lock map };

# Check SELinux permissions.

#line 22

#line 22
allow hwservicemanager selinuxfs:dir { open getattr read search ioctl lock };
#line 22
allow hwservicemanager selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 22

#line 22
allow hwservicemanager selinuxfs:file { open append write lock map };
#line 22
allow hwservicemanager kernel:security compute_av;
#line 22
allow hwservicemanager self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 22

#line 1 "system/sepolicy/public/idmap.te"
# idmap, when executed by installd
type idmap, domain;
type idmap_exec, exec_type, file_type;

# Use open file to /data/resource-cache file inherited from installd.
allow idmap installd:fd use;
allow idmap resourcecache_data_file:file { getattr read write };

# Open and read from target and overlay apk files passed by argument.
allow idmap apk_data_file:file { getattr open read ioctl lock map };
allow idmap apk_data_file:dir search;

# Allow apps access to /vendor/app

#line 14
allow idmap vendor_app_file:dir { open getattr read search ioctl lock };
#line 14
allow idmap vendor_app_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 14


# Allow apps access to /vendor/overlay

#line 17
allow idmap vendor_overlay_file:dir { open getattr read search ioctl lock };
#line 17
allow idmap vendor_overlay_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 17

#line 1 "system/sepolicy/public/incident.te"
# The incident command is used to call into the incidentd service to
# take an incident report (binary, shared bugreport), download incident
# reports that have already been taken, and monitor for new ones.
# It doesn't do anything else.

# incident
type incident, domain;

#line 1 "system/sepolicy/public/incidentd.te"
# incidentd
type incidentd, domain;

#line 1 "system/sepolicy/public/init.te"
# init is its own domain.
type init, domain, mlstrustedsubject;

# The init domain is entered by execing init.
type init_exec, exec_type, file_type;

# /dev/__null__ node created by init.
allow init tmpfs:chr_file { create setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

#
# init direct restorecon calls.
#
# /dev/kmsg
allow init tmpfs:chr_file relabelfrom;
allow init kmsg_device:chr_file { write relabelto };
# /dev/kmsg_debug

#line 17
  allow init kmsg_debug_device:chr_file { write relabelto };
#line 19

# /dev/__properties__
allow init properties_device:dir relabelto;
allow init properties_serial:file { write relabelto };
allow init property_type:file { { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } relabelto };
# /dev/event-log-tags
allow init device:file relabelfrom;
allow init runtime_event_log_tags_file:file { open write setattr relabelto };
# /dev/socket
allow init { device socket_device }:dir relabelto;
# /dev/random, /dev/urandom
allow init random_device:chr_file relabelto;
# /dev/device-mapper, /dev/block(/.*)?
allow init tmpfs:{ chr_file blk_file } relabelfrom;
allow init tmpfs:blk_file getattr;
allow init block_device:{ dir blk_file lnk_file } relabelto;
allow init dm_device:{ chr_file blk_file } relabelto;
allow init kernel:fd use;
# restorecon for early mount device symlinks
allow init tmpfs:lnk_file { getattr read relabelfrom };
allow init system_block_device:{ blk_file lnk_file } relabelto;

# setrlimit
allow init self:capability sys_resource;

# Remove /dev/.booting, created before initial policy load or restorecon /dev.
allow init tmpfs:file unlink;

# Access pty created for fsck.
allow init devpts:chr_file { read write open };

# Create /dev/fscklogs files.
allow init fscklogs:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access /dev/__null__ node created prior to initial policy load.
allow init tmpfs:chr_file write;

# Access /dev/console.
allow init console_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Access /dev/tty0.
allow init tty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Call mount(2).
allow init self:capability sys_admin;

# Create and mount on directories in /.
allow init rootfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow init { rootfs cache_file cgroup storage_file system_data_file system_file vendor_file postinstall_mnt_dir }:dir mounton;

# Mount on /dev/usb-ffs/adb.
allow init device:dir mounton;

# Create and remove symlinks in /.
allow init rootfs:lnk_file { create unlink };

# Mount debugfs on /sys/kernel/debug.
allow init sysfs:dir mounton;

# Create cgroups mount points in tmpfs and mount cgroups on them.
allow init tmpfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow init tmpfs:dir mounton;
allow init cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };

#line 82
allow init cgroup:dir { open getattr read search ioctl lock };
#line 82
allow init cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 82

allow init cpuctl_device:dir { create mounton };

# /config
allow init configfs:dir mounton;
allow init configfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow init configfs:{ file lnk_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Use tmpfs as /data, used for booting when /data is encrypted
allow init tmpfs:dir relabelfrom;

# Create directories under /dev/cpuctl after chowning it to system.
allow init self:capability dac_override;

# Set system clock.
allow init self:capability sys_time;

allow init self:capability { sys_rawio mknod };

# Mounting filesystems from block devices.
allow init dev_type:blk_file { getattr open read ioctl lock map };

# Mounting filesystems.
# Only allow relabelto for types used in context= mount options,
# which should all be assigned the contextmount_type attribute.
# This can be done in device-specific policy via type or typeattribute
# declarations.
allow init fs_type:filesystem ~relabelto;
allow init unlabeled:filesystem ~relabelto;
allow init contextmount_type:filesystem relabelto;

# Allow read-only access to context= mounted filesystems.
allow init contextmount_type:dir { open getattr read search ioctl lock };
allow init contextmount_type:{ file lnk_file sock_file fifo_file } { getattr open read ioctl lock map };

# restorecon /adb_keys or any other rootfs files and directories to a more
# specific type.
allow init rootfs:{ dir file } relabelfrom;

# mkdir, symlink, write, rm/rmdir, chown/chmod, restorecon/restorecon_recursive from init.rc files.
# chown/chmod require open+read+setattr required for open()+fchown/fchmod().
# system/core/init.rc requires at least cache_file and data_file_type.
# init.<board>.rc files often include device-specific types, so
# we just allow all file types except /system files here.
allow init self:capability { chown fowner fsetid };

allow init {
  file_type
  -app_data_file
  -exec_type
  -misc_logd_file
  -system_app_data_file
  -system_file
  -vendor_file_type
}:dir { create search getattr open read setattr ioctl };

allow init {
  file_type
  -app_data_file
  -exec_type
  -keystore_data_file
  -misc_logd_file
  -shell_data_file
  -system_app_data_file
  -system_file
  -vendor_file_type
  -vold_data_file
}:dir { write add_name remove_name rmdir relabelfrom };

allow init {
  file_type
  -app_data_file
  -runtime_event_log_tags_file
  -exec_type
  -keystore_data_file
  -misc_logd_file
  -shell_data_file
  -system_app_data_file
  -system_file
  -vendor_file_type
  -vold_data_file
}:file { create getattr open read write setattr relabelfrom unlink };

allow init {
  file_type
  -app_data_file
  -exec_type
  -keystore_data_file
  -misc_logd_file
  -shell_data_file
  -system_app_data_file
  -system_file
  -vendor_file_type
  -vold_data_file
}:{ sock_file fifo_file } { create getattr open read setattr relabelfrom unlink };

allow init {
  file_type
  -app_data_file
  -exec_type
  -keystore_data_file
  -misc_logd_file
  -shell_data_file
  -system_app_data_file
  -system_file
  -vendor_file_type
  -vold_data_file
}:lnk_file { create getattr setattr relabelfrom unlink };

allow init cache_file:lnk_file { getattr open read ioctl lock map };

allow init { file_type -system_file -vendor_file_type -exec_type }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } relabelto;
allow init { sysfs debugfs debugfs_tracing }:{ dir file lnk_file } { getattr relabelfrom };
allow init { sysfs_type debugfs_type }:{ dir file lnk_file } { relabelto getattr };
allow init dev_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow init dev_type:lnk_file create;

# Disable tracing by writing to /sys/kernel/debug/tracing/tracing_on
allow init debugfs_tracing:file { open append write lock map };

# Setup and control wifi event tracing (see wifi-events.rc)
allow init debugfs_tracing_instances:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow init debugfs_tracing_instances:file { open append write lock map };
allow init debugfs_wifi_tracing:file { open append write lock map };

# chown/chmod on pseudo files.
allow init { fs_type -contextmount_type -sdcard_type -rootfs }:file { open read setattr };
allow init { fs_type -contextmount_type -sdcard_type -rootfs }:dir  { open read setattr search };

# init should not be able to read or open generic devices
# TODO: auditing to see if this can be deleted entirely
allow init {
  dev_type
  -kmem_device
  -port_device
  -device
  -vndbinder_device
  }:chr_file { read open };
auditallow init {
  dev_type
  -alarm_device
  -ashmem_device
  -binder_device
  -console_device
  -device
  -devpts
  -dm_device
  -hwbinder_device
  -hw_random_device
  -keychord_device
  -kmem_device
  -kmsg_device
  -null_device
  -owntty_device
  -port_device
  -ptmx_device
  -random_device
  -zero_device
}:chr_file { read open };

# chown/chmod on devices.
allow init { dev_type -kmem_device -port_device }:chr_file setattr;

# Unlabeled file access for upgrades from 4.2.
allow init unlabeled:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } relabelfrom };
allow init unlabeled:{ file lnk_file sock_file fifo_file } { { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } relabelfrom };

# Any operation that can modify the kernel ring buffer, e.g. clear
# or a read that consumes the messages that were read.
allow init kernel:system syslog_mod;
allow init self:capability2 syslog;

# Set usermodehelpers and /proc security settings.
allow init { usermodehelper sysfs_usermodehelper }:file { { getattr open read ioctl lock map } { open append write lock map } };
allow init proc_security:file { { getattr open read ioctl lock map } { open append write lock map } };

# Write to /proc/sys/kernel/panic_on_oops.

#line 259
allow init proc:dir { open getattr read search ioctl lock };
#line 259
allow init proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 259

allow init proc:file { open append write lock map };

# Write to /proc/sys/net/ping_group_range and other /proc/sys/net files.

#line 263
allow init proc_net:dir { open getattr read search ioctl lock };
#line 263
allow init proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 263

allow init proc_net:file { open append write lock map };
allow init self:capability net_admin;

# Write to /proc/sysrq-trigger.
allow init proc_sysrq:file { open append write lock map };

# Read /proc/stat for bootchart.
allow init proc_stat:file { getattr open read ioctl lock map };

# Reboot.
allow init self:capability sys_boot;

# Write to sysfs nodes.
allow init sysfs_type:dir { open getattr read search ioctl lock };
allow init sysfs_type:lnk_file read;
allow init sysfs_type:file { { getattr open read ioctl lock map } { open append write lock map } };

# Init will create /data/misc/logd when the property persist.logd.logpersistd is "logcatd".
# Init will also walk through the directory as part of a recursive restorecon.
allow init misc_logd_file:dir { add_name open create read getattr setattr search write };
allow init misc_logd_file:file { open create getattr setattr write };

# Support "adb shell stop"
allow init self:capability kill;
allow init domain:process { getpgid sigkill signal };

# Init creates keystore's directory on boot, and walks through
# the directory as part of a recursive restorecon.
allow init keystore_data_file:dir { open create read getattr setattr search };
allow init keystore_data_file:file { getattr };

# Init creates vold's directory on boot, and walks through
# the directory as part of a recursive restorecon.
allow init vold_data_file:dir { open create read getattr setattr search };
allow init vold_data_file:file { getattr };

# Init creates /data/local/tmp at boot
allow init shell_data_file:dir { open create read getattr setattr search };
allow init shell_data_file:file { getattr };

# Set UID, GID, and adjust capability bounding set for services.
allow init self:capability { setuid setgid setpcap };

# For bootchart to read the /proc/$pid/cmdline file of each process,
# we need to have following line to allow init to have access
# to different domains.

#line 310
allow init domain:dir { open getattr read search ioctl lock };
#line 310
allow init domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 310


# Use setexeccon(), setfscreatecon(), and setsockcreatecon().
# setexec is for services with seclabel options.
# setfscreate is for labeling directories and socket files.
# setsockcreate is for labeling local/unix domain sockets.
allow init self:process { setexec setfscreate setsockcreate };

# Get file context
allow init file_contexts_file:file { getattr open read ioctl lock map };

# sepolicy access
allow init sepolicy_file:file { getattr open read ioctl lock map };

# Perform SELinux access checks on setting properties.

#line 325

#line 325
allow init selinuxfs:dir { open getattr read search ioctl lock };
#line 325
allow init selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 325

#line 325
allow init selinuxfs:file { open append write lock map };
#line 325
allow init kernel:security compute_av;
#line 325
allow init self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 325


# Ask the kernel for the new context on services to label their sockets.
allow init kernel:security compute_create;

# Create sockets for the services.
allow init domain:unix_stream_socket { create bind setopt };
allow init domain:unix_dgram_socket { create bind setopt };

# Create /data/property and files within it.
allow init property_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow init property_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Set any property.
allow init property_type:property_service set;

# Send an SELinux userspace denial to the kernel audit subsystem,
# so it can be picked up and processed by logd. These denials are
# generated when an attempt to set a property is denied by policy.
allow init self:netlink_audit_socket { { create { read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_relay };
allow init self:capability audit_write;

# Run "ifup lo" to bring up the localhost interface
allow init self:udp_socket { create ioctl };
# in addition to unpriv ioctls granted to all domains, init also needs:
allowxperm init self:udp_socket ioctl 0x00008914;
allow init self:capability net_raw;

# This line seems suspect, as it should not really need to
# set scheduling parameters for a kernel domain task.
allow init kernel:process setsched;

# swapon() needs write access to swap device
# system/core/fs_mgr/fs_mgr.c - fs_mgr_swapon_all
allow init swap_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Read from /dev/hw_random if present.
# system/core/init/init.c - mix_hwrng_into_linux_rng_action
allow init hw_random_device:chr_file { getattr open read ioctl lock map };

# Create and access /dev files without a specific type,
# e.g. /dev/.coldboot_done, /dev/.booting
# TODO:  Move these files into their own type unless they are
# only ever accessed by init.
allow init device:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# keychord configuration
allow init self:capability sys_tty_config;
allow init keychord_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Access device mapper for setting up dm-verity
allow init dm_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow init dm_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Access metadata block device for storing dm-verity state
allow init metadata_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Read /sys/fs/pstore/console-ramoops to detect restarts caused
# by dm-verity detecting corrupted blocks
allow init pstorefs:dir search;
allow init pstorefs:file { getattr open read ioctl lock map };
allow init kernel:system syslog_read;

# linux keyring configuration
allow init init:key { write search setattr };

# Allow init to create /data/unencrypted
allow init unencrypted_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };

# Allow init to write to /proc/sys/vm/overcommit_memory
allow init proc_overcommit_memory:file { write };


#line 397

#line 397

#line 397
allow init vold_socket:sock_file write;
#line 397
allow init vold:unix_stream_socket connectto;
#line 397

#line 397


# Raw writes to misc block device
allow init misc_block_device:blk_file { open append write lock map };


#line 402
allow init system_file:dir { open getattr read search ioctl lock };
#line 402
allow init system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 402


#line 403
allow init vendor_file_type:dir { open getattr read search ioctl lock };
#line 403
allow init vendor_file_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 403

allow init proc_meminfo:file { getattr open read ioctl lock map };

allow init system_data_file:file { getattr read };
allow init system_data_file:lnk_file { getattr open read ioctl lock map };

# For init to be able to run shell scripts from vendor
allow init vendor_shell_exec:file execute;

###
### neverallow rules
###

# The init domain is only entered via an exec based transition from the
# kernel domain, never via setcon().
neverallow domain init:process dyntransition;
neverallow { domain -kernel } init:process transition;
neverallow init { file_type fs_type -init_exec }:file entrypoint;

# Never read/follow symlinks created by shell or untrusted apps.
neverallow init shell_data_file:lnk_file read;
neverallow init app_data_file:lnk_file read;

# init should never execute a program without changing to another domain.
neverallow init { file_type fs_type }:file execute_no_trans;

# Init never adds or uses services via service_manager.
neverallow init service_manager_type:service_manager { add find };
neverallow init servicemanager:service_manager list;

# Init should not be creating subdirectories in /data/local/tmp
neverallow init shell_data_file:dir { write add_name remove_name };
#line 1 "system/sepolicy/public/inputflinger.te"
# inputflinger
type inputflinger, domain;
type inputflinger_exec, exec_type, file_type;


#line 5
# Call the servicemanager and transfer references to it.
#line 5
allow inputflinger servicemanager:binder { call transfer };
#line 5
# servicemanager performs getpidcon on clients.
#line 5
allow servicemanager inputflinger:dir search;
#line 5
allow servicemanager inputflinger:file { read open };
#line 5
allow servicemanager inputflinger:process getattr;
#line 5
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 5
# all domains in domain.te.
#line 5


#line 6
typeattribute inputflinger binderservicedomain;
#line 6



#line 8
# Call the server domain and optionally transfer references to it.
#line 8
allow inputflinger system_server:binder { call transfer };
#line 8
# Allow the serverdomain to transfer references to the client on the reply.
#line 8
allow system_server inputflinger:binder transfer;
#line 8
# Receive and use open files from the server.
#line 8
allow inputflinger system_server:fd use;
#line 8



#line 10
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 10
allow inputflinger sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 10
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 10
allow inputflinger self:capability2 block_suspend;
#line 10



#line 12
  allow inputflinger inputflinger_service:service_manager { add find };
#line 12
  neverallow { domain -inputflinger } inputflinger_service:service_manager add;
#line 12

allow inputflinger input_device:dir { open getattr read search ioctl lock };
allow inputflinger input_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };


#line 16
allow inputflinger cgroup:dir { open getattr read search ioctl lock };
#line 16
allow inputflinger cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 16

#line 1 "system/sepolicy/public/install_recovery.te"
# service flash_recovery in init.rc
type install_recovery, domain;
type install_recovery_exec, exec_type, file_type;

allow install_recovery self:capability dac_override;

# /system/bin/install-recovery.sh is a shell script.
# Needs to execute /system/bin/sh
allow install_recovery shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Execute /system/bin/applypatch
allow install_recovery system_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow install_recovery vendor_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

allow install_recovery toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Update the recovery block device based off a diff of the boot block device
allow install_recovery block_device:dir search;
allow install_recovery boot_block_device:blk_file { getattr open read ioctl lock map };
allow install_recovery recovery_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Create and delete /cache/saved.file
allow install_recovery cache_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow install_recovery cache_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Write to /proc/sys/vm/drop_caches
allow install_recovery proc_drop_caches:file { open append write lock map };
#line 1 "system/sepolicy/public/installd.te"
# installer daemon
type installd, domain;
type installd_exec, exec_type, file_type;
typeattribute installd mlstrustedsubject;
allow installd self:capability { chown dac_override fowner fsetid setgid setuid sys_admin };

# Allow labeling of files under /data/app/com.example/oat/
allow installd dalvikcache_data_file:dir relabelto;
allow installd dalvikcache_data_file:file { relabelto link };

# Allow movement of APK files between volumes
allow installd apk_data_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } relabelfrom };
allow installd apk_data_file:file { { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } relabelfrom link };
allow installd apk_data_file:lnk_file { create { getattr open read ioctl lock map } unlink };

allow installd asec_apk_file:file { getattr open read ioctl lock map };
allow installd apk_tmp_file:file { { getattr open read ioctl lock map } unlink };
allow installd apk_tmp_file:dir { relabelfrom { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } };
allow installd oemfs:dir { open getattr read search ioctl lock };
allow installd oemfs:file { getattr open read ioctl lock map };
allow installd cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow installd cgroup:{ file lnk_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow installd mnt_expand_file:dir { search getattr };
# Check validity of SELinux context before use.

#line 25

#line 25
allow installd selinuxfs:dir { open getattr read search ioctl lock };
#line 25
allow installd selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 25

#line 25
allow installd selinuxfs:file { open append write lock map };
#line 25
allow installd kernel:security check_context;
#line 25



#line 27
allow installd rootfs:dir { open getattr read search ioctl lock };
#line 27
allow installd rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 27

# Scan through APKs in /system/app and /system/priv-app

#line 29
allow installd system_file:dir { open getattr read search ioctl lock };
#line 29
allow installd system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 29

# Scan through APKs in /vendor/app

#line 31
allow installd vendor_app_file:dir { open getattr read search ioctl lock };
#line 31
allow installd vendor_app_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 31

# Scan through Runtime Resource Overlay APKs in /vendor/overlay

#line 33
allow installd vendor_overlay_file:dir { open getattr read search ioctl lock };
#line 33
allow installd vendor_overlay_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 33

# Get file context
allow installd file_contexts_file:file { getattr open read ioctl lock map };
# Get seapp_context
allow installd seapp_contexts_file:file { getattr open read ioctl lock map };

# Search /data/app-asec and stat files in it.
allow installd asec_image_file:dir search;
allow installd asec_image_file:file getattr;

# Create /data/user and /data/user/0 if necessary.
# Also required to initially create /data/data subdirectories
# and lib symlinks before the setfilecon call.  May want to
# move symlink creation after setfilecon in installd.
allow installd system_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow installd system_data_file:lnk_file { create setattr unlink };

# Upgrade /data/media for multi-user if necessary.
allow installd media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow installd media_rw_data_file:file { getattr unlink };
# restorecon new /data/media directory.
allow installd system_data_file:dir relabelfrom;
allow installd media_rw_data_file:dir relabelto;

# Delete /data/media files through sdcardfs, instead of going behind its back
allow installd tmpfs:dir { open getattr read search ioctl lock };
allow installd storage_file:dir search;
allow installd sdcardfs:dir { search open read write remove_name getattr rmdir };
allow installd sdcardfs:file { getattr unlink };

# Upgrade /data/misc/keychain for multi-user if necessary.
allow installd misc_user_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow installd misc_user_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow installd keychain_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow installd keychain_data_file:file {{ getattr open read ioctl lock map } unlink};

# Create /data/.layout_version.* file
allow installd install_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Create files under /data/dalvik-cache.
allow installd dalvikcache_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow installd dalvikcache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow installd dalvikcache_data_file:lnk_file getattr;

# Create files under /data/resource-cache.
allow installd resourcecache_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow installd resourcecache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Upgrade from unlabeled userdata.
# Just need enough to remove and/or relabel it.
allow installd unlabeled:dir { getattr search relabelfrom { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } rmdir };
allow installd unlabeled:{ file lnk_file sock_file fifo_file } { getattr relabelfrom rename unlink setattr };
# Read pkg.apk file for input during dexopt.
allow installd unlabeled:file { getattr open read ioctl lock map };

# Upgrade from before system_app_data_file was used for system UID apps.
# Just need enough to relabel it and to unlink removed package files.
# Directory access covered by earlier rule above.
allow installd system_data_file:{ file lnk_file sock_file fifo_file } { getattr relabelfrom unlink };

# Manage /data/data subdirectories, including initially labeling them
# upon creation via setfilecon or running restorecon_recursive,
# setting owner/mode, creating symlinks within them, and deleting them
# upon package uninstall.
# Types extracted from seapp_contexts type= fields.
allow installd {
    system_app_data_file
    bluetooth_data_file
    nfc_data_file
    radio_data_file
    shell_data_file
    app_data_file
}:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } relabelfrom relabelto };

allow installd {
    system_app_data_file
    bluetooth_data_file
    nfc_data_file
    radio_data_file
    shell_data_file
    app_data_file
}:{ file lnk_file sock_file fifo_file } { { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } relabelfrom relabelto };

# Similar for the files under /data/misc/profiles/
allow installd user_profile_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow installd user_profile_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow installd user_profile_data_file:dir rmdir;
allow installd user_profile_data_file:file unlink;

# Files created/updated by profman dumps.
allow installd profman_dump_data_file:dir { search add_name write };
allow installd profman_dump_data_file:file { create setattr open write };

# Create and use pty created by android_fork_execvp().
allow installd devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# execute toybox for app relocation
allow installd toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Allow installd to publish a binder service and make binder calls.

#line 133
# Call the servicemanager and transfer references to it.
#line 133
allow installd servicemanager:binder { call transfer };
#line 133
# servicemanager performs getpidcon on clients.
#line 133
allow servicemanager installd:dir search;
#line 133
allow servicemanager installd:file { read open };
#line 133
allow servicemanager installd:process getattr;
#line 133
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 133
# all domains in domain.te.
#line 133


#line 134
  allow installd installd_service:service_manager { add find };
#line 134
  neverallow { domain -installd } installd_service:service_manager add;
#line 134

allow installd dumpstate:fifo_file  { getattr write };

# Allow installd to call into the system server so it can check permissions.

#line 138
# Call the server domain and optionally transfer references to it.
#line 138
allow installd system_server:binder { call transfer };
#line 138
# Allow the serverdomain to transfer references to the client on the reply.
#line 138
allow system_server installd:binder transfer;
#line 138
# Receive and use open files from the server.
#line 138
allow installd system_server:fd use;
#line 138

allow installd permission_service:service_manager find;

# Allow installd to read and write quotas
allow installd block_device:dir { search };
allow installd labeledfs:filesystem { quotaget quotamod };

# Allow installd to delete from /data/preloads when trimming data caches
# TODO b/34690396 Remove when time-based purge policy for preloads is implemented in system_server
allow installd preloads_data_file:file { { getattr open read ioctl lock map } unlink };
allow installd preloads_data_file:dir { { open getattr read search ioctl lock } write remove_name rmdir };
allow installd preloads_media_file:file { { getattr open read ioctl lock map } unlink };
allow installd preloads_media_file:dir { { open getattr read search ioctl lock } write remove_name rmdir };

###
### Neverallow rules
###

# only system_server, installd and dumpstate may interact with installd over binder
neverallow { domain -system_server -dumpstate -installd } installd_service:service_manager find;
neverallow { domain -system_server -dumpstate } installd:binder call;
neverallow installd { domain -system_server -servicemanager -su }:binder call;
#line 1 "system/sepolicy/public/isolated_app.te"
###
### Services with isolatedProcess=true in their manifest.
###
### This file defines the rules for isolated apps. An "isolated
### app" is an APP with UID between AID_ISOLATED_START (99000)
### and AID_ISOLATED_END (99999).
###

type isolated_app, domain;
#line 1 "system/sepolicy/public/kernel.te"
# Life begins with the kernel.
type kernel, domain, mlstrustedsubject;

allow kernel self:capability sys_nice;

# Root fs.

#line 7
allow kernel rootfs:dir { open getattr read search ioctl lock };
#line 7
allow kernel rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 7


#line 8
allow kernel proc:dir { open getattr read search ioctl lock };
#line 8
allow kernel proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 8


# Get SELinux enforcing status.
allow kernel selinuxfs:dir { open getattr read search ioctl lock };
allow kernel selinuxfs:file { getattr open read ioctl lock map };

# Get file contexts during first stage
allow kernel file_contexts_file:file { getattr open read ioctl lock map };

# Allow init relabel itself.
allow kernel rootfs:file relabelfrom;
allow kernel init_exec:file relabelto;
# TODO: investigate why we need this.
allow kernel init:process share;

# cgroup filesystem initialization prior to setting the cgroup root directory label.
allow kernel unlabeled:dir search;

# Mount usbfs.
allow kernel usbfs:filesystem mount;
allow kernel usbfs:dir search;

# Initial setenforce by init prior to switching to init domain.
# We use dontaudit instead of allow to prevent a kernel spawned userspace
# process from turning off SELinux once enabled.
dontaudit kernel self:security setenforce;

# Write to /proc/1/oom_adj prior to switching to init domain.
allow kernel self:capability sys_resource;

# Init reboot before switching selinux domains under certain error
# conditions. Allow it.
# As part of rebooting, init writes "u" to /proc/sysrq-trigger to
# remount filesystems read-only. /data is not mounted at this point,
# so we could ignore this. For now, we allow it.
allow kernel self:capability sys_boot;
allow kernel proc_sysrq:file { open append write lock map };

# Allow writing to /dev/kmsg which was created prior to loading policy.
allow kernel tmpfs:chr_file write;

# Set checkreqprot by init.rc prior to switching to init domain.
allow kernel selinuxfs:file write;
allow kernel self:security setcheckreqprot;

# kernel thread "loop0", used by the loop block device, for ASECs (b/17158723)
allow kernel sdcard_type:file { read write };

# f_mtp driver accesses files from kernel context.
allow kernel mediaprovider:fd use;

# Allow the kernel to read OBB files from app directories. (b/17428116)
# Kernel thread "loop0" reads a vold supplied file descriptor.
# Fixes CTS tests:
#  * android.os.storage.cts.StorageManagerTest#testMountAndUnmountObbNormal
#  * android.os.storage.cts.StorageManagerTest#testMountAndUnmountTwoObbs
allow kernel vold:fd use;
allow kernel app_data_file:file read;
allow kernel asec_image_file:file read;

# Allow reading loop device in update_engine_unittests. (b/28319454)

#line 69
  allow kernel update_engine_data_file:file read;
#line 69
  allow kernel nativetest_data_file:file read;
#line 72


# Access to /data/media.
# This should be removed if sdcardfs is modified to alter the secontext for its
# accesses to the underlying FS.
allow kernel media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow kernel media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access to /data/misc/vold/virtual_disk.
allow kernel vold_data_file:file read;

###
### neverallow rules
###

# The initial task starts in the kernel domain (assigned via
# initial_sid_contexts), but nothing ever transitions to it.
neverallow * kernel:process { transition dyntransition };

# The kernel domain is never entered via an exec, nor should it
# ever execute a program outside the rootfs without changing to another domain.
# If you encounter an execute_no_trans denial on the kernel domain, then
# possible causes include:
# - The program is a kernel usermodehelper.  In this case, define a domain
#   for the program and domain_auto_trans() to it.
# - You are running an exploit which switched to the init task credentials
#   and is then trying to exec a shell or other program.  You lose!
neverallow kernel *:file { entrypoint execute_no_trans };

# the kernel should not be accessing files owned by other users.
# Instead of adding dac_{read_search,override}, fix the unix permissions
# on files being accessed.
neverallow kernel self:capability { dac_override dac_read_search };
#line 1 "system/sepolicy/public/keystore.te"
type keystore, domain;
type keystore_exec, exec_type, file_type;

# keystore daemon
typeattribute keystore mlstrustedsubject;

#line 6
# Call the servicemanager and transfer references to it.
#line 6
allow keystore servicemanager:binder { call transfer };
#line 6
# servicemanager performs getpidcon on clients.
#line 6
allow servicemanager keystore:dir search;
#line 6
allow servicemanager keystore:file { read open };
#line 6
allow servicemanager keystore:process getattr;
#line 6
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 6
# all domains in domain.te.
#line 6


#line 7
typeattribute keystore binderservicedomain;
#line 7


#line 8
# Call the server domain and optionally transfer references to it.
#line 8
allow keystore system_server:binder { call transfer };
#line 8
# Allow the serverdomain to transfer references to the client on the reply.
#line 8
allow system_server keystore:binder transfer;
#line 8
# Receive and use open files from the server.
#line 8
allow keystore system_server:fd use;
#line 8


allow keystore keystore_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow keystore keystore_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow keystore keystore_exec:file { getattr };


#line 14
  allow keystore keystore_service:service_manager { add find };
#line 14
  neverallow { domain -keystore } keystore_service:service_manager add;
#line 14

allow keystore sec_key_att_app_id_provider_service:service_manager find;

# Check SELinux permissions.

#line 18

#line 18
allow keystore selinuxfs:dir { open getattr read search ioctl lock };
#line 18
allow keystore selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 18

#line 18
allow keystore selinuxfs:file { open append write lock map };
#line 18
allow keystore kernel:security compute_av;
#line 18
allow keystore self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 18



#line 20
allow keystore cgroup:dir { open getattr read search ioctl lock };
#line 20
allow keystore cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 20


###
### Neverallow rules
###
### Protect ourself from others
###

neverallow { domain -keystore } keystore_data_file:dir ~{ open create read getattr setattr search relabelto ioctl };
neverallow { domain -keystore } keystore_data_file:{ file lnk_file sock_file fifo_file } ~{ relabelto getattr };

neverallow { domain -keystore -init } keystore_data_file:dir *;
neverallow { domain -keystore -init } keystore_data_file:{ file lnk_file sock_file fifo_file } *;

neverallow * keystore:process ptrace;
#line 1 "system/sepolicy/public/lmkd.te"
# lmkd low memory killer daemon
type lmkd, domain, mlstrustedsubject;
type lmkd_exec, exec_type, file_type;

allow lmkd self:capability { dac_override sys_resource kill };

# lmkd locks itself in memory, to prevent it from being
# swapped out and unable to kill other memory hogs.
# system/core commit b28ff9131363f7b4a698990da5748b2a88c3ed35
# b/16236289
allow lmkd self:capability ipc_lock;

## Open and write to /proc/PID/oom_score_adj
## TODO: maybe scope this down?

#line 15
allow lmkd appdomain:dir { open getattr read search ioctl lock };
#line 15
allow lmkd appdomain:{ file lnk_file } { getattr open read ioctl lock map };
#line 15

allow lmkd appdomain:file write;

#line 17
allow lmkd system_server:dir { open getattr read search ioctl lock };
#line 17
allow lmkd system_server:{ file lnk_file } { getattr open read ioctl lock map };
#line 17

allow lmkd system_server:file write;

## Writes to /sys/module/lowmemorykiller/parameters/minfree

#line 21
allow lmkd sysfs_type:dir { open getattr read search ioctl lock };
#line 21
allow lmkd sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 21

allow lmkd sysfs_lowmemorykiller:file { open append write lock map };

# Send kill signals
allow lmkd appdomain:process sigkill;

# Clean up old cgroups
allow lmkd cgroup:dir { remove_name rmdir };

# Allow to read memcg stats
allow lmkd cgroup:file { getattr open read ioctl lock map };

# Set self to SCHED_FIFO
allow lmkd self:capability sys_nice;

allow lmkd proc_zoneinfo:file { getattr open read ioctl lock map };

### neverallow rules

# never honor LD_PRELOAD
neverallow * lmkd:process noatsecure;
#line 1 "system/sepolicy/public/logd.te"
# android user-space log manager
type logd, domain, mlstrustedsubject;
type logd_exec, exec_type, file_type;

# Read access to pseudo filesystems.

#line 6
allow logd cgroup:dir { open getattr read search ioctl lock };
#line 6
allow logd cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 6


#line 7
allow logd proc:dir { open getattr read search ioctl lock };
#line 7
allow logd proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 7


#line 8
allow logd proc_meminfo:dir { open getattr read search ioctl lock };
#line 8
allow logd proc_meminfo:{ file lnk_file } { getattr open read ioctl lock map };
#line 8


#line 9
allow logd proc_net:dir { open getattr read search ioctl lock };
#line 9
allow logd proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 9


allow logd self:capability { setuid setgid setpcap sys_nice audit_control };
allow logd self:capability2 syslog;
allow logd self:netlink_audit_socket { { create { read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_write };
allow logd kernel:system syslog_read;
allow logd kmsg_device:chr_file { open append write lock map };
allow logd system_data_file:{ file lnk_file } { getattr open read ioctl lock map };
allow logd pstorefs:dir search;
allow logd pstorefs:file { getattr open read ioctl lock map };

#line 19
  # Access to /data/misc/logd/event-log-tags
#line 19
  allow logd misc_logd_file:dir { open getattr read search ioctl lock };
#line 19
  allow logd misc_logd_file:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 23

allow logd runtime_event_log_tags_file:file { { getattr open read ioctl lock map } { open append write lock map } };

# Access device logging gating property

#line 27
allow logd device_logging_prop:file { getattr open read ioctl lock map };
#line 27



#line 29
allow logd domain:dir { open getattr read search ioctl lock };
#line 29
allow logd domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 29


allow logd kernel:system syslog_mod;


#line 33
# Group AID_LOG checked by filesystem & logd
#line 33
# to permit control commands
#line 33

#line 33

#line 33

#line 33
allow logd logd_socket:sock_file write;
#line 33
allow logd logd:unix_stream_socket connectto;
#line 33

#line 33

#line 33


#line 34
allow logd runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 34


allow runtime_event_log_tags_file tmpfs:filesystem associate;
# Typically harmlessly blindly trying to access via liblog
# event tag mapping while in the untrusted_app domain.
# Access for that domain is controlled and gated via the
# event log tag service (albeit at a performance penalty,
# expected to be locally cached).
dontaudit domain runtime_event_log_tags_file:file { open read };

###
### Neverallow rules
###
### logd should NEVER do any of this

# Block device access.
neverallow logd dev_type:blk_file { read write };

# ptrace any other app
neverallow logd domain:process ptrace;

# ... and nobody may ptrace me (except on userdebug or eng builds)
neverallow { domain -crash_dump } logd:process ptrace;

# Write to /system.
neverallow logd system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data or system files on /data
neverallow logd { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Only init is allowed to enter the logd domain via exec()
neverallow { domain -init } logd:process transition;
neverallow * logd:process dyntransition;

# protect the event-log-tags file
neverallow {
  domain
  -init
  -logd
} runtime_event_log_tags_file:file { append create link unlink relabelfrom rename setattr write };
#line 1 "system/sepolicy/public/logpersist.te"
# android debug logging, logpersist domains
type logpersist, domain;

###
### Neverallow rules
###
### logpersist should NEVER do any of this

# Block device access.
neverallow logpersist dev_type:blk_file { read write };

# ptrace any other app
neverallow logpersist domain:process ptrace;

# Write to files in /data/data or system files on /data except misc_logd_file
neverallow logpersist { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Only init should be allowed to enter the logpersist domain via exec()
# Following is a list of debug domains we know that transition to logpersist
# neverallow_with_undefined_domains {
#   domain
#   -init       # goldfish, logcatd, raft
#   -mmi        # bat, mtp8996, msmcobalt
#   -system_app # Smith.apk
# } logpersist:process transition;
neverallow * logpersist:process dyntransition;
#line 1 "system/sepolicy/public/mdnsd.te"
# mdns daemon
type mdnsd, domain;
#line 1 "system/sepolicy/public/mediacodec.te"
# mediacodec - audio and video codecs live here
type mediacodec, domain;
type mediacodec_exec, exec_type, vendor_file_type, file_type;

typeattribute mediacodec mlstrustedsubject;

# TODO(b/36375899) attributize this domain appropriately as hal_omx
# and use macro hal_server_domain

#line 9
allow mediacodec hwservicemanager_prop:file { getattr open read ioctl lock map };
#line 9


# can route /dev/binder traffic to /dev/vndbinder

#line 12
# Talk to the vndbinder device node
#line 12
allow mediacodec vndbinder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 12
# Call the vndservicemanager and transfer references to it.
#line 12
allow mediacodec vndservicemanager:binder { call transfer };
#line 12
# vndservicemanager performs getpidcon on clients.
#line 12
allow vndservicemanager mediacodec:dir search;
#line 12
allow vndservicemanager mediacodec:file { read open };
#line 12
allow vndservicemanager mediacodec:process getattr;
#line 12



#line 14
    # on legacy devices, continue to allow /dev/binder traffic
#line 14
    
#line 14
# Call the servicemanager and transfer references to it.
#line 14
allow mediacodec servicemanager:binder { call transfer };
#line 14
# servicemanager performs getpidcon on clients.
#line 14
allow servicemanager mediacodec:dir search;
#line 14
allow servicemanager mediacodec:file { read open };
#line 14
allow servicemanager mediacodec:process getattr;
#line 14
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 14
# all domains in domain.te.
#line 14

#line 14
    
#line 14
typeattribute mediacodec binderservicedomain;
#line 14

#line 14
    
#line 14
  allow mediacodec mediacodec_service:service_manager { add find };
#line 14
  neverallow { domain -mediacodec } mediacodec_service:service_manager add;
#line 14

#line 14
    allow mediacodec mediametrics_service:service_manager find;
#line 14
    allow mediacodec surfaceflinger_service:service_manager find;
#line 21


#line 22
# Call the server domain and optionally transfer references to it.
#line 22
allow mediacodec binderservicedomain:binder { call transfer };
#line 22
# Allow the serverdomain to transfer references to the client on the reply.
#line 22
allow binderservicedomain mediacodec:binder transfer;
#line 22
# Receive and use open files from the server.
#line 22
allow mediacodec binderservicedomain:fd use;
#line 22


#line 23
# Call the server domain and optionally transfer references to it.
#line 23
allow mediacodec appdomain:binder { call transfer };
#line 23
# Allow the serverdomain to transfer references to the client on the reply.
#line 23
allow appdomain mediacodec:binder transfer;
#line 23
# Receive and use open files from the server.
#line 23
allow mediacodec appdomain:fd use;
#line 23


# Allow mediacodec access to composer sync fences
allow mediacodec hal_graphics_composer:fd use;

allow mediacodec gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow mediacodec video_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow mediacodec video_device:dir search;
allow mediacodec ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow mediacodec hal_camera:fd use;


#line 34

#line 34
  allow mediacodec su:fifo_file append;
#line 34

#line 34
allow mediacodec anr_data_file:file append;
#line 34
allow mediacodec dumpstate:fd use;
#line 34
# TODO: Figure out why write is needed.
#line 34
allow mediacodec dumpstate:fifo_file { append write };
#line 34
allow mediacodec system_server:fifo_file { append write };
#line 34
allow mediacodec tombstoned:unix_stream_socket connectto;
#line 34
allow mediacodec tombstoned:fd use;
#line 34
allow mediacodec tombstoned_crash_socket:sock_file write;
#line 34
allow mediacodec tombstone_data_file:file append;
#line 34



#line 36
  allow mediacodec hal_omx_hwservice:hwservice_manager { add find };
#line 36
  allow mediacodec hidl_base_hwservice:hwservice_manager add;
#line 36
  neverallow { domain -mediacodec } hal_omx_hwservice:hwservice_manager add;
#line 36



#line 38
typeattribute mediacodec halclientdomain;
#line 38
typeattribute mediacodec hal_allocator_client;
#line 38

#line 38
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 38
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 38
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 38

#line 38
typeattribute mediacodec hal_allocator;
#line 38
# Find passthrough HAL implementations
#line 38
allow hal_allocator system_file:dir { open getattr read search ioctl lock };
#line 38
allow hal_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 38
allow hal_allocator vendor_file:file { read open getattr execute map };
#line 38

#line 38



#line 40
typeattribute mediacodec halclientdomain;
#line 40
typeattribute mediacodec hal_cas_client;
#line 40

#line 40
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 40
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 40
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 40

#line 40
typeattribute mediacodec hal_cas;
#line 40
# Find passthrough HAL implementations
#line 40
allow hal_cas system_file:dir { open getattr read search ioctl lock };
#line 40
allow hal_cas vendor_file:dir { open getattr read search ioctl lock };
#line 40
allow hal_cas vendor_file:file { read open getattr execute map };
#line 40

#line 40


# allocate and use graphic buffers

#line 43
typeattribute mediacodec halclientdomain;
#line 43
typeattribute mediacodec hal_graphics_allocator_client;
#line 43

#line 43
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 43
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 43
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 43

#line 43
typeattribute mediacodec hal_graphics_allocator;
#line 43
# Find passthrough HAL implementations
#line 43
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 43
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 43
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 43

#line 43


# Recieve gralloc buffer FDs from bufferhubd. Note that mediacodec never
# directly connects to bufferhubd via PDX. Instead, a VR app acts as a bridge
# between those two: it talks to mediacodec via Binder and talks to bufferhubd
# via PDX. Thus, there is no need to use pdx_client macro.
allow mediacodec bufferhubd:fd use;

###
### neverallow rules
###

# mediacodec should never execute any executable without a
# domain transition
neverallow mediacodec { file_type fs_type }:file execute_no_trans;

# The goal of the mediaserver split is to place media processing code into
# restrictive sandboxes with limited responsibilities and thus limited
# permissions. Example: Audioserver is only responsible for controlling audio
# hardware and processing audio content. Cameraserver does the same for camera
# hardware/content. Etc.
#
# Media processing code is inherently risky and thus should have limited
# permissions and be isolated from the rest of the system and network.
# Lengthier explanation here:
# https://android-developers.googleblog.com/2016/05/hardening-media-stack.html
neverallow mediacodec domain:{ tcp_socket udp_socket rawip_socket } *;
#line 1 "system/sepolicy/public/mediadrmserver.te"
# mediadrmserver - mediadrm daemon
type mediadrmserver, domain;
type mediadrmserver_exec, exec_type, file_type;

typeattribute mediadrmserver mlstrustedsubject;


#line 7
typeattribute mediadrmserver netdomain;
#line 7


#line 8
# Call the servicemanager and transfer references to it.
#line 8
allow mediadrmserver servicemanager:binder { call transfer };
#line 8
# servicemanager performs getpidcon on clients.
#line 8
allow servicemanager mediadrmserver:dir search;
#line 8
allow servicemanager mediadrmserver:file { read open };
#line 8
allow servicemanager mediadrmserver:process getattr;
#line 8
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 8
# all domains in domain.te.
#line 8


#line 9
# Call the server domain and optionally transfer references to it.
#line 9
allow mediadrmserver binderservicedomain:binder { call transfer };
#line 9
# Allow the serverdomain to transfer references to the client on the reply.
#line 9
allow binderservicedomain mediadrmserver:binder transfer;
#line 9
# Receive and use open files from the server.
#line 9
allow mediadrmserver binderservicedomain:fd use;
#line 9


#line 10
# Call the server domain and optionally transfer references to it.
#line 10
allow mediadrmserver appdomain:binder { call transfer };
#line 10
# Allow the serverdomain to transfer references to the client on the reply.
#line 10
allow appdomain mediadrmserver:binder transfer;
#line 10
# Receive and use open files from the server.
#line 10
allow mediadrmserver appdomain:fd use;
#line 10


#line 11
typeattribute mediadrmserver binderservicedomain;
#line 11


#line 12
typeattribute mediadrmserver halclientdomain;
#line 12
typeattribute mediadrmserver hal_drm_client;
#line 12

#line 12
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 12
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 12
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 12

#line 12
typeattribute mediadrmserver hal_drm;
#line 12
# Find passthrough HAL implementations
#line 12
allow hal_drm system_file:dir { open getattr read search ioctl lock };
#line 12
allow hal_drm vendor_file:dir { open getattr read search ioctl lock };
#line 12
allow hal_drm vendor_file:file { read open getattr execute map };
#line 12

#line 12



#line 14
  allow mediadrmserver mediadrmserver_service:service_manager { add find };
#line 14
  neverallow { domain -mediadrmserver } mediadrmserver_service:service_manager add;
#line 14

allow mediadrmserver mediaserver_service:service_manager find;
allow mediadrmserver mediametrics_service:service_manager find;
allow mediadrmserver processinfo_service:service_manager find;
allow mediadrmserver surfaceflinger_service:service_manager find;
allow mediadrmserver system_file:dir { open getattr read search ioctl lock };


#line 21
# Call the server domain and optionally transfer references to it.
#line 21
allow mediadrmserver mediacodec:binder { call transfer };
#line 21
# Allow the serverdomain to transfer references to the client on the reply.
#line 21
allow mediacodec mediadrmserver:binder transfer;
#line 21
# Receive and use open files from the server.
#line 21
allow mediadrmserver mediacodec:fd use;
#line 21

###
### neverallow rules
###

# mediadrmserver should never execute any executable without a
# domain transition
neverallow mediadrmserver { file_type fs_type }:file execute_no_trans;

# do not allow privileged socket ioctl commands
neverallowxperm mediadrmserver domain:{ rawip_socket tcp_socket udp_socket } ioctl 
#line 31
{
#line 31
# qualcomm rmnet ioctls
#line 31
0x00006900 0x00006902
#line 31
# socket ioctls
#line 31
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 31
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 31
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 31
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 31
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 31
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 31
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 31
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 31
0x00008991 0x00008992 0x00008993 0x00008994
#line 31
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 31
# device and protocol specific ioctls
#line 31
0x000089f0-0x000089ff
#line 31
0x000089e0-0x000089ef
#line 31
# Wireless extension ioctls
#line 31
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 31
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 31
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 31
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 31
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 31
0x00008b34 0x00008b35 0x00008b36
#line 31
# Dev private ioctl i.e. hardware specific ioctls
#line 31
0x00008be0-0x00008bff
#line 31
};
#line 1 "system/sepolicy/public/mediaextractor.te"
# mediaextractor - multimedia daemon
type mediaextractor, domain;
type mediaextractor_exec, exec_type, file_type;

typeattribute mediaextractor mlstrustedsubject;


#line 7
# Call the servicemanager and transfer references to it.
#line 7
allow mediaextractor servicemanager:binder { call transfer };
#line 7
# servicemanager performs getpidcon on clients.
#line 7
allow servicemanager mediaextractor:dir search;
#line 7
allow servicemanager mediaextractor:file { read open };
#line 7
allow servicemanager mediaextractor:process getattr;
#line 7
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 7
# all domains in domain.te.
#line 7


#line 8
# Call the server domain and optionally transfer references to it.
#line 8
allow mediaextractor binderservicedomain:binder { call transfer };
#line 8
# Allow the serverdomain to transfer references to the client on the reply.
#line 8
allow binderservicedomain mediaextractor:binder transfer;
#line 8
# Receive and use open files from the server.
#line 8
allow mediaextractor binderservicedomain:fd use;
#line 8


#line 9
# Call the server domain and optionally transfer references to it.
#line 9
allow mediaextractor appdomain:binder { call transfer };
#line 9
# Allow the serverdomain to transfer references to the client on the reply.
#line 9
allow appdomain mediaextractor:binder transfer;
#line 9
# Receive and use open files from the server.
#line 9
allow mediaextractor appdomain:fd use;
#line 9


#line 10
typeattribute mediaextractor binderservicedomain;
#line 10



#line 12
  allow mediaextractor mediaextractor_service:service_manager { add find };
#line 12
  neverallow { domain -mediaextractor } mediaextractor_service:service_manager add;
#line 12

allow mediaextractor mediametrics_service:service_manager find;
allow mediaextractor hidl_token_hwservice:hwservice_manager find;

allow mediaextractor system_server:fd use;


#line 18
typeattribute mediaextractor halclientdomain;
#line 18
typeattribute mediaextractor hal_cas_client;
#line 18

#line 18
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 18
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 18
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 18

#line 18
typeattribute mediaextractor hal_cas;
#line 18
# Find passthrough HAL implementations
#line 18
allow hal_cas system_file:dir { open getattr read search ioctl lock };
#line 18
allow hal_cas vendor_file:dir { open getattr read search ioctl lock };
#line 18
allow hal_cas vendor_file:file { read open getattr execute map };
#line 18

#line 18



#line 20
allow mediaextractor cgroup:dir { open getattr read search ioctl lock };
#line 20
allow mediaextractor cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 20

allow mediaextractor proc_meminfo:file { getattr open read ioctl lock map };


#line 23

#line 23
  allow mediaextractor su:fifo_file append;
#line 23

#line 23
allow mediaextractor anr_data_file:file append;
#line 23
allow mediaextractor dumpstate:fd use;
#line 23
# TODO: Figure out why write is needed.
#line 23
allow mediaextractor dumpstate:fifo_file { append write };
#line 23
allow mediaextractor system_server:fifo_file { append write };
#line 23
allow mediaextractor tombstoned:unix_stream_socket connectto;
#line 23
allow mediaextractor tombstoned:fd use;
#line 23
allow mediaextractor tombstoned_crash_socket:sock_file write;
#line 23
allow mediaextractor tombstone_data_file:file append;
#line 23


# allow mediaextractor read permissions for file sources
allow mediaextractor media_rw_data_file:file { getattr read };
allow mediaextractor app_data_file:file { getattr read };

# Read resources from open apk files passed over Binder
allow mediaextractor apk_data_file:file { read getattr };
allow mediaextractor asec_apk_file:file { read getattr };
allow mediaextractor ringtone_file:file { read getattr };

###
### neverallow rules
###

# mediaextractor should never execute any executable without a
# domain transition
neverallow mediaextractor { file_type fs_type }:file execute_no_trans;

# The goal of the mediaserver split is to place media processing code into
# restrictive sandboxes with limited responsibilities and thus limited
# permissions. Example: Audioserver is only responsible for controlling audio
# hardware and processing audio content. Cameraserver does the same for camera
# hardware/content. Etc.
#
# Media processing code is inherently risky and thus should have limited
# permissions and be isolated from the rest of the system and network.
# Lengthier explanation here:
# https://android-developers.googleblog.com/2016/05/hardening-media-stack.html
neverallow mediaextractor domain:{ tcp_socket udp_socket rawip_socket } *;
#line 1 "system/sepolicy/public/mediametrics.te"
# mediametrics - daemon for collecting media.metrics data
type mediametrics, domain;
type mediametrics_exec, exec_type, file_type;



#line 6
# Call the servicemanager and transfer references to it.
#line 6
allow mediametrics servicemanager:binder { call transfer };
#line 6
# servicemanager performs getpidcon on clients.
#line 6
allow servicemanager mediametrics:dir search;
#line 6
allow servicemanager mediametrics:file { read open };
#line 6
allow servicemanager mediametrics:process getattr;
#line 6
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 6
# all domains in domain.te.
#line 6


#line 7
# Call the server domain and optionally transfer references to it.
#line 7
allow mediametrics binderservicedomain:binder { call transfer };
#line 7
# Allow the serverdomain to transfer references to the client on the reply.
#line 7
allow binderservicedomain mediametrics:binder transfer;
#line 7
# Receive and use open files from the server.
#line 7
allow mediametrics binderservicedomain:fd use;
#line 7


#line 8
typeattribute mediametrics binderservicedomain;
#line 8



#line 10
  allow mediametrics mediametrics_service:service_manager { add find };
#line 10
  neverallow { domain -mediametrics } mediametrics_service:service_manager add;
#line 10


allow mediametrics system_server:fd use;


#line 14
allow mediametrics cgroup:dir { open getattr read search ioctl lock };
#line 14
allow mediametrics cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 14

allow mediametrics proc_meminfo:file { getattr open read ioctl lock map };

# allows interactions with dumpsys to GMScore
allow mediametrics app_data_file:file write;

# allow access to package manager for uid->apk mapping
allow mediametrics package_native_service:service_manager find;

###
### neverallow rules
###

# mediametrics should never execute any executable without a
# domain transition
neverallow mediametrics { file_type fs_type }:file execute_no_trans;

# The goal of the mediaserver split is to place media processing code into
# restrictive sandboxes with limited responsibilities and thus limited
# permissions. Example: Audioserver is only responsible for controlling audio
# hardware and processing audio content. Cameraserver does the same for camera
# hardware/content. Etc.
#
# Media processing code is inherently risky and thus should have limited
# permissions and be isolated from the rest of the system and network.
# Lengthier explanation here:
# https://android-developers.googleblog.com/2016/05/hardening-media-stack.html
neverallow mediametrics domain:{ tcp_socket udp_socket rawip_socket } *;
#line 1 "system/sepolicy/public/mediaprovider.te"
###
### A domain for android.process.media, which contains both
### MediaProvider and DownloadProvider and associated services.
###

type mediaprovider, domain;
#line 1 "system/sepolicy/public/mediaserver.te"
# mediaserver - multimedia daemon
type mediaserver, domain;
type mediaserver_exec, exec_type, file_type;

typeattribute mediaserver mlstrustedsubject;

# TODO(b/36375899): replace with hal_client_domain macro on hal_omx
typeattribute mediaserver halclientdomain;


#line 10
typeattribute mediaserver netdomain;
#line 10



#line 12
allow mediaserver sdcard_type:dir { open getattr read search ioctl lock };
#line 12
allow mediaserver sdcard_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 12


#line 13
allow mediaserver cgroup:dir { open getattr read search ioctl lock };
#line 13
allow mediaserver cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 13


# stat /proc/self
allow mediaserver proc:lnk_file getattr;

# open /vendor/lib/mediadrm
allow mediaserver system_file:dir { open getattr read search ioctl lock };


#line 21
  # ptrace to processes in the same domain for memory leak detection
#line 21
  allow mediaserver self:process ptrace;
#line 24



#line 26
# Call the servicemanager and transfer references to it.
#line 26
allow mediaserver servicemanager:binder { call transfer };
#line 26
# servicemanager performs getpidcon on clients.
#line 26
allow servicemanager mediaserver:dir search;
#line 26
allow servicemanager mediaserver:file { read open };
#line 26
allow servicemanager mediaserver:process getattr;
#line 26
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 26
# all domains in domain.te.
#line 26


#line 27
# Call the server domain and optionally transfer references to it.
#line 27
allow mediaserver binderservicedomain:binder { call transfer };
#line 27
# Allow the serverdomain to transfer references to the client on the reply.
#line 27
allow binderservicedomain mediaserver:binder transfer;
#line 27
# Receive and use open files from the server.
#line 27
allow mediaserver binderservicedomain:fd use;
#line 27


#line 28
# Call the server domain and optionally transfer references to it.
#line 28
allow mediaserver appdomain:binder { call transfer };
#line 28
# Allow the serverdomain to transfer references to the client on the reply.
#line 28
allow appdomain mediaserver:binder transfer;
#line 28
# Receive and use open files from the server.
#line 28
allow mediaserver appdomain:fd use;
#line 28


#line 29
typeattribute mediaserver binderservicedomain;
#line 29


allow mediaserver media_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow mediaserver media_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow mediaserver app_data_file:dir search;
allow mediaserver app_data_file:file { { getattr open read ioctl lock map } { open append write lock map } };
allow mediaserver sdcard_type:file write;
allow mediaserver gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow mediaserver video_device:dir { open getattr read search ioctl lock };
allow mediaserver video_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };


#line 40

#line 40
allow mediaserver property_socket:sock_file write;
#line 40
allow mediaserver init:unix_stream_socket connectto;
#line 40

#line 40
allow mediaserver audio_prop:property_service set;
#line 40

#line 40
allow mediaserver audio_prop:file { getattr open read ioctl lock map };
#line 40

#line 40


# XXX Label with a specific type?
allow mediaserver sysfs:file { getattr open read ioctl lock map };

# Read resources from open apk files passed over Binder.
allow mediaserver apk_data_file:file { read getattr };
allow mediaserver asec_apk_file:file { read getattr };
allow mediaserver ringtone_file:file { read getattr };

# Read /data/data/com.android.providers.telephony files passed over Binder.
allow mediaserver radio_data_file:file { read getattr };

# Use pipes passed over Binder from app domains.
allow mediaserver appdomain:fifo_file { getattr read write };

allow mediaserver rpmsg_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Inter System processes communicate over named pipe (FIFO)
allow mediaserver system_server:fifo_file { getattr open read ioctl lock map };


#line 61
allow mediaserver media_rw_data_file:dir { open getattr read search ioctl lock };
#line 61
allow mediaserver media_rw_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 61


# Grant access to read files on appfuse.
allow mediaserver app_fuse_file:file { read getattr };

# Read/[write] to /proc/net/xt_qtaguid/ctrl and /dev/xt_qtaguid
allow mediaserver qtaguid_proc:file { { getattr open read ioctl lock map } { open append write lock map } };
allow mediaserver qtaguid_device:chr_file { getattr open read ioctl lock map };

# Needed on some devices for playing DRM protected content,
# but seems expected and appropriate for all devices.

#line 72

#line 72

#line 72
allow mediaserver drmserver_socket:sock_file write;
#line 72
allow mediaserver drmserver:unix_stream_socket connectto;
#line 72

#line 72


# Needed on some devices for playing audio on paired BT device,
# but seems appropriate for all devices.

#line 76

#line 76

#line 76
allow mediaserver bluetooth_socket:sock_file write;
#line 76
allow mediaserver bluetooth:unix_stream_socket connectto;
#line 76

#line 76



#line 78
  allow mediaserver mediaserver_service:service_manager { add find };
#line 78
  neverallow { domain -mediaserver } mediaserver_service:service_manager add;
#line 78

allow mediaserver activity_service:service_manager find;
allow mediaserver appops_service:service_manager find;
allow mediaserver audioserver_service:service_manager find;
allow mediaserver cameraserver_service:service_manager find;
allow mediaserver batterystats_service:service_manager find;
allow mediaserver drmserver_service:service_manager find;
allow mediaserver mediaextractor_service:service_manager find;
allow mediaserver mediacodec_service:service_manager find;
allow mediaserver mediametrics_service:service_manager find;
allow mediaserver media_session_service:service_manager find;
allow mediaserver permission_service:service_manager find;
allow mediaserver power_service:service_manager find;
allow mediaserver processinfo_service:service_manager find;
allow mediaserver scheduling_policy_service:service_manager find;
allow mediaserver surfaceflinger_service:service_manager find;

# for ModDrm/MediaPlayer
allow mediaserver mediadrmserver_service:service_manager find;

# For interfacing with OMX HAL
allow mediaserver hidl_token_hwservice:hwservice_manager find;

# /oem access
allow mediaserver oemfs:dir search;
allow mediaserver oemfs:file { getattr open read ioctl lock map };


#line 105
  allow drmserver mediaserver:dir search;
#line 105
  allow drmserver mediaserver:file { read open };
#line 105
  allow drmserver mediaserver:process getattr;
#line 105

allow mediaserver drmserver:drmservice {
    consumeRights
    setPlaybackStatus
    openDecryptSession
    closeDecryptSession
    initializeDecryptUnit
    decrypt
    finalizeDecryptUnit
    pread
};

# only allow unprivileged socket ioctl commands
allowxperm mediaserver self:{ rawip_socket tcp_socket udp_socket }
  ioctl { 
#line 119
{
#line 119
# Socket ioctls for gathering information about the interface
#line 119
0x00008906 0x00008907
#line 119
0x00008910 0x00008912 0x00008913 0x00008915 0x00008917 0x00008919
#line 119
0x0000891b 0x00008921 0x00008933 0x00008938 0x00008942
#line 119
# Wireless extension ioctls. Primarily get functions.
#line 119
0x00008b01 0x00008b05 0x00008b07 0x00008b09 0x00008b0b 0x00008b0d
#line 119
0x00008b0f 0x00008b11 0x00008b12 0x00008b13 0x00008b21 0x00008b23
#line 119
0x00008b25 0x00008b27 0x00008b29 0x00008b2d
#line 119
} {
#line 119
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 119
  0x0000540b 0x00005410 0x0000540f
#line 119
} };

# Access to /data/media.
# This should be removed if sdcardfs is modified to alter the secontext for its
# accesses to the underlying FS.
allow mediaserver media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow mediaserver media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access to media in /data/preloads
allow mediaserver preloads_media_file:file { getattr read ioctl };

allow mediaserver ion_device:chr_file { getattr open read ioctl lock map };
allow mediaserver hal_graphics_allocator:fd use;
allow mediaserver hal_graphics_composer:fd use;
allow mediaserver hal_camera:fd use;

allow mediaserver system_server:fd use;


#line 137
typeattribute mediaserver halclientdomain;
#line 137
typeattribute mediaserver hal_allocator_client;
#line 137

#line 137
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 137
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 137
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 137

#line 137
typeattribute mediaserver hal_allocator;
#line 137
# Find passthrough HAL implementations
#line 137
allow hal_allocator system_file:dir { open getattr read search ioctl lock };
#line 137
allow hal_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 137
allow hal_allocator vendor_file:file { read open getattr execute map };
#line 137

#line 137



#line 139
# Call the server domain and optionally transfer references to it.
#line 139
allow mediaserver mediacodec:binder { call transfer };
#line 139
# Allow the serverdomain to transfer references to the client on the reply.
#line 139
allow mediacodec mediaserver:binder transfer;
#line 139
# Receive and use open files from the server.
#line 139
allow mediaserver mediacodec:fd use;
#line 139


###
### neverallow rules
###

# mediaserver should never execute any executable without a
# domain transition
neverallow mediaserver { file_type fs_type }:file execute_no_trans;

# do not allow privileged socket ioctl commands
neverallowxperm mediaserver domain:{ rawip_socket tcp_socket udp_socket } ioctl 
#line 150
{
#line 150
# qualcomm rmnet ioctls
#line 150
0x00006900 0x00006902
#line 150
# socket ioctls
#line 150
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 150
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 150
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 150
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 150
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 150
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 150
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 150
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 150
0x00008991 0x00008992 0x00008993 0x00008994
#line 150
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 150
# device and protocol specific ioctls
#line 150
0x000089f0-0x000089ff
#line 150
0x000089e0-0x000089ef
#line 150
# Wireless extension ioctls
#line 150
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 150
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 150
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 150
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 150
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 150
0x00008b34 0x00008b35 0x00008b36
#line 150
# Dev private ioctl i.e. hardware specific ioctls
#line 150
0x00008be0-0x00008bff
#line 150
};
#line 1 "system/sepolicy/public/modprobe.te"
type modprobe, domain;

allow modprobe proc_modules:file { getattr open read ioctl lock map };
allow modprobe self:capability sys_module;
allow modprobe kernel:key search;
#line 9

allow modprobe { system_file }:system module_load;

#line 11
allow modprobe { system_file }:dir { open getattr read search ioctl lock };
#line 11
allow modprobe { system_file }:{ file lnk_file } { getattr open read ioctl lock map };
#line 11

#line 1 "system/sepolicy/public/mtp.te"
# vpn tunneling protocol manager
type mtp, domain;
type mtp_exec, exec_type, file_type;


#line 5
typeattribute mtp netdomain;
#line 5


# pptp policy
allow mtp self:socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow mtp self:capability net_raw;
allow mtp ppp:process signal;
allow mtp vpn_data_file:dir search;
#line 1 "system/sepolicy/public/net.te"
# Network types
type node, node_type;
type netif, netif_type;
type port, port_type;
#line 1 "system/sepolicy/public/netd.te"
# network manager
type netd, domain, mlstrustedsubject;
type netd_exec, exec_type, file_type;


#line 5
typeattribute netd netdomain;
#line 5

# in addition to ioctls whitelisted for all domains, grant netd priv_sock_ioctls.
allowxperm netd self:udp_socket ioctl 
#line 7
{
#line 7
# qualcomm rmnet ioctls
#line 7
0x00006900 0x00006902
#line 7
# socket ioctls
#line 7
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 7
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 7
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 7
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 7
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 7
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 7
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 7
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 7
0x00008991 0x00008992 0x00008993 0x00008994
#line 7
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 7
# device and protocol specific ioctls
#line 7
0x000089f0-0x000089ff
#line 7
0x000089e0-0x000089ef
#line 7
# Wireless extension ioctls
#line 7
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 7
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 7
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 7
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 7
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 7
0x00008b34 0x00008b35 0x00008b36
#line 7
# Dev private ioctl i.e. hardware specific ioctls
#line 7
0x00008be0-0x00008bff
#line 7
};


#line 9
allow netd cgroup:dir { open getattr read search ioctl lock };
#line 9
allow netd cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 9

allow netd system_server:fd use;

allow netd self:capability { net_admin net_raw kill };
# Note: fsetid is deliberately not included above. fsetid checks are
# triggered by chmod on a directory or file owned by a group other
# than one of the groups assigned to the current process to see if
# the setgid bit should be cleared, regardless of whether the setgid
# bit was even set.  We do not appear to truly need this capability
# for netd to operate.
dontaudit netd self:capability fsetid;

allow netd self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd self:netlink_route_socket nlmsg_write;
allow netd self:netlink_nflog_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd self:netlink_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd self:netlink_tcpdiag_socket { { create { read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_read nlmsg_write };
allow netd self:netlink_generic_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd self:netlink_netfilter_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netd shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow netd system_file:file { getattr execute execute_no_trans map };
allow netd vendor_file:file { getattr execute execute_no_trans map };
allow netd devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Acquire advisory lock on /system/etc/xtables.lock
allow netd system_file:file lock;


#line 36
allow netd proc_net:dir { open getattr read search ioctl lock };
#line 36
allow netd proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 36

# For /proc/sys/net/ipv[46]/route/flush.
allow netd proc_net:file { { getattr open read ioctl lock map } { open append write lock map } };

# Enables PppController and interface enumeration (among others)

#line 41
allow netd sysfs_type:dir { open getattr read search ioctl lock };
#line 41
allow netd sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 41

# Allows setting interface MTU
allow netd sysfs:file write;

# TODO: added to match above sysfs rule. Remove me?
allow netd sysfs_usb:file write;

# TODO: netd previously thought it needed these permissions to do WiFi related
#       work.  However, after all the WiFi stuff is gone, we still need them.
#       Why?
allow netd self:capability { dac_override chown };

# Needed to update /data/misc/net/rt_tables
allow netd net_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow netd net_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow netd self:capability fowner;

# Needed to lock the iptables lock.
allow netd system_file:file lock;

# Allow netd to spawn dnsmasq in it's own domain
allow netd dnsmasq:process signal;

# Allow netd to start clatd in its own domain
allow netd clatd:process signal;


#line 67

#line 67
allow netd property_socket:sock_file write;
#line 67
allow netd init:unix_stream_socket connectto;
#line 67

#line 67
allow netd ctl_mdnsd_prop:property_service set;
#line 67

#line 67
allow netd ctl_mdnsd_prop:file { getattr open read ioctl lock map };
#line 67

#line 67


#line 68

#line 68
allow netd property_socket:sock_file write;
#line 68
allow netd init:unix_stream_socket connectto;
#line 68

#line 68
allow netd netd_stable_secret_prop:property_service set;
#line 68

#line 68
allow netd netd_stable_secret_prop:file { getattr open read ioctl lock map };
#line 68

#line 68


# Allow netd to publish a binder service and make binder calls.

#line 71
# Call the servicemanager and transfer references to it.
#line 71
allow netd servicemanager:binder { call transfer };
#line 71
# servicemanager performs getpidcon on clients.
#line 71
allow servicemanager netd:dir search;
#line 71
allow servicemanager netd:file { read open };
#line 71
allow servicemanager netd:process getattr;
#line 71
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 71
# all domains in domain.te.
#line 71


#line 72
  allow netd netd_service:service_manager { add find };
#line 72
  neverallow { domain -netd } netd_service:service_manager add;
#line 72

allow netd dumpstate:fifo_file  { getattr write };

# Allow netd to call into the system server so it can check permissions.
allow netd system_server:binder call;
allow netd permission_service:service_manager find;

# Allow netd to talk to the framework service which collects netd events.
allow netd netd_listener_service:service_manager find;

# Allow netd to operate on sockets that are passed to it.
allow netd netdomain:{
  tcp_socket
  udp_socket
  rawip_socket
  tun_socket
} { read write getattr setattr getopt setopt };
allow netd netdomain:fd use;

# give netd permission to read and write netlink xfrm
allow netd self:netlink_xfrm_socket { { create { read getattr write setattr lock append bind connect getopt setopt shutdown } } nlmsg_write nlmsg_read };

# Allow netd to register as hal server.

#line 95
  allow netd system_net_netd_hwservice:hwservice_manager { add find };
#line 95
  allow netd hidl_base_hwservice:hwservice_manager add;
#line 95
  neverallow { domain -netd } system_net_netd_hwservice:hwservice_manager add;
#line 95


#line 96
# Call the hwservicemanager and transfer references to it.
#line 96
allow netd hwservicemanager:binder { call transfer };
#line 96
# Allow hwservicemanager to send out callbacks
#line 96
allow hwservicemanager netd:binder { call transfer };
#line 96
# hwservicemanager performs getpidcon on clients.
#line 96
allow hwservicemanager netd:dir search;
#line 96
allow hwservicemanager netd:file { read open };
#line 96
allow hwservicemanager netd:process getattr;
#line 96
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 96
# all domains in domain.te.
#line 96


#line 97
allow netd hwservicemanager_prop:file { getattr open read ioctl lock map };
#line 97


###
### Neverallow rules
###
### netd should NEVER do any of this

# Block device access.
neverallow netd dev_type:blk_file { read write };

# ptrace any other app
neverallow netd { domain }:process ptrace;

# Write to /system.
neverallow netd system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data or system files on /data
neverallow netd { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# only system_server and dumpstate may find netd service
neverallow { domain -system_server -dumpstate -netd } netd_service:service_manager find;

# apps may not interact with netd over binder.
neverallow appdomain netd:binder call;
neverallow netd { appdomain -su }:binder call;

# persist.netd.stable_secret contains RFC 7217 secret key which should never be
# leaked to other processes. Make sure it never leaks.
neverallow { domain -netd -init } netd_stable_secret_prop:file { getattr open read ioctl lock map };

# We want to ensure that no other process ever tries tampering with persist.netd.stable_secret,
# the RFC 7217 secret key managed by netd. Doing so could compromise user privacy.
neverallow { domain -netd -init } netd_stable_secret_prop:property_service set;
#line 1 "system/sepolicy/public/netutils_wrapper.te"
type netutils_wrapper, domain;
type netutils_wrapper_exec, exec_type, file_type;

neverallow domain netutils_wrapper_exec:file execute_no_trans;
#line 1 "system/sepolicy/public/nfc.te"
# nfc subsystem
type nfc, domain;
#line 1 "system/sepolicy/public/otapreopt_chroot.te"
# otapreopt_chroot executable
type otapreopt_chroot, domain;
type otapreopt_chroot_exec, exec_type, file_type;

# Chroot preparation and execution.
# We need to create an unshared mount namespace, and then mount /data.
allow otapreopt_chroot postinstall_file:dir { search mounton };
allow otapreopt_chroot self:capability { sys_admin sys_chroot };

# This is required to mount /vendor.
allow otapreopt_chroot block_device:dir search;
allow otapreopt_chroot labeledfs:filesystem mount;
# Mounting /vendor can have this side-effect. Ignore denial.
dontaudit otapreopt_chroot kernel:process setsched;

# Allow otapreopt to use file descriptors from update-engine. It will
# close them immediately.
allow otapreopt_chroot postinstall:fd use;
allow otapreopt_chroot update_engine:fd use;
allow otapreopt_chroot update_engine:fifo_file write;
#line 1 "system/sepolicy/public/otapreopt_slot.te"
# otapreopt_slot
#
# This command set moves the artifact corresponding to the current slot
# from /data/ota to /data/dalvik-cache.

type otapreopt_slot, domain, mlstrustedsubject;
type otapreopt_slot_exec, exec_type, file_type;


# The otapreopt_slot renames the OTA dalvik-cache to the regular dalvik-cache, and cleans up
# the directory afterwards. For logging of aggregate size, we need getattr.
allow otapreopt_slot ota_data_file:dir { { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } rename reparent rmdir };
allow otapreopt_slot ota_data_file:{ file lnk_file } getattr;
# (du follows symlinks)
allow otapreopt_slot ota_data_file:lnk_file read;

# Delete old content of the dalvik-cache.
allow otapreopt_slot dalvikcache_data_file:dir { add_name getattr open read remove_name rmdir search write };
allow otapreopt_slot dalvikcache_data_file:file { getattr unlink };
allow otapreopt_slot dalvikcache_data_file:lnk_file { getattr read unlink };

# Allow cppreopts to execute itself using #!/system/bin/sh
allow otapreopt_slot shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Allow running the mv and rm/rmdir commands using otapreopt_slot  permissions.
# Needed so we can move artifacts into /data/dalvik-cache/dalvik-cache.
allow otapreopt_slot toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 1 "system/sepolicy/public/performanced.te"
# performanced
type performanced, domain, mlstrustedsubject;
type performanced_exec, exec_type, file_type;

# Needed to check for app permissions.

#line 6
# Call the servicemanager and transfer references to it.
#line 6
allow performanced servicemanager:binder { call transfer };
#line 6
# servicemanager performs getpidcon on clients.
#line 6
allow servicemanager performanced:dir search;
#line 6
allow servicemanager performanced:file { read open };
#line 6
allow servicemanager performanced:process getattr;
#line 6
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 6
# all domains in domain.te.
#line 6


#line 7
# Call the server domain and optionally transfer references to it.
#line 7
allow performanced system_server:binder { call transfer };
#line 7
# Allow the serverdomain to transfer references to the client on the reply.
#line 7
allow system_server performanced:binder transfer;
#line 7
# Receive and use open files from the server.
#line 7
allow performanced system_server:fd use;
#line 7

allow performanced permission_service:service_manager find;


#line 10
# Mark the server domain as a PDX server.
#line 10
typeattribute performanced pdx_performance_client_server_type;
#line 10
# Allow the init process to create the initial endpoint socket.
#line 10
allow init pdx_performance_client_endpoint_socket_type:unix_stream_socket { create bind };
#line 10
# Allow the server domain to use the endpoint socket and accept connections on it.
#line 10
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 10
# than we need (e.g. we don"t need "bind" or "connect").
#line 10
allow performanced pdx_performance_client_endpoint_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown listen accept };
#line 10
# Allow the server domain to apply security context label to the channel socket pair (allow process to use setsockcreatecon_raw()).
#line 10
allow performanced self:process setsockcreate;
#line 10
# Allow the server domain to create a client channel socket.
#line 10
allow performanced pdx_performance_client_channel_socket_type:unix_stream_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
#line 10
# Prevent other processes from claiming to be a server for the same service.
#line 10
neverallow {domain -performanced} pdx_performance_client_endpoint_socket_type:unix_stream_socket { listen accept };
#line 10


# TODO: use file caps to obtain sys_nice instead of setuid / setgid.
allow performanced self:capability { setuid setgid sys_nice };

# Access /proc to validate we're only affecting threads in the same thread group.
# Performanced also shields unbound kernel threads.  It scans every task in the
# root cpu set, but only affects the kernel threads.

#line 18
allow performanced { appdomain bufferhubd kernel surfaceflinger }:dir { open getattr read search ioctl lock };
#line 18
allow performanced { appdomain bufferhubd kernel surfaceflinger }:{ file lnk_file } { getattr open read ioctl lock map };
#line 18

dontaudit performanced domain:dir read;
allow performanced { appdomain bufferhubd kernel surfaceflinger }:process setsched;

# Access /dev/cpuset/cpuset.cpus

#line 23
allow performanced cgroup:dir { open getattr read search ioctl lock };
#line 23
allow performanced cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 23

#line 1 "system/sepolicy/public/perfprofd.te"
# perfprofd - perf profile collection daemon
type perfprofd, domain;
type perfprofd_exec, exec_type, file_type;


#line 5

#line 5
  typeattribute perfprofd coredomain;
#line 5
  typeattribute perfprofd mlstrustedsubject;
#line 5

#line 5
  # perfprofd needs to control CPU hot-plug in order to avoid kernel
#line 5
  # perfevents problems in cases where CPU goes on/off during measurement;
#line 5
  # this means read access to /sys/devices/system/cpu/possible
#line 5
  # and read/write access to /sys/devices/system/cpu/cpu*/online
#line 5
  allow perfprofd sysfs_devices_system_cpu:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 5

#line 5
  # perfprofd checks for the existence of and then invokes simpleperf;
#line 5
  # simpleperf retains perfprofd domain after exec
#line 5
  allow perfprofd system_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 5

#line 5
  # perfprofd reads a config file from /data/data/com.google.android.gms/files
#line 5
  allow perfprofd app_data_file:file { getattr open read ioctl lock map };
#line 5
  allow perfprofd app_data_file:dir search;
#line 5
  allow perfprofd self:capability { dac_override };
#line 5

#line 5
  # perfprofd opens a file for writing in /data/misc/perfprofd
#line 5
  allow perfprofd perfprofd_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 5
  allow perfprofd perfprofd_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
#line 5

#line 5
  # perfprofd uses the system log
#line 5
  
#line 5
allow perfprofd logcat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 5

#line 5

#line 5

#line 5
allow perfprofd logdr_socket:sock_file write;
#line 5
allow perfprofd logd:unix_stream_socket connectto;
#line 5

#line 5

#line 5
;
#line 5
  
#line 5

#line 5
allow perfprofd logdw_socket:sock_file write;
#line 5
allow perfprofd logd:unix_dgram_socket sendto;
#line 5

#line 5
allow perfprofd pmsg_device:chr_file { open append write lock map };
#line 5
;
#line 5

#line 5
  # perfprofd inspects /sys/power/wake_unlock
#line 5
  
#line 5
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 5
allow perfprofd sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 5
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 5
allow perfprofd self:capability2 block_suspend;
#line 5
;
#line 5

#line 5
  # simpleperf uses ioctl() to turn on kernel perf events measurements
#line 5
  allow perfprofd self:capability sys_admin;
#line 5

#line 5
  # simpleperf needs to examine /proc to collect task/thread info
#line 5
  
#line 5
allow perfprofd domain:dir { open getattr read search ioctl lock };
#line 5
allow perfprofd domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 5

#line 5

#line 5
  # simpleperf needs to access /proc/<pid>/exec
#line 5
  allow perfprofd self:capability { sys_resource sys_ptrace };
#line 5
  neverallow perfprofd domain:process ptrace;
#line 5

#line 5
  # simpleperf needs open/read any file that turns up in a profile
#line 5
  # to see whether it has a build ID
#line 5
  allow perfprofd exec_type:file { getattr open read ioctl lock map };
#line 5

#line 5
  # simpleperf examines debugfs on startup to collect tracepoint event types
#line 5
  allow perfprofd debugfs_tracing:file { getattr open read ioctl lock map };
#line 5

#line 5
  # simpleperf is going to execute "sleep"
#line 5
  allow perfprofd toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 5

#line 5
  # needed for simpleperf on some kernels
#line 5
  allow perfprofd self:capability ipc_lock;
#line 5

#line 59

#line 1 "system/sepolicy/public/platform_app.te"
###
### Apps signed with the platform key.
###

type platform_app, domain;
#line 1 "system/sepolicy/public/postinstall.te"
# Domain where the postinstall program runs during the update.
# Extend the permissions in this domain to allow this program to access other
# files needed by the specific device on your device's sepolicy directory.
type postinstall, domain;

# Allow postinstall to write to its stdout/stderr when redirected via pipes to
# update_engine.
allow postinstall update_engine_common:fd use;
allow postinstall update_engine_common:fifo_file { { getattr open read ioctl lock map } { open append write lock map } };

# Allow postinstall to read and execute directories and files in the same
# mounted location.
allow postinstall postinstall_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow postinstall postinstall_file:lnk_file { getattr open read ioctl lock map };
allow postinstall postinstall_file:dir { open getattr read search ioctl lock };

# Allow postinstall to execute the shell or other system executables.
allow postinstall shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow postinstall system_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow postinstall toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

#
# For OTA dexopt.
#

# Allow postinstall scripts to talk to the system server.

#line 27
# Call the servicemanager and transfer references to it.
#line 27
allow postinstall servicemanager:binder { call transfer };
#line 27
# servicemanager performs getpidcon on clients.
#line 27
allow servicemanager postinstall:dir search;
#line 27
allow servicemanager postinstall:file { read open };
#line 27
allow servicemanager postinstall:process getattr;
#line 27
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 27
# all domains in domain.te.
#line 27


#line 28
# Call the server domain and optionally transfer references to it.
#line 28
allow postinstall system_server:binder { call transfer };
#line 28
# Allow the serverdomain to transfer references to the client on the reply.
#line 28
allow system_server postinstall:binder transfer;
#line 28
# Receive and use open files from the server.
#line 28
allow postinstall system_server:fd use;
#line 28


# Need to talk to the otadexopt service.
allow postinstall otadexopt_service:service_manager find;

# No domain other than update_engine and recovery (via update_engine_sideload)
# should transition to postinstall, as it is only meant to run during the
# update.
neverallow { domain -update_engine -recovery } postinstall:process { transition dyntransition };
#line 1 "system/sepolicy/public/postinstall_dexopt.te"
# Domain for the otapreopt executable, running under postinstall_dexopt
#
# Note: otapreopt is a driver for dex2oat, and reuses parts of installd. As such,
# this is derived and adapted from installd.te.

type postinstall_dexopt, domain;

allow postinstall_dexopt self:capability { chown dac_override fowner setgid setuid };

allow postinstall_dexopt postinstall_file:filesystem getattr;
allow postinstall_dexopt postinstall_file:dir { getattr search };
allow postinstall_dexopt postinstall_file:lnk_file read;
allow postinstall_dexopt proc:file { getattr open read };
allow postinstall_dexopt tmpfs:file read;

# Note: /data/ota is created by init (see system/core/rootdir/init.rc) to avoid giving access
# here and having to relabel the directory.

# Read app data (APKs) as input to dex2oat.

#line 20
allow postinstall_dexopt apk_data_file:dir { open getattr read search ioctl lock };
#line 20
allow postinstall_dexopt apk_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 20

# Read vendor app data (APKs) as input to dex2oat.

#line 22
allow postinstall_dexopt vendor_app_file:dir { open getattr read search ioctl lock };
#line 22
allow postinstall_dexopt vendor_app_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 22

# Access to app oat directory.

#line 24
allow postinstall_dexopt dalvikcache_data_file:dir { open getattr read search ioctl lock };
#line 24
allow postinstall_dexopt dalvikcache_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 24


# Read profile data.
allow postinstall_dexopt user_profile_data_file:dir { getattr search };
allow postinstall_dexopt user_profile_data_file:file { getattr open read ioctl lock map };

# Write to /data/ota(/*). Create symlinks in /data/ota(/*)
allow postinstall_dexopt ota_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow postinstall_dexopt ota_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow postinstall_dexopt ota_data_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Need to write .b files, which are dalvikcache_data_file, not ota_data_file.
# TODO: See whether we can apply ota_data_file?
allow postinstall_dexopt dalvikcache_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow postinstall_dexopt dalvikcache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Allow labeling of files under /data/app/com.example/oat/
# TODO: Restrict to .b suffix?
allow postinstall_dexopt dalvikcache_data_file:dir relabelto;
allow postinstall_dexopt dalvikcache_data_file:file { relabelto link };

# Check validity of SELinux context before use.

#line 46

#line 46
allow postinstall_dexopt selinuxfs:dir { open getattr read search ioctl lock };
#line 46
allow postinstall_dexopt selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 46

#line 46
allow postinstall_dexopt selinuxfs:file { open append write lock map };
#line 46
allow postinstall_dexopt kernel:security check_context;
#line 46


#line 47

#line 47
allow postinstall_dexopt selinuxfs:dir { open getattr read search ioctl lock };
#line 47
allow postinstall_dexopt selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 47

#line 47
allow postinstall_dexopt selinuxfs:file { open append write lock map };
#line 47
allow postinstall_dexopt kernel:security compute_av;
#line 47
allow postinstall_dexopt self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 47



# Postinstall wants to know about our child.
allow postinstall_dexopt postinstall:process sigchld;

# Allow otapreopt to use file descriptors from otapreopt_chroot.
# TODO: Probably we can actually close file descriptors...
allow postinstall_dexopt otapreopt_chroot:fd use;

allow postinstall_dexopt cpuctl_device:dir search;
#line 1 "system/sepolicy/public/ppp.te"
# Point to Point Protocol daemon
type ppp, domain;
type ppp_device, dev_type;
type ppp_exec, exec_type, file_type;


#line 6
typeattribute ppp netdomain;
#line 6



#line 8
allow ppp proc_net:dir { open getattr read search ioctl lock };
#line 8
allow ppp proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 8


allow ppp mtp:socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };

# ioctls needed for VPN.
allowxperm ppp self:udp_socket ioctl 
#line 13
{
#line 13
# qualcomm rmnet ioctls
#line 13
0x00006900 0x00006902
#line 13
# socket ioctls
#line 13
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 13
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 13
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 13
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 13
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 13
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 13
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 13
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 13
0x00008991 0x00008992 0x00008993 0x00008994
#line 13
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 13
# device and protocol specific ioctls
#line 13
0x000089f0-0x000089ff
#line 13
0x000089e0-0x000089ef
#line 13
# Wireless extension ioctls
#line 13
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 13
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 13
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 13
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 13
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 13
0x00008b34 0x00008b35 0x00008b36
#line 13
# Dev private ioctl i.e. hardware specific ioctls
#line 13
0x00008be0-0x00008bff
#line 13
};
allowxperm ppp mtp:socket ioctl {
#line 14
0x7436 0x7437 0x7438 0x7439
#line 14
0x743a 0x743b 0x743c 0x743d
#line 14
0x743e 0x743f 0x7440 0x7441
#line 14
0x7446 0x7447 0x744b 0x744c
#line 14
0x744d 0x744e 0x744f
#line 14
0x7450 0x7451 0x7452 0x7453
#line 14
0x7454 0x7455 0x7456 0x7457
#line 14
0x7458 0x7459 0x745a 0x7480
#line 14
0x7481 0x7482 0x7483 0x7484
#line 14
0x7485 0x7486 0x7487 0x7488
#line 14
};

allow ppp mtp:unix_dgram_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow ppp ppp_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow ppp self:capability net_admin;
allow ppp system_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow ppp vendor_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow ppp vpn_data_file:dir { open search write add_name remove_name lock };
allow ppp vpn_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow ppp mtp:fd use;
#line 1 "system/sepolicy/public/preopt2cachename.te"
# preopt2cachename executable
#
# This executable translates names from the preopted versions the build system
# creates to the names the runtime expects in the data directory.
type preopt2cachename, domain;
type preopt2cachename_exec, exec_type, file_type;

# Allow write to stdout.
allow preopt2cachename cppreopts:fd use;
allow preopt2cachename cppreopts:fifo_file { getattr read write };

# Allow write to logcat.
allow preopt2cachename proc_net:file { getattr open read ioctl lock map };
#line 1 "system/sepolicy/public/priv_app.te"
###
### A domain for further sandboxing privileged apps.
###

type priv_app, domain;
#line 1 "system/sepolicy/public/profman.te"
# profman
type profman, domain;
type profman_exec, exec_type, file_type;

allow profman user_profile_data_file:file { getattr read write lock };

# Dumping profile info opens the application APK file for pretty printing.
allow profman asec_apk_file:file { read };
allow profman apk_data_file:file { read };
allow profman oemfs:file { read };
# Reading an APK opens a ZipArchive, which unpack to tmpfs.
allow profman tmpfs:file { read };
allow profman profman_dump_data_file:file { write };

allow profman installd:fd use;

# Allow profman to analyze profiles for the secondary dex files. These
# are application dex files reported back to the framework when using
# BaseDexClassLoader.
allow profman app_data_file:file { getattr read write lock };

###
### neverallow rules
###

neverallow profman app_data_file:{ file lnk_file sock_file fifo_file } open;
#line 1 "system/sepolicy/public/property.te"
type audio_prop, property_type, core_property_type;
type boottime_prop, property_type;
type bluetooth_prop, property_type;
type config_prop, property_type, core_property_type;
type cppreopt_prop, property_type, core_property_type;
type ctl_bootanim_prop, property_type;
type ctl_bugreport_prop, property_type;
type ctl_console_prop, property_type;
type ctl_default_prop, property_type;
type ctl_dumpstate_prop, property_type;
type ctl_fuse_prop, property_type;
type ctl_mdnsd_prop, property_type;
type ctl_rildaemon_prop, property_type;
type dalvik_prop, property_type, core_property_type;
type debuggerd_prop, property_type, core_property_type;
type debug_prop, property_type, core_property_type;
type default_prop, property_type, core_property_type;
type device_logging_prop, property_type;
type dhcp_prop, property_type, core_property_type;
type dumpstate_options_prop, property_type;
type dumpstate_prop, property_type, core_property_type;
type ffs_prop, property_type, core_property_type;
type fingerprint_prop, property_type, core_property_type;
type firstboot_prop, property_type;
type hwservicemanager_prop, property_type;
type logd_prop, property_type, core_property_type;
type logpersistd_logging_prop, property_type;
type log_prop, property_type, log_property_type;
type log_tag_prop, property_type, log_property_type;
type mmc_prop, property_type;
type net_dns_prop, property_type;
type net_radio_prop, property_type, core_property_type;
type netd_stable_secret_prop, property_type;
type nfc_prop, property_type, core_property_type;
type overlay_prop, property_type;
type pan_result_prop, property_type, core_property_type;
type persist_debug_prop, property_type, core_property_type;
type persistent_properties_ready_prop, property_type;
type powerctl_prop, property_type, core_property_type;
type radio_prop, property_type, core_property_type;
type restorecon_prop, property_type, core_property_type;
type safemode_prop, property_type;
type serialno_prop, property_type;
type shell_prop, property_type, core_property_type;
type system_prop, property_type, core_property_type;
type system_radio_prop, property_type, core_property_type;
type vold_prop, property_type, core_property_type;
type wifi_log_prop, property_type, log_property_type;
type wifi_prop, property_type;

allow property_type tmpfs:filesystem associate;

###
### Neverallow rules
###

# core_property_type should not be used for new properties or
# device specific properties. Properties with this attribute
# are readable to everyone, which is overly broad and should
# be avoided.
# New properties should have appropriate read / write access
# control rules written.

neverallow * {
  core_property_type
  -audio_prop
  -config_prop
  -cppreopt_prop
  -dalvik_prop
  -debuggerd_prop
  -debug_prop
  -default_prop
  -dhcp_prop
  -dumpstate_prop
  -ffs_prop
  -fingerprint_prop
  -logd_prop
  -net_radio_prop
  -nfc_prop
  -pan_result_prop
  -persist_debug_prop
  -powerctl_prop
  -radio_prop
  -restorecon_prop
  -shell_prop
  -system_prop
  -system_radio_prop
  -vold_prop
}:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
#line 1 "system/sepolicy/public/racoon.te"
# IKE key management daemon
type racoon, domain;
type racoon_exec, exec_type, file_type;

typeattribute racoon mlstrustedsubject;


#line 7
typeattribute racoon netdomain;
#line 7

allowxperm racoon self:udp_socket ioctl { 0x00008914 0x00008916 0x0000891c };


#line 10
# Call the servicemanager and transfer references to it.
#line 10
allow racoon servicemanager:binder { call transfer };
#line 10
# servicemanager performs getpidcon on clients.
#line 10
allow servicemanager racoon:dir search;
#line 10
allow servicemanager racoon:file { read open };
#line 10
allow servicemanager racoon:process getattr;
#line 10
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 10
# all domains in domain.te.
#line 10


allow racoon tun_device:chr_file { getattr open read ioctl lock map };
allow racoon cgroup:dir { add_name create };
allow racoon kernel:system module_request;

allow racoon self:key_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow racoon self:tun_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow racoon self:capability { net_admin net_bind_service net_raw };

# XXX: should we give ip-up-vpn its own label (currently racoon domain)
allow racoon system_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow racoon vendor_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow racoon vpn_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow racoon vpn_data_file:dir { open search write add_name remove_name lock };


#line 26
  allow keystore racoon:dir search;
#line 26
  allow keystore racoon:file { read open };
#line 26
  allow keystore racoon:process getattr;
#line 26
  allow racoon keystore_service:service_manager find;
#line 26
  
#line 26
# Call the server domain and optionally transfer references to it.
#line 26
allow racoon keystore:binder { call transfer };
#line 26
# Allow the serverdomain to transfer references to the client on the reply.
#line 26
allow keystore racoon:binder transfer;
#line 26
# Receive and use open files from the server.
#line 26
allow racoon keystore:fd use;
#line 26

#line 26


# Racoon (VPN) has a restricted set of permissions from the default.
allow racoon keystore:keystore_key {
	get
	sign
	verify
};
#line 1 "system/sepolicy/public/radio.te"
# phone subsystem
type radio, domain, mlstrustedsubject;


#line 4
typeattribute radio netdomain;
#line 4


#line 5
typeattribute radio bluetoothdomain;
#line 5


#line 6
typeattribute radio binderservicedomain;
#line 6


# Talks to rild via the rild socket only for devices without full treble

#line 9

#line 9

#line 9
allow radio rild_socket:sock_file write;
#line 9
allow radio rild:unix_stream_socket connectto;
#line 9

#line 9


# Data file accesses.
allow radio radio_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow radio radio_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

allow radio alarm_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

allow radio net_data_file:dir search;
allow radio net_data_file:file { getattr open read ioctl lock map };

# Property service

#line 21

#line 21
allow radio property_socket:sock_file write;
#line 21
allow radio init:unix_stream_socket connectto;
#line 21

#line 21
allow radio radio_prop:property_service set;
#line 21

#line 21
allow radio radio_prop:file { getattr open read ioctl lock map };
#line 21

#line 21


#line 22

#line 22
allow radio property_socket:sock_file write;
#line 22
allow radio init:unix_stream_socket connectto;
#line 22

#line 22
allow radio net_radio_prop:property_service set;
#line 22

#line 22
allow radio net_radio_prop:file { getattr open read ioctl lock map };
#line 22

#line 22


# ctl interface

#line 25

#line 25
allow radio property_socket:sock_file write;
#line 25
allow radio init:unix_stream_socket connectto;
#line 25

#line 25
allow radio ctl_rildaemon_prop:property_service set;
#line 25

#line 25
allow radio ctl_rildaemon_prop:file { getattr open read ioctl lock map };
#line 25

#line 25



#line 27
  allow radio radio_service:service_manager { add find };
#line 27
  neverallow { domain -radio } radio_service:service_manager add;
#line 27

allow radio audioserver_service:service_manager find;
allow radio cameraserver_service:service_manager find;
allow radio drmserver_service:service_manager find;
allow radio mediaserver_service:service_manager find;
allow radio nfc_service:service_manager find;
allow radio surfaceflinger_service:service_manager find;
allow radio app_api_service:service_manager find;
allow radio system_api_service:service_manager find;

# Perform HwBinder IPC.

#line 38
# Call the hwservicemanager and transfer references to it.
#line 38
allow radio hwservicemanager:binder { call transfer };
#line 38
# Allow hwservicemanager to send out callbacks
#line 38
allow hwservicemanager radio:binder { call transfer };
#line 38
# hwservicemanager performs getpidcon on clients.
#line 38
allow hwservicemanager radio:dir search;
#line 38
allow hwservicemanager radio:file { read open };
#line 38
allow hwservicemanager radio:process getattr;
#line 38
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 38
# all domains in domain.te.
#line 38


#line 39
typeattribute radio halclientdomain;
#line 39
typeattribute radio hal_telephony_client;
#line 39

#line 39
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 39
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 39
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 39

#line 39
typeattribute radio hal_telephony;
#line 39
# Find passthrough HAL implementations
#line 39
allow hal_telephony system_file:dir { open getattr read search ioctl lock };
#line 39
allow hal_telephony vendor_file:dir { open getattr read search ioctl lock };
#line 39
allow hal_telephony vendor_file:file { read open getattr execute map };
#line 39

#line 39

#line 1 "system/sepolicy/public/recovery.te"
# recovery console (used in recovery init.rc for /sbin/recovery)

# Declare the domain unconditionally so we can always reference it
# in neverallow rules.
type recovery, domain;

# But the allow rules are only included in the recovery policy.
# Otherwise recovery is only allowed the domain rules.
#line 134


###
### neverallow rules
###

# Recovery should never touch /data.
#
# In particular, if /data is encrypted, it is not accessible
# to recovery anyway.
#
# For now, we only enforce write/execute restrictions, as domain.te
# contains a number of read-only rules that apply to all
# domains, including recovery.
#
# TODO: tighten this up further.
neverallow recovery {
   data_file_type
   -cache_file
   -cache_recovery_file
}:file { { append create link unlink relabelfrom rename setattr write } { execute execute_no_trans } };
neverallow recovery {
   data_file_type
   -cache_file
   -cache_recovery_file
}:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };
#line 1 "system/sepolicy/public/recovery_persist.te"
# android recovery persistent log manager
type recovery_persist, domain;
type recovery_persist_exec, exec_type, file_type;

allow recovery_persist pstorefs:dir search;
allow recovery_persist pstorefs:file { getattr open read ioctl lock map };

allow recovery_persist recovery_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow recovery_persist recovery_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };

###
### Neverallow rules
###
### recovery_persist should NEVER do any of this

# Block device access.
neverallow recovery_persist dev_type:blk_file { read write };

# ptrace any other app
neverallow recovery_persist domain:process ptrace;

# Write to /system.
neverallow recovery_persist system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data
neverallow recovery_persist { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

#line 1 "system/sepolicy/public/recovery_refresh.te"
# android recovery refresh log manager
type recovery_refresh, domain;
type recovery_refresh_exec, exec_type, file_type;

allow recovery_refresh pstorefs:dir search;
allow recovery_refresh pstorefs:file { getattr open read ioctl lock map };
# NB: domain inherits write_logd which hands us write to pmsg_device

###
### Neverallow rules
###
### recovery_refresh should NEVER do any of this

# Block device access.
neverallow recovery_refresh dev_type:blk_file { read write };

# ptrace any other app
neverallow recovery_refresh domain:process ptrace;

# Write to /system.
neverallow recovery_refresh system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Write to files in /data/data or system files on /data
neverallow recovery_refresh { app_data_file system_data_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
#line 1 "system/sepolicy/public/rild.te"
# rild - radio interface layer daemon
type rild, domain;

#line 3
typeattribute rild halserverdomain;
#line 3
typeattribute rild hal_telephony_server;
#line 3
typeattribute rild hal_telephony;
#line 3



#line 5
typeattribute rild netdomain;
#line 5

allowxperm rild self:udp_socket ioctl 
#line 6
{
#line 6
# qualcomm rmnet ioctls
#line 6
0x00006900 0x00006902
#line 6
# socket ioctls
#line 6
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 6
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 6
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 6
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 6
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 6
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 6
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 6
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 6
0x00008991 0x00008992 0x00008993 0x00008994
#line 6
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 6
# device and protocol specific ioctls
#line 6
0x000089f0-0x000089ff
#line 6
0x000089e0-0x000089ef
#line 6
# Wireless extension ioctls
#line 6
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 6
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 6
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 6
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 6
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 6
0x00008b34 0x00008b35 0x00008b36
#line 6
# Dev private ioctl i.e. hardware specific ioctls
#line 6
0x00008be0-0x00008bff
#line 6
};

allow rild self:netlink_route_socket nlmsg_write;
allow rild kernel:system module_request;
allow rild self:capability { setpcap setgid setuid net_admin net_raw };
allow rild alarm_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow rild cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow rild cgroup:{ file lnk_file } { getattr open read ioctl lock map };
allow rild radio_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow rild radio_device:blk_file { getattr open read ioctl lock map };
allow rild mtd_device:dir search;
allow rild efs_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow rild efs_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow rild shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow rild bluetooth_efs_file:file { getattr open read ioctl lock map };
allow rild bluetooth_efs_file:dir { open getattr read search ioctl lock };
allow rild sdcard_type:dir { open getattr read search ioctl lock };

# property service

#line 25

#line 25
allow rild property_socket:sock_file write;
#line 25
allow rild init:unix_stream_socket connectto;
#line 25

#line 25
allow rild radio_prop:property_service set;
#line 25

#line 25
allow rild radio_prop:file { getattr open read ioctl lock map };
#line 25

#line 25


allow rild tty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Allow rild to create and use netlink sockets.
allow rild self:netlink_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow rild self:netlink_generic_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow rild self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Access to wake locks

#line 35
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 35
allow rild sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 35
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 35
allow rild self:capability2 block_suspend;
#line 35



#line 37
allow rild proc:dir { open getattr read search ioctl lock };
#line 37
allow rild proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 37


#line 38
allow rild proc_net:dir { open getattr read search ioctl lock };
#line 38
allow rild proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 38


#line 39
allow rild sysfs_type:dir { open getattr read search ioctl lock };
#line 39
allow rild sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 39


#line 40
allow rild system_file:dir { open getattr read search ioctl lock };
#line 40
allow rild system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 40


# granting the ioctl permission for rild should be device specific
allow rild self:socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

#line 1 "system/sepolicy/public/runas.te"
type runas, domain, mlstrustedsubject;
type runas_exec, exec_type, file_type;

allow runas adbd:fd use;
allow runas adbd:process sigchld;
allow runas adbd:unix_stream_socket { read write };
allow runas shell:fd use;
allow runas shell:fifo_file { read write };
allow runas shell:unix_stream_socket { read write };
allow runas devpts:chr_file { read write ioctl };
allow runas shell_data_file:file { read write };

# run-as reads package information.
allow runas system_data_file:file { getattr open read ioctl lock map };

# run-as checks and changes to the app data dir.
dontaudit runas self:capability dac_override;
allow runas app_data_file:dir { getattr search };

# run-as switches to the app UID/GID.
allow runas self:capability { setuid setgid };

# run-as switches to the app security context.

#line 24

#line 24
allow runas selinuxfs:dir { open getattr read search ioctl lock };
#line 24
allow runas selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 24

#line 24
allow runas selinuxfs:file { open append write lock map };
#line 24
allow runas kernel:security check_context;
#line 24
 # validate context
allow runas self:process setcurrent;
allow runas { appdomain -system_app }:process dyntransition; # setcon

# runas/libselinux needs access to seapp_contexts_file to
# determine which domain to transition to.
allow runas seapp_contexts_file:file { getattr open read ioctl lock map };

###
### neverallow rules
###

# run-as cannot have capabilities other than CAP_SETUID and CAP_SETGID
neverallow runas self:capability ~{ setuid setgid };
neverallow runas self:capability2 *;
#line 1 "system/sepolicy/public/sdcardd.te"
type sdcardd, domain;
type sdcardd_exec, exec_type, file_type;

allow sdcardd cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow sdcardd fuse_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow sdcardd rootfs:dir mounton;  # TODO: deprecated in M
allow sdcardd sdcardfs:filesystem remount;
allow sdcardd tmpfs:dir { open getattr read search ioctl lock };
allow sdcardd mnt_media_rw_file:dir { open getattr read search ioctl lock };
allow sdcardd storage_file:dir search;
allow sdcardd storage_stub_file:dir { search mounton };
allow sdcardd sdcard_type:filesystem { mount unmount };
allow sdcardd self:capability { setuid setgid dac_override sys_admin sys_resource };

allow sdcardd sdcard_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow sdcardd sdcard_type:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

allow sdcardd media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow sdcardd media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Read /data/system/packages.list.
allow sdcardd system_data_file:file { getattr open read ioctl lock map };

# Read /data/.layout_version
allow sdcardd install_data_file:file { getattr open read ioctl lock map };

# Allow stdin/out back to vold
allow sdcardd vold:fd use;
allow sdcardd vold:fifo_file { read write getattr };

# Allow running on top of expanded storage
allow sdcardd mnt_expand_file:dir search;

# access /proc/filesystems
allow sdcardd proc:file { getattr open read ioctl lock map };

###
### neverallow rules
###

# The sdcard daemon should no longer be started from init
neverallow init sdcardd_exec:file execute;
neverallow init sdcardd:process { transition dyntransition };
#line 1 "system/sepolicy/public/service.te"
type audioserver_service,       service_manager_type;
type batteryproperties_service, app_api_service, ephemeral_app_api_service, service_manager_type;
type bluetooth_service,         service_manager_type;
type cameraserver_service,      service_manager_type;
type default_android_service,   service_manager_type;
type drmserver_service,         service_manager_type;
type dumpstate_service,         service_manager_type;
type fingerprintd_service,      service_manager_type;
type hal_fingerprint_service,   service_manager_type;
type gatekeeper_service,        app_api_service, service_manager_type;
type gpu_service,               service_manager_type;
type inputflinger_service,      service_manager_type;
type incident_service,          service_manager_type;
type installd_service,          service_manager_type;
type keystore_service,          service_manager_type;
type mediaserver_service,       service_manager_type;
type mediametrics_service,      service_manager_type;
type mediaextractor_service,    service_manager_type;
type mediacodec_service,        service_manager_type;
type mediadrmserver_service,    service_manager_type;
type netd_service,              service_manager_type;
type nfc_service,               service_manager_type;
type radio_service,             service_manager_type;
type storaged_service,          service_manager_type;
type surfaceflinger_service,    service_manager_type;
type system_app_service,        service_manager_type;
type thermal_service,           service_manager_type;
type update_engine_service,     service_manager_type;
type virtual_touchpad_service,  service_manager_type;
type vr_hwc_service,            service_manager_type;

# system_server_services broken down
type accessibility_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type account_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type activity_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type alarm_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type appops_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type appwidget_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type assetatlas_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type audio_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type autofill_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type backup_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type batterystats_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type battery_service, system_server_service, service_manager_type;
type bluetooth_manager_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type broadcastradio_service, system_server_service, service_manager_type;
type cameraproxy_service, system_server_service, service_manager_type;
type clipboard_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type contexthub_service, app_api_service,  system_server_service, service_manager_type;
type IProxyService_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type commontime_management_service, system_server_service, service_manager_type;
type companion_device_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type connectivity_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type connmetrics_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type consumer_ir_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type content_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type country_detector_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
# Note: The coverage_service should only be enabled for userdebug / eng builds that were compiled
# with EMMA_INSTRUMENT=true. We should consider locking this down in the future.
type coverage_service, system_server_service, service_manager_type;
type cpuinfo_service, system_api_service, system_server_service, service_manager_type;
type dbinfo_service, system_api_service, system_server_service, service_manager_type;
type device_policy_service, app_api_service, system_server_service, service_manager_type;
type deviceidle_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type device_identifiers_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type devicestoragemonitor_service, system_server_service, service_manager_type;
type diskstats_service, system_api_service, system_server_service, service_manager_type;
type display_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type font_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type netd_listener_service, system_server_service, service_manager_type;
type DockObserver_service, system_server_service, service_manager_type;
type dreams_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type dropbox_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type ethernet_service, app_api_service, system_server_service, service_manager_type;
type fingerprint_service, app_api_service, system_server_service, service_manager_type;
type gfxinfo_service, system_api_service, system_server_service, service_manager_type;
type graphicsstats_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type hardware_service, system_server_service, service_manager_type;
type hardware_properties_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type hdmi_control_service, system_api_service, system_server_service, service_manager_type;
type input_method_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type input_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type imms_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type ipsec_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type jobscheduler_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type launcherapps_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type location_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type lock_settings_service, system_api_service, system_server_service, service_manager_type;
type media_projection_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type media_router_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type media_session_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type meminfo_service, system_api_service, system_server_service, service_manager_type;
type midi_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type mount_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type netpolicy_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type netstats_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type network_management_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type network_score_service, system_api_service, system_server_service, service_manager_type;
type network_time_update_service, system_server_service, service_manager_type;
type notification_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type oem_lock_service, system_api_service, system_server_service, service_manager_type;
type otadexopt_service, system_server_service, service_manager_type;
type overlay_service, system_api_service, system_server_service, service_manager_type;
type package_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type package_native_service, system_server_service, service_manager_type;
type permission_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type persistent_data_block_service, system_api_service, system_server_service, service_manager_type;
type pinner_service, system_server_service, service_manager_type;
type power_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type print_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type processinfo_service, system_server_service, service_manager_type;
type procstats_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type recovery_service, system_server_service, service_manager_type;
type registry_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type restrictions_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type rttmanager_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type samplingprofiler_service, system_server_service, service_manager_type;
type scheduling_policy_service, system_server_service, service_manager_type;
type search_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type sec_key_att_app_id_provider_service, app_api_service, system_server_service, service_manager_type;
type sensorservice_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type serial_service, system_api_service, system_server_service, service_manager_type;
type servicediscovery_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type settings_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type shortcut_service, app_api_service, system_server_service, service_manager_type;
type statusbar_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type storagestats_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type task_service, system_server_service, service_manager_type;
type textclassification_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type textservices_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type telecom_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type timezone_service, system_server_service, service_manager_type;
type trust_service, app_api_service, system_server_service, service_manager_type;
type tv_input_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type uimode_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type updatelock_service, system_api_service, system_server_service, service_manager_type;
type usagestats_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type usb_service, app_api_service, system_server_service, service_manager_type;
type user_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type vibrator_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type voiceinteraction_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type vr_manager_service, system_server_service, service_manager_type;
type wallpaper_service, app_api_service, system_server_service, service_manager_type;
type webviewupdate_service, app_api_service, ephemeral_app_api_service, system_server_service, service_manager_type;
type wifip2p_service, app_api_service, system_server_service, service_manager_type;
type wifiscanner_service, system_api_service, system_server_service, service_manager_type;
type wifi_service, app_api_service, system_server_service, service_manager_type;
type wificond_service, service_manager_type;
type wifiaware_service, app_api_service, system_server_service, service_manager_type;
type window_service, system_api_service, system_server_service, service_manager_type;
#line 1 "system/sepolicy/public/servicemanager.te"
# servicemanager - the Binder context manager
type servicemanager, domain, mlstrustedsubject;
type servicemanager_exec, exec_type, file_type;

# Note that we do not use the binder_* macros here.
# servicemanager is unique in that it only provides
# name service (aka context manager) for Binder.
# As such, it only ever receives and transfers other references
# created by other domains.  It never passes its own references
# or initiates a Binder IPC.
allow servicemanager self:binder set_context_mgr;
allow servicemanager {
  domain
  -init
  -hwservicemanager
  -vndservicemanager
}:binder transfer;

allow servicemanager service_contexts_file:file { getattr open read ioctl lock map };
# nonplat_service_contexts only accessible on non full-treble devices
allow servicemanager nonplat_service_contexts_file:file { getattr open read ioctl lock map };

# Check SELinux permissions.

#line 24

#line 24
allow servicemanager selinuxfs:dir { open getattr read search ioctl lock };
#line 24
allow servicemanager selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 24

#line 24
allow servicemanager selinuxfs:file { open append write lock map };
#line 24
allow servicemanager kernel:security compute_av;
#line 24
allow servicemanager self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 24

#line 1 "system/sepolicy/public/sgdisk.te"
# sgdisk called from vold
type sgdisk, domain;
type sgdisk_exec, exec_type, file_type;

# Allowed to read/write low-level partition tables
allow sgdisk block_device:dir search;
allow sgdisk vold_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Inherit and use pty created by android_fork_execvp()
allow sgdisk devpts:chr_file { read write ioctl getattr };

# Allow stdin/out back to vold
allow sgdisk vold:fd use;
allow sgdisk vold:fifo_file { read write getattr };

# Used to probe kernel to reload partition tables
allow sgdisk self:capability sys_admin;

# Only allow entry from vold
neverallow { domain -vold } sgdisk:process transition;
neverallow * sgdisk:process dyntransition;
neverallow sgdisk { file_type fs_type -sgdisk_exec }:file entrypoint;
#line 1 "system/sepolicy/public/shared_relro.te"
# Process which creates/updates shared RELRO files to be used by other apps.
type shared_relro, domain;

# Grant write access to the shared relro files/directory.
allow shared_relro shared_relro_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow shared_relro shared_relro_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Needs to contact the "webviewupdate" and "activity" services
allow shared_relro webviewupdate_service:service_manager find;
#line 1 "system/sepolicy/public/shell.te"
# Domain for shell processes spawned by ADB or console service.
type shell, domain, mlstrustedsubject;
type shell_exec, exec_type, file_type;

# Create and use network sockets.

#line 6
typeattribute shell netdomain;
#line 6


# logcat

#line 9
allow shell logcat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 9

#line 9

#line 9

#line 9
allow shell logdr_socket:sock_file write;
#line 9
allow shell logd:unix_stream_socket connectto;
#line 9

#line 9

#line 9


#line 10
# Group AID_LOG checked by filesystem & logd
#line 10
# to permit control commands
#line 10

#line 10

#line 10

#line 10
allow shell logd_socket:sock_file write;
#line 10
allow shell logd:unix_stream_socket connectto;
#line 10

#line 10

#line 10

# logcat -L (directly, or via dumpstate)
allow shell pstorefs:dir search;
allow shell pstorefs:file { getattr open read ioctl lock map };

# Root fs.
allow shell rootfs:dir { open getattr read search ioctl lock };

# read files in /data/anr
allow shell anr_data_file:dir { open getattr read search ioctl lock };
allow shell anr_data_file:file { getattr open read ioctl lock map };

# Access /data/local/tmp.
allow shell shell_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow shell shell_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow shell shell_data_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow shell shell_data_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access /data/misc/profman.
allow shell profman_dump_data_file:dir { search getattr write remove_name };
allow shell profman_dump_data_file:file { getattr unlink };

# Read/execute files in /data/nativetest

#line 33
  allow shell nativetest_data_file:dir { open getattr read search ioctl lock };
#line 33
  allow shell nativetest_data_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 36


# adb bugreport

#line 39

#line 39

#line 39
allow shell dumpstate_socket:sock_file write;
#line 39
allow shell dumpstate:unix_stream_socket connectto;
#line 39

#line 39


allow shell devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow shell tty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow shell console_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow shell input_device:dir { open getattr read search ioctl lock };
allow shell input_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

#line 46
allow shell system_file:dir { open getattr read search ioctl lock };
#line 46
allow shell system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 46

allow shell system_file:file { getattr execute execute_no_trans map };
allow shell toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow shell tzdatacheck_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow shell shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow shell zygote_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };


#line 53
allow shell apk_data_file:dir { open getattr read search ioctl lock };
#line 53
allow shell apk_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 53


# Set properties.

#line 56

#line 56
allow shell property_socket:sock_file write;
#line 56
allow shell init:unix_stream_socket connectto;
#line 56

#line 56
allow shell shell_prop:property_service set;
#line 56

#line 56
allow shell shell_prop:file { getattr open read ioctl lock map };
#line 56

#line 56


#line 57

#line 57
allow shell property_socket:sock_file write;
#line 57
allow shell init:unix_stream_socket connectto;
#line 57

#line 57
allow shell ctl_bugreport_prop:property_service set;
#line 57

#line 57
allow shell ctl_bugreport_prop:file { getattr open read ioctl lock map };
#line 57

#line 57


#line 58

#line 58
allow shell property_socket:sock_file write;
#line 58
allow shell init:unix_stream_socket connectto;
#line 58

#line 58
allow shell ctl_dumpstate_prop:property_service set;
#line 58

#line 58
allow shell ctl_dumpstate_prop:file { getattr open read ioctl lock map };
#line 58

#line 58


#line 59

#line 59
allow shell property_socket:sock_file write;
#line 59
allow shell init:unix_stream_socket connectto;
#line 59

#line 59
allow shell dumpstate_prop:property_service set;
#line 59

#line 59
allow shell dumpstate_prop:file { getattr open read ioctl lock map };
#line 59

#line 59


#line 60

#line 60
allow shell property_socket:sock_file write;
#line 60
allow shell init:unix_stream_socket connectto;
#line 60

#line 60
allow shell debug_prop:property_service set;
#line 60

#line 60
allow shell debug_prop:file { getattr open read ioctl lock map };
#line 60

#line 60


#line 61

#line 61
allow shell property_socket:sock_file write;
#line 61
allow shell init:unix_stream_socket connectto;
#line 61

#line 61
allow shell powerctl_prop:property_service set;
#line 61

#line 61
allow shell powerctl_prop:file { getattr open read ioctl lock map };
#line 61

#line 61


#line 62

#line 62
allow shell property_socket:sock_file write;
#line 62
allow shell init:unix_stream_socket connectto;
#line 62

#line 62
allow shell log_tag_prop:property_service set;
#line 62

#line 62
allow shell log_tag_prop:file { getattr open read ioctl lock map };
#line 62

#line 62


#line 63

#line 63
allow shell property_socket:sock_file write;
#line 63
allow shell init:unix_stream_socket connectto;
#line 63

#line 63
allow shell wifi_log_prop:property_service set;
#line 63

#line 63
allow shell wifi_log_prop:file { getattr open read ioctl lock map };
#line 63

#line 63

# adjust is_loggable properties

#line 65

#line 65
allow shell property_socket:sock_file write;
#line 65
allow shell init:unix_stream_socket connectto;
#line 65

#line 65
allow shell log_prop:property_service set;
#line 65

#line 65
allow shell log_prop:file { getattr open read ioctl lock map };
#line 65

#line 65

# logpersist script

#line 67

#line 67
allow shell property_socket:sock_file write;
#line 67
allow shell init:unix_stream_socket connectto;
#line 67

#line 67
allow shell logpersistd_logging_prop:property_service set;
#line 67

#line 67
allow shell logpersistd_logging_prop:file { getattr open read ioctl lock map };
#line 67

#line 67



#line 69
  # "systrace --boot" support - allow boottrace service to run
#line 69
  allow shell boottrace_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
#line 69
  allow shell boottrace_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 69
  
#line 69

#line 69
allow shell property_socket:sock_file write;
#line 69
allow shell init:unix_stream_socket connectto;
#line 69

#line 69
allow shell persist_debug_prop:property_service set;
#line 69

#line 69
allow shell persist_debug_prop:file { getattr open read ioctl lock map };
#line 69

#line 69

#line 74


# Read device's serial number from system properties

#line 77
allow shell serialno_prop:file { getattr open read ioctl lock map };
#line 77


# Read state of logging-related properties

#line 80
allow shell device_logging_prop:file { getattr open read ioctl lock map };
#line 80


# allow shell access to services
allow shell servicemanager:service_manager list;
# don't allow shell to access GateKeeper service
# TODO: why is this so broad? Tightening candidate? It needs at list:
# - dumpstate_service (so it can receive dumpstate progress updates)
allow shell { service_manager_type -gatekeeper_service -incident_service -installd_service -netd_service -virtual_touchpad_service -vr_hwc_service }:service_manager find;
allow shell dumpstate:binder call;

# allow shell to get information from hwservicemanager
# for instance, listing hardware services with lshal

#line 92
# Call the hwservicemanager and transfer references to it.
#line 92
allow shell hwservicemanager:binder { call transfer };
#line 92
# Allow hwservicemanager to send out callbacks
#line 92
allow hwservicemanager shell:binder { call transfer };
#line 92
# hwservicemanager performs getpidcon on clients.
#line 92
allow hwservicemanager shell:dir search;
#line 92
allow hwservicemanager shell:file { read open };
#line 92
allow hwservicemanager shell:process getattr;
#line 92
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 92
# all domains in domain.te.
#line 92

allow shell hwservicemanager:hwservice_manager list;

# allow shell to look through /proc/ for ps, top, netstat

#line 96
allow shell proc:dir { open getattr read search ioctl lock };
#line 96
allow shell proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 96


#line 97
allow shell proc_net:dir { open getattr read search ioctl lock };
#line 97
allow shell proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 97

allow shell proc_interrupts:file { getattr open read ioctl lock map };
allow shell proc_meminfo:file { getattr open read ioctl lock map };
allow shell proc_stat:file { getattr open read ioctl lock map };
allow shell proc_timer:file { getattr open read ioctl lock map };
allow shell proc_zoneinfo:file { getattr open read ioctl lock map };

#line 103
allow shell cgroup:dir { open getattr read search ioctl lock };
#line 103
allow shell cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 103

allow shell domain:dir { search open read getattr };
allow shell domain:{ file lnk_file } { open read getattr };

# statvfs() of /proc and other labeled filesystems
# (yaffs2, jffs2, ext2, ext3, ext4, xfs, btrfs, f2fs, squashfs)
allow shell { proc labeledfs }:filesystem getattr;

# stat() of /dev
allow shell device:dir getattr;

# allow shell to read /proc/pid/attr/current for ps -Z
allow shell domain:process getattr;

# Allow pulling the SELinux policy for CTS purposes
allow shell selinuxfs:dir { open getattr read search ioctl lock };
allow shell selinuxfs:file { getattr open read ioctl lock map };

# enable shell domain to read/write files/dirs for bootchart data
# User will creates the start and stop file via adb shell
# and read other files created by init process under /data/bootchart
allow shell bootchart_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow shell bootchart_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Make sure strace works for the non-privileged shell user
allow shell self:process ptrace;

# allow shell to get battery info
allow shell sysfs_batteryinfo:file { getattr open read ioctl lock map };
allow shell sysfs:dir { open getattr read search ioctl lock };

# Allow access to ion memory allocation device.
allow shell ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

#
# filesystem test for insecure chr_file's is done
# via a host side test
#
allow shell dev_type:dir { open getattr read search ioctl lock };
allow shell dev_type:chr_file getattr;

# /dev/fd is a symlink
allow shell proc:lnk_file getattr;

#
# filesystem test for insucre blk_file's is done
# via hostside test
#
allow shell dev_type:blk_file getattr;

# read selinux policy files
allow shell file_contexts_file:file { getattr open read ioctl lock map };
allow shell property_contexts_file:file { getattr open read ioctl lock map };
allow shell seapp_contexts_file:file { getattr open read ioctl lock map };
allow shell service_contexts_file:file { getattr open read ioctl lock map };
allow shell sepolicy_file:file { getattr open read ioctl lock map };

###
### Neverallow rules
###

# Do not allow shell to hard link to any files.
# In particular, if shell hard links to app data
# files, installd will not be able to guarantee the deletion
# of the linked to file. Hard links also contribute to security
# bugs, so we want to ensure the shell user never has this
# capability.
neverallow shell file_type:file link;

# Do not allow privileged socket ioctl commands
neverallowxperm shell domain:{ rawip_socket tcp_socket udp_socket } ioctl 
#line 173
{
#line 173
# qualcomm rmnet ioctls
#line 173
0x00006900 0x00006902
#line 173
# socket ioctls
#line 173
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 173
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 173
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 173
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 173
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 173
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 173
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 173
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 173
0x00008991 0x00008992 0x00008993 0x00008994
#line 173
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 173
# device and protocol specific ioctls
#line 173
0x000089f0-0x000089ff
#line 173
0x000089e0-0x000089ef
#line 173
# Wireless extension ioctls
#line 173
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 173
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 173
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 173
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 173
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 173
0x00008b34 0x00008b35 0x00008b36
#line 173
# Dev private ioctl i.e. hardware specific ioctls
#line 173
0x00008be0-0x00008bff
#line 173
};

# limit shell access to sensitive char drivers to
# only getattr required for host side test.
neverallow shell {
  fuse_device
  hw_random_device
  kmem_device
  port_device
}:chr_file ~getattr;

# Limit shell to only getattr on blk devices for host side tests.
neverallow shell dev_type:blk_file ~getattr;
#line 1 "system/sepolicy/public/slideshow.te"
# slideshow seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type slideshow, domain;

allow slideshow kmsg_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

#line 6
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 6
allow slideshow sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 6
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 6
allow slideshow self:capability2 block_suspend;
#line 6

allow slideshow device:dir { open getattr read search ioctl lock };
allow slideshow self:capability sys_tty_config;
allow slideshow graphics_device:dir { open getattr read search ioctl lock };
allow slideshow graphics_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow slideshow input_device:dir { open getattr read search ioctl lock };
allow slideshow input_device:chr_file { getattr open read ioctl lock map };
allow slideshow tty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

#line 1 "system/sepolicy/public/su.te"
# All types must be defined regardless of build variant to ensure
# policy compilation succeeds with userdebug/user combination at boot
type su, domain;

# File types must be defined for file_contexts.
type su_exec, exec_type, file_type;


#line 8
  # Domain used for su processes, as well as for adbd and adb shell
#line 8
  # after performing an adb root command.  The domain definition is
#line 8
  # wrapped to ensure that it does not exist at all on -user builds.
#line 8
  typeattribute su mlstrustedsubject;
#line 8

#line 8
  # Add su to various domains
#line 8
  
#line 8
typeattribute su netdomain;
#line 8

#line 8

#line 8
  # grant su access to vndbinder
#line 8
  
#line 8
# Talk to the vndbinder device node
#line 8
allow su vndbinder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 8
# Call the vndservicemanager and transfer references to it.
#line 8
allow su vndservicemanager:binder { call transfer };
#line 8
# vndservicemanager performs getpidcon on clients.
#line 8
allow vndservicemanager su:dir search;
#line 8
allow vndservicemanager su:file { read open };
#line 8
allow vndservicemanager su:process getattr;
#line 8

#line 8

#line 8
  dontaudit su self:{ capability capability2 } *;
#line 8
  dontaudit su kernel:security *;
#line 8
  dontaudit su kernel:system *;
#line 8
  dontaudit su self:memprotect *;
#line 8
  dontaudit su domain:process *;
#line 8
  dontaudit su domain:fd *;
#line 8
  dontaudit su domain:dir *;
#line 8
  dontaudit su domain:lnk_file *;
#line 8
  dontaudit su domain:{ fifo_file file } *;
#line 8
  dontaudit su domain:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket } *;
#line 8
  dontaudit su domain:{ sem msgq shm ipc } *;
#line 8
  dontaudit su domain:key *;
#line 8
  dontaudit su fs_type:filesystem *;
#line 8
  dontaudit su {fs_type dev_type file_type}:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } *;
#line 8
  dontaudit su node_type:node *;
#line 8
  dontaudit su node_type:{ tcp_socket udp_socket rawip_socket } *;
#line 8
  dontaudit su netif_type:netif *;
#line 8
  dontaudit su port_type:{ socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket unix_stream_socket unix_dgram_socket appletalk_socket netlink_route_socket netlink_tcpdiag_socket netlink_nflog_socket netlink_xfrm_socket netlink_selinux_socket netlink_audit_socket netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket } *;
#line 8
  dontaudit su port_type:{ tcp_socket dccp_socket } *;
#line 8
  dontaudit su domain:peer *;
#line 8
  dontaudit su domain:binder *;
#line 8
  dontaudit su property_type:property_service *;
#line 8
  dontaudit su property_type:file *;
#line 8
  dontaudit su service_manager_type:service_manager *;
#line 8
  dontaudit su hwservice_manager_type:hwservice_manager *;
#line 8
  dontaudit su vndservice_manager_type:service_manager *;
#line 8
  dontaudit su servicemanager:service_manager list;
#line 8
  dontaudit su hwservicemanager:hwservice_manager list;
#line 8
  dontaudit su vndservicemanager:service_manager list;
#line 8
  dontaudit su keystore:keystore_key *;
#line 8
  dontaudit su domain:drmservice *;
#line 8
  dontaudit su unlabeled:filesystem *;
#line 8
  dontaudit su postinstall_file:filesystem *;
#line 53

#line 1 "system/sepolicy/public/surfaceflinger.te"
# surfaceflinger - display compositor service
type surfaceflinger, domain;
#line 1 "system/sepolicy/public/system_app.te"
###
### Apps that run with the system UID, e.g. com.android.system.ui,
### com.android.settings.  These are not as privileged as the system
### server.
###

type system_app, domain;
#line 1 "system/sepolicy/public/system_server.te"
#
# System Server aka system_server spawned by zygote.
# Most of the framework services run in this process.
#
type system_server, domain;
#line 1 "system/sepolicy/public/tee.te"
##
# trusted execution environment (tee) daemon
#
type tee, domain;

# Device(s) for communicating with the TEE
type tee_device, dev_type;
#line 1 "system/sepolicy/public/thermalserviced.te"
# thermalserviced -- thermal management services for system and vendor
type thermalserviced, domain;
type thermalserviced_exec, exec_type, file_type;


#line 5
# Call the servicemanager and transfer references to it.
#line 5
allow thermalserviced servicemanager:binder { call transfer };
#line 5
# servicemanager performs getpidcon on clients.
#line 5
allow servicemanager thermalserviced:dir search;
#line 5
allow servicemanager thermalserviced:file { read open };
#line 5
allow servicemanager thermalserviced:process getattr;
#line 5
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 5
# all domains in domain.te.
#line 5


#line 6
typeattribute thermalserviced binderservicedomain;
#line 6


#line 7
  allow thermalserviced thermal_service:service_manager { add find };
#line 7
  neverallow { domain -thermalserviced } thermal_service:service_manager add;
#line 7



#line 9
# Call the hwservicemanager and transfer references to it.
#line 9
allow thermalserviced hwservicemanager:binder { call transfer };
#line 9
# Allow hwservicemanager to send out callbacks
#line 9
allow hwservicemanager thermalserviced:binder { call transfer };
#line 9
# hwservicemanager performs getpidcon on clients.
#line 9
allow hwservicemanager thermalserviced:dir search;
#line 9
allow hwservicemanager thermalserviced:file { read open };
#line 9
allow hwservicemanager thermalserviced:process getattr;
#line 9
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 9
# all domains in domain.te.
#line 9


#line 10
typeattribute thermalserviced halclientdomain;
#line 10
typeattribute thermalserviced hal_thermal_client;
#line 10

#line 10
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 10
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 10
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 10

#line 10
typeattribute thermalserviced hal_thermal;
#line 10
# Find passthrough HAL implementations
#line 10
allow hal_thermal system_file:dir { open getattr read search ioctl lock };
#line 10
allow hal_thermal vendor_file:dir { open getattr read search ioctl lock };
#line 10
allow hal_thermal vendor_file:file { read open getattr execute map };
#line 10

#line 10


#line 11
  allow thermalserviced thermalcallback_hwservice:hwservice_manager { add find };
#line 11
  allow thermalserviced hidl_base_hwservice:hwservice_manager add;
#line 11
  neverallow { domain -thermalserviced } thermalcallback_hwservice:hwservice_manager add;
#line 11

#line 1 "system/sepolicy/public/tombstoned.te"
# debugger interface
type tombstoned, domain, mlstrustedsubject;
type tombstoned_exec, exec_type, file_type;

# Write to arbitrary pipes given to us.
allow tombstoned domain:fd use;
allow tombstoned domain:fifo_file write;

allow tombstoned domain:dir { open getattr read search ioctl lock };
allow tombstoned domain:file { getattr open read ioctl lock map };
allow tombstoned tombstone_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow tombstoned tombstone_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# TODO: Remove append / write permissions. They were temporarily
# granted due to a bug which appears to have been fixed.
allow tombstoned anr_data_file:file { append write };
auditallow tombstoned anr_data_file:file { append write };

# Changes for the new stack dumping mechanism. Each trace goes into a
# separate file, and these files are managed by tombstoned.
allow tombstoned anr_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow tombstoned anr_data_file:file { getattr open create };
#line 1 "system/sepolicy/public/toolbox.te"
# Any toolbox command run by init.
# At present, the only known usage is for running mkswap via fs_mgr.
# Do NOT use this domain for toolbox when run by any other domain.
type toolbox, domain;
type toolbox_exec, exec_type, file_type;

# /dev/__null__ created by init prior to policy load,
# open fd inherited by fsck.
allow toolbox tmpfs:chr_file { read write ioctl };

# Inherit and use pty created by android_fork_execvp_ext().
allow toolbox devpts:chr_file { read write getattr ioctl };

# mkswap-specific.
# Read/write block devices used for swap partitions.
# Assign swap_block_device type any such partition in your
# device/<vendor>/<product>/sepolicy/file_contexts file.
allow toolbox block_device:dir search;
allow toolbox swap_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Only allow entry from init via the toolbox binary.
neverallow { domain -init } toolbox:process transition;
neverallow * toolbox:process dyntransition;
neverallow toolbox { file_type fs_type -toolbox_exec}:file entrypoint;
#line 1 "system/sepolicy/public/tzdatacheck.te"
# The tzdatacheck command run by init.
type tzdatacheck, domain;
type tzdatacheck_exec, exec_type, file_type;

allow tzdatacheck zoneinfo_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow tzdatacheck zoneinfo_data_file:file unlink;

# Below are strong assertion that only init, system_server and tzdatacheck
# can modify the /data time zone rules directories. This is to make it very
# clear that only these domains should modify the actual time zone rules data.
# The tzdatacheck binary itself may be executed by shell for tests but it must
# not be able to modify the real rules.
# If other users / binaries could modify time zone rules on device this might
# have negative implications for users (who may get incorrect local times)
# or break assumptions made / invalidate data held by the components actually
# responsible for updating time zone rules.
neverallow { domain -system_server -init -tzdatacheck } zoneinfo_data_file:file { append create link unlink relabelfrom rename setattr write };
neverallow { domain -system_server -init -tzdatacheck } zoneinfo_data_file:dir { add_name create link relabelfrom remove_name rename reparent rmdir setattr write };
#line 1 "system/sepolicy/public/ueventd.te"
# ueventd seclabel is specified in init.rc since
# it lives in the rootfs and has no unique file type.
type ueventd, domain;

# Write to /dev/kmsg.
allow ueventd kmsg_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

allow ueventd self:capability { chown mknod net_admin setgid fsetid sys_rawio dac_override fowner };
allow ueventd device:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };


#line 11
allow ueventd rootfs:dir { open getattr read search ioctl lock };
#line 11
allow ueventd rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 11


# ueventd needs write access to files in /sys to regenerate uevents
allow ueventd sysfs_type:file { open append write lock map };

#line 15
allow ueventd sysfs_type:dir { open getattr read search ioctl lock };
#line 15
allow ueventd sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 15

allow ueventd sysfs_type:{ file lnk_file } { relabelfrom relabelto setattr };
allow ueventd sysfs_type:dir { relabelfrom relabelto setattr };
allow ueventd tmpfs:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow ueventd dev_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow ueventd dev_type:lnk_file { create unlink };
allow ueventd dev_type:chr_file { getattr create setattr unlink };
allow ueventd dev_type:blk_file { getattr relabelfrom relabelto create setattr unlink };
allow ueventd self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow ueventd efs_file:dir search;
allow ueventd efs_file:file { getattr open read ioctl lock map };

# Get SELinux enforcing status.

#line 28
allow ueventd selinuxfs:dir { open getattr read search ioctl lock };
#line 28
allow ueventd selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 28


# Access for /vendor/ueventd.rc and /vendor/firmware

#line 31
allow ueventd { vendor_file_type -vendor_app_file -vendor_overlay_file }:dir { open getattr read search ioctl lock };
#line 31
allow ueventd { vendor_file_type -vendor_app_file -vendor_overlay_file }:{ file lnk_file } { getattr open read ioctl lock map };
#line 31


# Get file contexts for new device nodes
allow ueventd file_contexts_file:file { getattr open read ioctl lock map };

# Use setfscreatecon() to label /dev directories and files.
allow ueventd self:process setfscreate;

#####
##### neverallow rules
#####

# ueventd must never set properties, otherwise deadlocks may occur.
# https://android-review.googlesource.com/#/c/133120/6/init/devices.cpp@941
# No writing to the property socket, connecting to init, or setting properties.
neverallow ueventd property_socket:sock_file write;
neverallow ueventd init:unix_stream_socket connectto;
neverallow ueventd property_type:property_service set;

# Restrict ueventd access on block devices to maintenence operations.
neverallow ueventd dev_type:blk_file ~{ getattr relabelfrom relabelto create setattr unlink };

# Only relabelto as we would never want to relabelfrom kmem_device or port_device
neverallow ueventd { kmem_device port_device }:chr_file ~{ getattr create setattr unlink relabelto };
#line 1 "system/sepolicy/public/uncrypt.te"
# uncrypt
type uncrypt, domain, mlstrustedsubject;
type uncrypt_exec, exec_type, file_type;

allow uncrypt self:capability dac_override;

# Read OTA zip file from /data/data/com.google.android.gsf/app_download

#line 8
allow uncrypt app_data_file:dir { open getattr read search ioctl lock };
#line 8
allow uncrypt app_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 8



#line 10
  # For debugging, allow /data/local/tmp access
#line 10
  
#line 10
allow uncrypt shell_data_file:dir { open getattr read search ioctl lock };
#line 10
allow uncrypt shell_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 10

#line 13


# Read /cache/recovery/command
# Read /cache/recovery/uncrypt_file
allow uncrypt cache_file:dir search;
allow uncrypt cache_recovery_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow uncrypt cache_recovery_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Read OTA zip file at /data/ota_package/.
allow uncrypt ota_package_file:dir { open getattr read search ioctl lock };
allow uncrypt ota_package_file:file { getattr open read ioctl lock map };

# Write to /dev/socket/uncrypt

#line 26

#line 26

#line 26
allow uncrypt uncrypt_socket:sock_file write;
#line 26
allow uncrypt uncrypt:unix_stream_socket connectto;
#line 26

#line 26


# Set a property to reboot the device.

#line 29

#line 29
allow uncrypt property_socket:sock_file write;
#line 29
allow uncrypt init:unix_stream_socket connectto;
#line 29

#line 29
allow uncrypt powerctl_prop:property_service set;
#line 29

#line 29
allow uncrypt powerctl_prop:file { getattr open read ioctl lock map };
#line 29

#line 29


# Raw writes to block device
allow uncrypt self:capability sys_rawio;
allow uncrypt misc_block_device:blk_file { open append write lock map };
allow uncrypt block_device:dir { open getattr read search ioctl lock };

# Access userdata block device.
allow uncrypt userdata_block_device:blk_file { open append write lock map };


#line 39
allow uncrypt rootfs:dir { open getattr read search ioctl lock };
#line 39
allow uncrypt rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 39

#line 1 "system/sepolicy/public/untrusted_app.te"
###
### Untrusted apps.
###
### Apps are labeled based on mac_permissions.xml (maps signer and
### optionally package name to seinfo value) and seapp_contexts (maps UID
### and optionally seinfo value to domain for process and type for data
### directory).  The untrusted_app domain is the default assignment in
### seapp_contexts for any app with UID between APP_AID (10000)
### and AID_ISOLATED_START (99000) if the app has no specific seinfo
### value as determined from mac_permissions.xml.  In current AOSP, this
### domain is assigned to all non-system apps as well as to any system apps
### that are not signed by the platform key.  To move
### a system app into a specific domain, add a signer entry for it to
### mac_permissions.xml and assign it one of the pre-existing seinfo values
### or define and use a new seinfo value in both mac_permissions.xml and
### seapp_contexts.
###

type untrusted_app, domain;
#line 1 "system/sepolicy/public/untrusted_app_25.te"
###
### Untrusted apps.
###
### Apps are labeled based on mac_permissions.xml (maps signer and
### optionally package name to seinfo value) and seapp_contexts (maps UID
### and optionally seinfo value to domain for process and type for data
### directory).  The untrusted_app domain is the default assignment in
### seapp_contexts for any app with UID between APP_AID (10000)
### and AID_ISOLATED_START (99000) if the app has no specific seinfo
### value as determined from mac_permissions.xml.  In current AOSP, this
### domain is assigned to all non-system apps as well as to any system apps
### that are not signed by the platform key.  To move
### a system app into a specific domain, add a signer entry for it to
### mac_permissions.xml and assign it one of the pre-existing seinfo values
### or define and use a new seinfo value in both mac_permissions.xml and
### seapp_contexts.
###

type untrusted_app_25, domain;

#line 1 "system/sepolicy/public/untrusted_v2_app.te"
###
### Untrusted v2 sandbox apps.
###

type untrusted_v2_app, domain;
#line 1 "system/sepolicy/public/update_engine.te"
# Domain for update_engine daemon.
type update_engine, domain, update_engine_common;
type update_engine_exec, exec_type, file_type;


#line 5
typeattribute update_engine netdomain;
#line 5
;

# Read/[write] to /proc/net/xt_qtaguid/ctrl and /dev/xt_qtaguid to tag network
# sockets.
allow update_engine qtaguid_proc:file { { getattr open read ioctl lock map } { open append write lock map } };
allow update_engine qtaguid_device:chr_file { getattr open read ioctl lock map };

# Following permissions are needed for update_engine.
allow update_engine self:process { setsched };
allow update_engine self:capability { fowner sys_admin };
allow update_engine kmsg_device:chr_file { open append write lock map };
allow update_engine update_engine_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

#line 17
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 17
allow update_engine sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 17
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 17
allow update_engine self:capability2 block_suspend;
#line 17
;

# Ignore these denials.
dontaudit update_engine kernel:process setsched;

# Allow using persistent storage in /data/misc/update_engine.
allow update_engine update_engine_data_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } };
allow update_engine update_engine_data_file:file { { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } };

# Don't allow kernel module loading, just silence the logs.
dontaudit update_engine kernel:system module_request;

# Register the service to perform Binder IPC.

#line 30
# Call the servicemanager and transfer references to it.
#line 30
allow update_engine servicemanager:binder { call transfer };
#line 30
# servicemanager performs getpidcon on clients.
#line 30
allow servicemanager update_engine:dir search;
#line 30
allow servicemanager update_engine:file { read open };
#line 30
allow servicemanager update_engine:process getattr;
#line 30
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 30
# all domains in domain.te.
#line 30


#line 31
  allow update_engine update_engine_service:service_manager { add find };
#line 31
  neverallow { domain -update_engine } update_engine_service:service_manager add;
#line 31


# Allow update_engine to call the callback function provided by priv_app.

#line 34
# Call the server domain and optionally transfer references to it.
#line 34
allow update_engine priv_app:binder { call transfer };
#line 34
# Allow the serverdomain to transfer references to the client on the reply.
#line 34
allow priv_app update_engine:binder transfer;
#line 34
# Receive and use open files from the server.
#line 34
allow update_engine priv_app:fd use;
#line 34


# Read OTA zip file at /data/ota_package/.
allow update_engine ota_package_file:file { getattr open read ioctl lock map };
allow update_engine ota_package_file:dir { open getattr read search ioctl lock };

# Use Boot Control HAL

#line 41
typeattribute update_engine halclientdomain;
#line 41
typeattribute update_engine hal_bootctl_client;
#line 41

#line 41
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 41
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 41
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 41

#line 41
typeattribute update_engine hal_bootctl;
#line 41
# Find passthrough HAL implementations
#line 41
allow hal_bootctl system_file:dir { open getattr read search ioctl lock };
#line 41
allow hal_bootctl vendor_file:dir { open getattr read search ioctl lock };
#line 41
allow hal_bootctl vendor_file:file { read open getattr execute map };
#line 41

#line 41

#line 1 "system/sepolicy/public/update_engine_common.te"
# update_engine payload application permissions. These are shared between the
# background daemon and the recovery tool to sideload an update.

# Allow update_engine to reach block devices in /dev/block.
allow update_engine_common block_device:dir search;

# Allow read/write on system and boot partitions.
allow update_engine_common boot_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };
allow update_engine_common system_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Allow to set recovery options in the BCB. Used to trigger factory reset when
# the update to an older version (channel change) or incompatible version
# requires it.
allow update_engine_common misc_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# read fstab
allow update_engine_common rootfs:dir getattr;
allow update_engine_common rootfs:file { getattr open read ioctl lock map };

# Allow update_engine_common to mount on the /postinstall directory and reset the
# labels on the mounted filesystem to postinstall_file.
allow update_engine_common postinstall_mnt_dir:dir { mounton getattr search };
allow update_engine_common postinstall_file:filesystem { mount unmount relabelfrom relabelto };
allow update_engine_common labeledfs:filesystem relabelfrom;

# Allow update_engine_common to read and execute postinstall_file.
allow update_engine_common postinstall_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow update_engine_common postinstall_file:lnk_file { getattr open read ioctl lock map };
allow update_engine_common postinstall_file:dir { open getattr read search ioctl lock };

# install update.zip from cache

#line 32
allow update_engine_common cache_file:dir { open getattr read search ioctl lock };
#line 32
allow update_engine_common cache_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 32


# A postinstall program is typically a shell script (with a #!), so we allow
# to execute those.
allow update_engine_common shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Allow update_engine_common to suspend, resume and kill the postinstall program.
allow update_engine_common postinstall:process { signal sigstop sigkill };

# access /proc/misc
# Access is also granted to proc:file, but it is likely unneeded
# due to the more specific grant to proc_misc immediately below.
allow update_engine proc:file { getattr open read ioctl lock map }; # delete candidate
allow update_engine proc_misc:file { getattr open read ioctl lock map };

# read directories on /system and /vendor
allow update_engine system_file:dir { open getattr read search ioctl lock };
#line 1 "system/sepolicy/public/update_verifier.te"
# update_verifier
type update_verifier, domain;
type update_verifier_exec, exec_type, file_type;

# Allow update_verifier to reach block devices in /dev/block.
allow update_verifier block_device:dir search;

# Read care map in /data/ota_package/.
allow update_verifier ota_package_file:dir { open getattr read search ioctl lock };
allow update_verifier ota_package_file:file { getattr open read ioctl lock map };

# Read all blocks in dm wrapped system partition.
allow update_verifier dm_device:blk_file { getattr open read ioctl lock map };

# Allow update_verifier to reboot the device.

#line 16

#line 16
allow update_verifier property_socket:sock_file write;
#line 16
allow update_verifier init:unix_stream_socket connectto;
#line 16

#line 16
allow update_verifier powerctl_prop:property_service set;
#line 16

#line 16
allow update_verifier powerctl_prop:file { getattr open read ioctl lock map };
#line 16

#line 16


# Use Boot Control HAL

#line 19
typeattribute update_verifier halclientdomain;
#line 19
typeattribute update_verifier hal_bootctl_client;
#line 19

#line 19
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 19
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 19
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 19

#line 19
typeattribute update_verifier hal_bootctl;
#line 19
# Find passthrough HAL implementations
#line 19
allow hal_bootctl system_file:dir { open getattr read search ioctl lock };
#line 19
allow hal_bootctl vendor_file:dir { open getattr read search ioctl lock };
#line 19
allow hal_bootctl vendor_file:file { read open getattr execute map };
#line 19

#line 19

#line 1 "system/sepolicy/public/vdc.te"
# vdc spawned from init for the following services:
#  defaultcrypto
#  encrypt
#
# We also transition into this domain from dumpstate, when
# collecting bug reports.

type vdc, domain;
type vdc_exec, exec_type, file_type;


#line 11

#line 11

#line 11
allow vdc vold_socket:sock_file write;
#line 11
allow vdc vold:unix_stream_socket connectto;
#line 11

#line 11


# vdc sends information back to dumpstate when "adb bugreport" is used
allow vdc dumpstate:fd use;
allow vdc dumpstate:unix_stream_socket { read write getattr };

# vdc information is written to shell owned bugreport files
allow vdc shell_data_file:file { write getattr };

# Why?
allow vdc dumpstate:unix_dgram_socket { read write };

# vdc can be invoked with logwrapper, so let it write to pty
allow vdc devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# vdc writes directly to kmsg during the boot process
allow vdc kmsg_device:chr_file { open append write lock map };
#line 1 "system/sepolicy/public/vendor_shell.te"
# vendor shell MUST never run as interactive or login shell.
# vendor shell CAN never be traisitioned to by any process, so it is
# only intended by shell script interpreter.
type vendor_shell_exec, exec_type, vendor_file_type, file_type;
#line 1 "system/sepolicy/public/vendor_toolbox.te"
# Toolbox installation for vendor binaries / scripts
# Non-vendor processes are not allowed to execute the binary
# and is always executed without transition.
type vendor_toolbox_exec, exec_type, vendor_file_type, file_type;

# Do not allow domains to transition to vendor toolbox
# or read, execute the vendor_toolbox file.
# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 8

#line 8
    # Do not allow non-vendor domains to transition
#line 8
    # to vendor toolbox except for the whitelisted domains.
#line 8
    neverallow {
#line 8
        coredomain
#line 8
        -init
#line 8
        -modprobe
#line 8
    } vendor_toolbox_exec:file { entrypoint execute execute_no_trans };
#line 8

#line 8
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 16

#line 1 "system/sepolicy/public/virtual_touchpad.te"
type virtual_touchpad, domain;
type virtual_touchpad_exec, exec_type, file_type;


#line 4
# Call the servicemanager and transfer references to it.
#line 4
allow virtual_touchpad servicemanager:binder { call transfer };
#line 4
# servicemanager performs getpidcon on clients.
#line 4
allow servicemanager virtual_touchpad:dir search;
#line 4
allow servicemanager virtual_touchpad:file { read open };
#line 4
allow servicemanager virtual_touchpad:process getattr;
#line 4
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 4
# all domains in domain.te.
#line 4


#line 5
typeattribute virtual_touchpad binderservicedomain;
#line 5


#line 6
  allow virtual_touchpad virtual_touchpad_service:service_manager { add find };
#line 6
  neverallow { domain -virtual_touchpad } virtual_touchpad_service:service_manager add;
#line 6


# Needed to check app permissions.

#line 9
# Call the server domain and optionally transfer references to it.
#line 9
allow virtual_touchpad system_server:binder { call transfer };
#line 9
# Allow the serverdomain to transfer references to the client on the reply.
#line 9
allow system_server virtual_touchpad:binder transfer;
#line 9
# Receive and use open files from the server.
#line 9
allow virtual_touchpad system_server:fd use;
#line 9


# Requires access to /dev/uinput to create and feed the virtual device.
allow virtual_touchpad uhid_device:chr_file { { open append write lock map } ioctl };

# Requires access to the permission service to validate that clients have the
# appropriate VR permissions.
allow virtual_touchpad permission_service:service_manager find;
#line 1 "system/sepolicy/public/vndservice.te"
type default_android_vndservice, vndservice_manager_type;
#line 1 "system/sepolicy/public/vndservicemanager.te"
# vndservicemanager - the Binder context manager for vendor processes
type vndservicemanager, domain;
#line 1 "system/sepolicy/public/vold.te"
# volume manager
type vold, domain;
type vold_exec, exec_type, file_type;

# Read already opened /cache files.
allow vold cache_file:dir { open getattr read search ioctl lock };
allow vold cache_file:file { getattr read };
allow vold cache_file:lnk_file { getattr open read ioctl lock map };

# Read access to pseudo filesystems.

#line 11
allow vold proc:dir { open getattr read search ioctl lock };
#line 11
allow vold proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 11


#line 12
allow vold proc_net:dir { open getattr read search ioctl lock };
#line 12
allow vold proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 12


#line 13
allow vold sysfs_type:dir { open getattr read search ioctl lock };
#line 13
allow vold sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 13

# XXX Label sysfs files with a specific type?
allow vold sysfs:file { open append write lock map };
allow vold sysfs_usb:file { open append write lock map };
allow vold sysfs_zram_uevent:file { open append write lock map };


#line 19
allow vold rootfs:dir { open getattr read search ioctl lock };
#line 19
allow vold rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 19

allow vold proc_meminfo:file { getattr open read ioctl lock map };

#Get file contexts
allow vold file_contexts_file:file { getattr open read ioctl lock map };

# Allow us to jump into execution domains of above tools
allow vold self:process setexec;

# For sgdisk launched through popen()
allow vold shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# For formatting adoptable storage devices
allow vold e2fs_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

typeattribute vold mlstrustedsubject;
allow vold self:process setfscreate;
allow vold system_file:file { getattr execute execute_no_trans map };
allow vold vendor_file:file { getattr execute execute_no_trans map };
allow vold block_device:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow vold device:dir write;
allow vold devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow vold rootfs:dir mounton;
allow vold sdcard_type:dir mounton; # TODO: deprecated in M
allow vold sdcard_type:filesystem { mount remount unmount }; # TODO: deprecated in M
allow vold sdcard_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } }; # TODO: deprecated in M
allow vold sdcard_type:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } }; # TODO: deprecated in M

# Manage locations where storage is mounted
allow vold { mnt_media_rw_file storage_file sdcard_type }:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow vold { mnt_media_rw_file storage_file sdcard_type }:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access to storage that backs emulated FUSE daemons for migration optimization
allow vold media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow vold media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Allow mounting of storage devices
allow vold { mnt_media_rw_stub_file storage_stub_file }:dir { mounton create rmdir getattr setattr };

# Manage per-user primary symlinks
allow vold mnt_user_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow vold mnt_user_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Allow to create and mount expanded storage
allow vold mnt_expand_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } mounton };
allow vold apk_data_file:dir { create getattr setattr };
allow vold shell_data_file:dir { create getattr setattr };

allow vold tmpfs:filesystem { mount unmount };
allow vold tmpfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow vold tmpfs:dir mounton;
allow vold self:capability { net_admin dac_override mknod sys_admin chown fowner fsetid };
allow vold self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow vold app_data_file:dir search;
allow vold app_data_file:file { { getattr open read ioctl lock map } { open append write lock map } };
allow vold loop_control_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow vold loop_device:blk_file { create setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow vold vold_device:blk_file { create setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow vold dm_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow vold dm_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };
# For vold Process::killProcessesWithOpenFiles function.
allow vold domain:dir { open getattr read search ioctl lock };
allow vold domain:{ file lnk_file } { getattr open read ioctl lock map };
allow vold domain:process { signal sigkill };
allow vold self:capability { sys_ptrace kill };

# XXX Label sysfs files with a specific type?
allow vold sysfs:file { { getattr open read ioctl lock map } { open append write lock map } };

allow vold kmsg_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Run fsck in the fsck domain.
allow vold fsck_exec:file { { getattr open read ioctl lock map } execute };

# Log fsck results
allow vold fscklogs:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow vold fscklogs:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

#
# Rules to support encrypted fs support.
#

# Unmount and mount the fs.
allow vold labeledfs:filesystem { mount unmount };

# Access /efs/userdata_footer.
# XXX Split into a separate type?
allow vold efs_file:file { { getattr open read ioctl lock map } { open append write lock map } };

# Create and mount on /data/tmp_mnt and management of expansion mounts
allow vold system_data_file:dir { create { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } mounton setattr rmdir };

# Set scheduling policy of kernel processes
allow vold kernel:process setsched;

# Property Service

#line 115

#line 115
allow vold property_socket:sock_file write;
#line 115
allow vold init:unix_stream_socket connectto;
#line 115

#line 115
allow vold vold_prop:property_service set;
#line 115

#line 115
allow vold vold_prop:file { getattr open read ioctl lock map };
#line 115

#line 115


#line 116

#line 116
allow vold property_socket:sock_file write;
#line 116
allow vold init:unix_stream_socket connectto;
#line 116

#line 116
allow vold powerctl_prop:property_service set;
#line 116

#line 116
allow vold powerctl_prop:file { getattr open read ioctl lock map };
#line 116

#line 116


#line 117

#line 117
allow vold property_socket:sock_file write;
#line 117
allow vold init:unix_stream_socket connectto;
#line 117

#line 117
allow vold ctl_fuse_prop:property_service set;
#line 117

#line 117
allow vold ctl_fuse_prop:file { getattr open read ioctl lock map };
#line 117

#line 117


#line 118

#line 118
allow vold property_socket:sock_file write;
#line 118
allow vold init:unix_stream_socket connectto;
#line 118

#line 118
allow vold restorecon_prop:property_service set;
#line 118

#line 118
allow vold restorecon_prop:file { getattr open read ioctl lock map };
#line 118

#line 118


# ASEC
allow vold asec_image_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow vold asec_image_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow vold asec_apk_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } mounton relabelfrom relabelto };
allow vold asec_public_file:dir { relabelto setattr };
allow vold asec_apk_file:file { { getattr open read ioctl lock map } setattr relabelfrom relabelto };
allow vold asec_public_file:file { relabelto setattr };
# restorecon files in asec containers created on 4.2 or earlier.
allow vold unlabeled:dir { { open getattr read search ioctl lock } setattr relabelfrom };
allow vold unlabeled:file { { getattr open read ioctl lock map } setattr relabelfrom };

# Handle wake locks (used for device encryption)

#line 132
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 132
allow vold sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 132
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 132
allow vold self:capability2 block_suspend;
#line 132


# talk to batteryservice

#line 135
# Call the servicemanager and transfer references to it.
#line 135
allow vold servicemanager:binder { call transfer };
#line 135
# servicemanager performs getpidcon on clients.
#line 135
allow servicemanager vold:dir search;
#line 135
allow servicemanager vold:file { read open };
#line 135
allow servicemanager vold:process getattr;
#line 135
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 135
# all domains in domain.te.
#line 135


#line 136
# Call the server domain and optionally transfer references to it.
#line 136
allow vold healthd:binder { call transfer };
#line 136
# Allow the serverdomain to transfer references to the client on the reply.
#line 136
allow healthd vold:binder transfer;
#line 136
# Receive and use open files from the server.
#line 136
allow vold healthd:fd use;
#line 136


# talk to keymaster

#line 139
typeattribute vold halclientdomain;
#line 139
typeattribute vold hal_keymaster_client;
#line 139

#line 139
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 139
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 139
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 139

#line 139
typeattribute vold hal_keymaster;
#line 139
# Find passthrough HAL implementations
#line 139
allow hal_keymaster system_file:dir { open getattr read search ioctl lock };
#line 139
allow hal_keymaster vendor_file:dir { open getattr read search ioctl lock };
#line 139
allow hal_keymaster vendor_file:file { read open getattr execute map };
#line 139

#line 139


# Access userdata block device.
allow vold userdata_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Access metadata block device used for encryption meta-data.
allow vold metadata_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Allow vold to manipulate /data/unencrypted
allow vold unencrypted_data_file:{ file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow vold unencrypted_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };

# Write to /proc/sys/vm/drop_caches
allow vold proc_drop_caches:file { open append write lock map };

# Give vold a place where only vold can store files; everyone else is off limits
allow vold vold_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow vold vold_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# linux keyring configuration
allow vold init:key { write search setattr };
allow vold vold:key { write search setattr };

# vold temporarily changes its priority when running benchmarks
allow vold self:capability sys_nice;

# vold needs to chroot into app namespaces to remount when runtime permissions change
allow vold self:capability sys_chroot;
allow vold storage_file:dir mounton;

# For AppFuse.
allow vold fuse_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow vold fuse:filesystem { relabelfrom };
allow vold app_fusefs:filesystem { relabelfrom relabelto };
allow vold app_fusefs:filesystem { mount unmount };

# MoveTask.cpp executes cp and rm
allow vold toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Prepare profile dir for users.
allow vold user_profile_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };

# Raw writes to misc block device
allow vold misc_block_device:blk_file { open append write lock map };

neverallow { domain -vold } vold_data_file:dir ~{ open create read getattr setattr search relabelto ioctl };
neverallow { domain -vold -kernel } vold_data_file:{ file lnk_file sock_file fifo_file } ~{ relabelto getattr };
neverallow { domain -vold -init } vold_data_file:dir *;
neverallow { domain -vold -init -kernel } vold_data_file:{ file lnk_file sock_file fifo_file } *;
neverallow { domain -vold -init } restorecon_prop:property_service set;

neverallow vold fsck_exec:file execute_no_trans;
#line 1 "system/sepolicy/public/vr_hwc.te"
type vr_hwc, domain;
type vr_hwc_exec, exec_type, file_type;

# Get buffer metadata.

#line 5
typeattribute vr_hwc halclientdomain;
#line 5
typeattribute vr_hwc hal_graphics_allocator_client;
#line 5

#line 5
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 5
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 5
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 5

#line 5
typeattribute vr_hwc hal_graphics_allocator;
#line 5
# Find passthrough HAL implementations
#line 5
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 5
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 5
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 5

#line 5



#line 7
# Call the servicemanager and transfer references to it.
#line 7
allow vr_hwc servicemanager:binder { call transfer };
#line 7
# servicemanager performs getpidcon on clients.
#line 7
allow servicemanager vr_hwc:dir search;
#line 7
allow servicemanager vr_hwc:file { read open };
#line 7
allow servicemanager vr_hwc:process getattr;
#line 7
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 7
# all domains in domain.te.
#line 7


#line 8
typeattribute vr_hwc binderservicedomain;
#line 8



#line 10
# Call the server domain and optionally transfer references to it.
#line 10
allow vr_hwc surfaceflinger:binder { call transfer };
#line 10
# Allow the serverdomain to transfer references to the client on the reply.
#line 10
allow surfaceflinger vr_hwc:binder transfer;
#line 10
# Receive and use open files from the server.
#line 10
allow vr_hwc surfaceflinger:fd use;
#line 10

# Needed to check for app permissions.

#line 12
# Call the server domain and optionally transfer references to it.
#line 12
allow vr_hwc system_server:binder { call transfer };
#line 12
# Allow the serverdomain to transfer references to the client on the reply.
#line 12
allow system_server vr_hwc:binder transfer;
#line 12
# Receive and use open files from the server.
#line 12
allow vr_hwc system_server:fd use;
#line 12



#line 14
  allow vr_hwc vr_hwc_service:service_manager { add find };
#line 14
  neverallow { domain -vr_hwc } vr_hwc_service:service_manager add;
#line 14


# Hosts the VR HWC implementation and provides a simple Binder interface for VR
# Window Manager to receive the layers/buffers.

#line 18
# Call the hwservicemanager and transfer references to it.
#line 18
allow vr_hwc hwservicemanager:binder { call transfer };
#line 18
# Allow hwservicemanager to send out callbacks
#line 18
allow hwservicemanager vr_hwc:binder { call transfer };
#line 18
# hwservicemanager performs getpidcon on clients.
#line 18
allow hwservicemanager vr_hwc:dir search;
#line 18
allow hwservicemanager vr_hwc:file { read open };
#line 18
allow hwservicemanager vr_hwc:process getattr;
#line 18
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 18
# all domains in domain.te.
#line 18


# Load vendor libraries.
allow vr_hwc system_file:dir { open getattr read search ioctl lock };

allow vr_hwc ion_device:chr_file { getattr open read ioctl lock map };

# Allow connection to VR DisplayClient to get the primary display metadata
# (ie: size).

#line 27

#line 27
# Allow client to open the service endpoint file.
#line 27
allow vr_hwc pdx_display_client_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 27
allow vr_hwc pdx_display_client_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 27
# Allow the client to connect to endpoint socket.
#line 27
allow vr_hwc pdx_display_client_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 27

#line 27

#line 27
# Allow the client to use the PDX channel socket.
#line 27
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 27
# than we need (e.g. we don"t need "bind" or "connect").
#line 27
allow vr_hwc pdx_display_client_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 27
# Client needs to use an channel event fd from the server.
#line 27
allow vr_hwc pdx_display_client_server_type:fd use;
#line 27
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 27
# This could be tightened on a per-server basis, but keeping track of service
#line 27
# clients is error prone.
#line 27
allow pdx_display_client_server_type vr_hwc:fd use;
#line 27

#line 27


# Requires access to the permission service to validate that clients have the
# appropriate VR permissions.
allow vr_hwc permission_service:service_manager find;
#line 1 "system/sepolicy/public/watchdogd.te"
# watchdogd seclabel is specified in init.<board>.rc
type watchdogd, domain;
allow watchdogd watchdog_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow watchdogd kmsg_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 1 "system/sepolicy/public/webview_zygote.te"
# webview_zygote is an auxiliary zygote process that is used to spawn
# isolated_app processes for rendering untrusted web content.

type webview_zygote, domain;
type webview_zygote_exec, exec_type, file_type;
#line 1 "system/sepolicy/public/wificond.te"
# wificond
type wificond, domain;
type wificond_exec, exec_type, file_type;


#line 5
# Call the servicemanager and transfer references to it.
#line 5
allow wificond servicemanager:binder { call transfer };
#line 5
# servicemanager performs getpidcon on clients.
#line 5
allow servicemanager wificond:dir search;
#line 5
allow servicemanager wificond:file { read open };
#line 5
allow servicemanager wificond:process getattr;
#line 5
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 5
# all domains in domain.te.
#line 5


#line 6
# Call the server domain and optionally transfer references to it.
#line 6
allow wificond system_server:binder { call transfer };
#line 6
# Allow the serverdomain to transfer references to the client on the reply.
#line 6
allow system_server wificond:binder transfer;
#line 6
# Receive and use open files from the server.
#line 6
allow wificond system_server:fd use;
#line 6



#line 8
  allow wificond wificond_service:service_manager { add find };
#line 8
  neverallow { domain -wificond } wificond_service:service_manager add;
#line 8



#line 10

#line 10
allow wificond property_socket:sock_file write;
#line 10
allow wificond init:unix_stream_socket connectto;
#line 10

#line 10
allow wificond wifi_prop:property_service set;
#line 10

#line 10
allow wificond wifi_prop:file { getattr open read ioctl lock map };
#line 10

#line 10


#line 11

#line 11
allow wificond property_socket:sock_file write;
#line 11
allow wificond init:unix_stream_socket connectto;
#line 11

#line 11
allow wificond ctl_default_prop:property_service set;
#line 11

#line 11
allow wificond ctl_default_prop:file { getattr open read ioctl lock map };
#line 11

#line 11


# create sockets to set interfaces up and down
allow wificond self:udp_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
# setting interface state up/down is a privileged ioctl
allowxperm wificond self:udp_socket ioctl { 0x00008914 };
allow wificond self:capability { net_admin net_raw };
# allow wificond to speak to nl80211 in the kernel
allow wificond self:netlink_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
# newer kernels (e.g. 4.4 but not 4.1) have a new class for sockets
allow wificond self:netlink_generic_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };


#line 23
allow wificond proc_net:dir { open getattr read search ioctl lock };
#line 23
allow wificond proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 23


# wificond writes out configuration files for wpa_supplicant/hostapd.
# wificond also reads pid files out of this directory
allow wificond wifi_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow wificond wifi_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# allow wificond to check permission for dumping logs
allow wificond permission_service:service_manager find;

# dumpstate support
allow wificond dumpstate:fd use;
allow wificond dumpstate:fifo_file write;
#line 1 "system/sepolicy/public/zygote.te"
# zygote
type zygote, domain;
type zygote_exec, exec_type, file_type;
#line 1 "system/sepolicy/private/adbd.te"
### ADB daemon

typeattribute adbd coredomain;
typeattribute adbd mlstrustedsubject;


#line 6

#line 6
# Allow the necessary permissions.
#line 6

#line 6
# Old domain may exec the file and transition to the new domain.
#line 6
allow init adbd_exec:file { getattr open read execute map };
#line 6
allow init adbd:process transition;
#line 6
# New domain is entered by executing the file.
#line 6
allow adbd adbd_exec:file { entrypoint open read execute getattr map };
#line 6
# New domain can send SIGCHLD to its caller.
#line 6

#line 6
# Enable AT_SECURE, i.e. libc secure mode.
#line 6
dontaudit init adbd:process noatsecure;
#line 6
# XXX dontaudit candidate but requires further study.
#line 6
allow init adbd:process { siginh rlimitinh };
#line 6

#line 6
# Make the transition occur by default.
#line 6
type_transition init adbd_exec:process adbd;
#line 6

#line 6

#line 6
type adbd_tmpfs, file_type;
#line 6
type_transition adbd tmpfs:file adbd_tmpfs;
#line 6
allow adbd adbd_tmpfs:file { read write getattr };
#line 6
allow adbd tmpfs:dir { getattr search };
#line 6

#line 6



#line 8
# Allow the necessary permissions.
#line 8

#line 8
# Old domain may exec the file and transition to the new domain.
#line 8
allow adbd shell_exec:file { getattr open read execute map };
#line 8
allow adbd shell:process transition;
#line 8
# New domain is entered by executing the file.
#line 8
allow shell shell_exec:file { entrypoint open read execute getattr map };
#line 8
# New domain can send SIGCHLD to its caller.
#line 8
allow shell adbd:process sigchld;
#line 8
# Enable AT_SECURE, i.e. libc secure mode.
#line 8
dontaudit adbd shell:process noatsecure;
#line 8
# XXX dontaudit candidate but requires further study.
#line 8
allow adbd shell:process { siginh rlimitinh };
#line 8

#line 8
# Make the transition occur by default.
#line 8
type_transition adbd shell_exec:process shell;
#line 8



#line 10
  allow adbd self:process setcurrent;
#line 10
  allow adbd su:process dyntransition;
#line 13


# Do not sanitize the environment or open fds of the shell. Allow signaling
# created processes.
allow adbd shell:process { noatsecure signal };

# Set UID and GID to shell.  Set supplementary groups.
allow adbd self:capability { setuid setgid };

# Drop capabilities from bounding set on user builds.
allow adbd self:capability setpcap;

# Create and use network sockets.

#line 26
typeattribute adbd netdomain;
#line 26


# Access /dev/usb-ffs/adb/ep0
allow adbd functionfs:dir search;
allow adbd functionfs:file { { getattr open read ioctl lock map } { open append write lock map } };

# Use a pseudo tty.
allow adbd devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# adb push/pull /data/local/tmp.
allow adbd shell_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow adbd shell_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# adb pull /data/misc/profman.
allow adbd profman_dump_data_file:dir { open getattr read search ioctl lock };
allow adbd profman_dump_data_file:file { getattr open read ioctl lock map };

# adb push/pull sdcard.
allow adbd tmpfs:dir search;
allow adbd rootfs:lnk_file { getattr open read ioctl lock map };  # /sdcard symlink
allow adbd tmpfs:lnk_file { getattr open read ioctl lock map };   # /mnt/sdcard symlink
allow adbd sdcard_type:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow adbd sdcard_type:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# adb pull /data/anr/traces.txt
allow adbd anr_data_file:dir { open getattr read search ioctl lock };
allow adbd anr_data_file:file { getattr open read ioctl lock map };

# Set service.adb.*, sys.powerctl, and sys.usb.ffs.ready properties.

#line 55

#line 55
allow adbd property_socket:sock_file write;
#line 55
allow adbd init:unix_stream_socket connectto;
#line 55

#line 55
allow adbd shell_prop:property_service set;
#line 55

#line 55
allow adbd shell_prop:file { getattr open read ioctl lock map };
#line 55

#line 55


#line 56

#line 56
allow adbd property_socket:sock_file write;
#line 56
allow adbd init:unix_stream_socket connectto;
#line 56

#line 56
allow adbd powerctl_prop:property_service set;
#line 56

#line 56
allow adbd powerctl_prop:file { getattr open read ioctl lock map };
#line 56

#line 56


#line 57

#line 57
allow adbd property_socket:sock_file write;
#line 57
allow adbd init:unix_stream_socket connectto;
#line 57

#line 57
allow adbd ffs_prop:property_service set;
#line 57

#line 57
allow adbd ffs_prop:file { getattr open read ioctl lock map };
#line 57

#line 57


# Access device logging gating property

#line 60
allow adbd device_logging_prop:file { getattr open read ioctl lock map };
#line 60


# Read device's serial number from system properties

#line 63
allow adbd serialno_prop:file { getattr open read ioctl lock map };
#line 63


# Run /system/bin/bu
allow adbd system_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Perform binder IPC to surfaceflinger (screencap)
# XXX Run screencap in a separate domain?

#line 70
# Call the servicemanager and transfer references to it.
#line 70
allow adbd servicemanager:binder { call transfer };
#line 70
# servicemanager performs getpidcon on clients.
#line 70
allow servicemanager adbd:dir search;
#line 70
allow servicemanager adbd:file { read open };
#line 70
allow servicemanager adbd:process getattr;
#line 70
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 70
# all domains in domain.te.
#line 70


#line 71
# Call the server domain and optionally transfer references to it.
#line 71
allow adbd surfaceflinger:binder { call transfer };
#line 71
# Allow the serverdomain to transfer references to the client on the reply.
#line 71
allow surfaceflinger adbd:binder transfer;
#line 71
# Receive and use open files from the server.
#line 71
allow adbd surfaceflinger:fd use;
#line 71

# b/13188914
allow adbd gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow adbd ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

#line 75
allow adbd system_file:dir { open getattr read search ioctl lock };
#line 75
allow adbd system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 75


# Needed for various screenshots

#line 78
typeattribute adbd halclientdomain;
#line 78
typeattribute adbd hal_graphics_allocator_client;
#line 78

#line 78
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 78
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 78
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 78

#line 78
typeattribute adbd hal_graphics_allocator;
#line 78
# Find passthrough HAL implementations
#line 78
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 78
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 78
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 78

#line 78


# Read /data/misc/adb/adb_keys.
allow adbd adb_keys_file:dir search;
allow adbd adb_keys_file:file { getattr open read ioctl lock map };


#line 84
  # Write debugging information to /data/adb
#line 84
  # when persist.adb.trace_mask is set
#line 84
  # https://code.google.com/p/android/issues/detail?id=72895
#line 84
  allow adbd adb_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
#line 84
  allow adbd adb_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 90


# ndk-gdb invokes adb forward to forward the gdbserver socket.
allow adbd app_data_file:dir search;
allow adbd app_data_file:sock_file write;
allow adbd appdomain:unix_stream_socket connectto;

# ndk-gdb invokes adb pull of app_process, linker, and libc.so.
allow adbd zygote_exec:file { getattr open read ioctl lock map };
allow adbd system_file:file { getattr open read ioctl lock map };

# Allow pulling the SELinux policy for CTS purposes
allow adbd selinuxfs:dir { open getattr read search ioctl lock };
allow adbd selinuxfs:file { getattr open read ioctl lock map };
allow adbd kernel:security read_policy;
allow adbd service_contexts_file:file { getattr open read ioctl lock map };
allow adbd file_contexts_file:file { getattr open read ioctl lock map };
allow adbd seapp_contexts_file:file { getattr open read ioctl lock map };
allow adbd property_contexts_file:file { getattr open read ioctl lock map };
allow adbd sepolicy_file:file { getattr open read ioctl lock map };

# Allow pulling config.gz for CTS purposes
allow adbd config_gz:file { getattr open read ioctl lock map };

allow adbd surfaceflinger_service:service_manager find;
allow adbd bootchart_data_file:dir search;
allow adbd bootchart_data_file:file { getattr open read ioctl lock map };

# Allow access to external storage; we have several visible mount points under /storage
# and symlinks to primary storage at places like /storage/sdcard0 and /mnt/user/0/primary
allow adbd storage_file:dir { open getattr read search ioctl lock };
allow adbd storage_file:lnk_file { getattr open read ioctl lock map };
allow adbd mnt_user_file:dir { open getattr read search ioctl lock };
allow adbd mnt_user_file:lnk_file { getattr open read ioctl lock map };

# Access to /data/media.
# This should be removed if sdcardfs is modified to alter the secontext for its
# accesses to the underlying FS.
allow adbd media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow adbd media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };


#line 131
allow adbd apk_data_file:dir { open getattr read search ioctl lock };
#line 131
allow adbd apk_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 131


allow adbd rootfs:dir { open getattr read search ioctl lock };

###
### Neverallow rules
###

# No transitions from adbd to non-shell, non-crash_dump domains. adbd only ever
# transitions to the shell domain (except when it crashes). In particular, we
# never want to see a transition from adbd to su (aka "adb root")
neverallow adbd { domain -crash_dump -shell }:process transition;
neverallow adbd { domain -su }:process dyntransition;
#line 1 "system/sepolicy/private/app.te"
###
### Domain for all zygote spawned apps
###
### This file is the base policy for all zygote spawned apps.
### Other policy files, such as isolated_app.te, untrusted_app.te, etc
### extend from this policy. Only policies which should apply to ALL
### zygote spawned apps should be added here.
###

# TODO: deal with tmpfs_domain pub/priv split properly
# Read system properties managed by zygote.
allow appdomain zygote_tmpfs:file read;

# WebView and other application-specific JIT compilers
allow appdomain self:process execmem;

allow appdomain ashmem_device:chr_file execute;

# Receive and use open file descriptors inherited from zygote.
allow appdomain zygote:fd use;

# gdbserver for ndk-gdb reads the zygote.
# valgrind needs mmap exec for zygote
allow appdomain zygote_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Notify zygote of death;
allow appdomain zygote:process sigchld;

# Place process into foreground / background
allow appdomain cgroup:dir { search write };
allow appdomain cgroup:file { { getattr open read ioctl lock map } { open append write lock map } };

# Read /data/dalvik-cache.
allow appdomain dalvikcache_data_file:dir { search getattr };
allow appdomain dalvikcache_data_file:file { getattr open read ioctl lock map };

# Read the /sdcard and /mnt/sdcard symlinks
allow { appdomain -isolated_app } rootfs:lnk_file { getattr open read ioctl lock map };
allow { appdomain -isolated_app } tmpfs:lnk_file { getattr open read ioctl lock map };

# Search /storage/emulated tmpfs mount.
allow appdomain tmpfs:dir { open getattr read search ioctl lock };

# Notify zygote of the wrapped process PID when using --invoke-with.
allow appdomain zygote:fifo_file write;


#line 47
  # Allow apps to create and write method traces in /data/misc/trace.
#line 47
  allow appdomain method_trace_data_file:dir { open search write add_name remove_name lock };
#line 47
  allow appdomain method_trace_data_file:file { create { open append write lock map } };
#line 51


# Notify shell and adbd of death when spawned via runas for ndk-gdb.
allow appdomain shell:process sigchld;
allow appdomain adbd:process sigchld;

# child shell or gdbserver pty access for runas.
allow appdomain devpts:chr_file { getattr read write ioctl };

# Use pipes and sockets provided by system_server via binder or local socket.
allow appdomain system_server:fd use;
allow appdomain system_server:fifo_file { { getattr open read ioctl lock map } { open append write lock map } };
allow appdomain system_server:unix_stream_socket { read write setopt getattr getopt shutdown };
allow appdomain system_server:tcp_socket { read write getattr getopt shutdown };

# Communication with other apps via fifos
allow appdomain appdomain:fifo_file { { getattr open read ioctl lock map } { open append write lock map } };

# Communicate with surfaceflinger.
allow appdomain surfaceflinger:unix_stream_socket { read write setopt getattr getopt shutdown };

# App sandbox file accesses.
allow { appdomain -isolated_app } app_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow { appdomain -isolated_app } app_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Traverse into expanded storage
allow appdomain mnt_expand_file:dir { open getattr read search ioctl lock };

# Keychain and user-trusted credentials

#line 80
allow appdomain keychain_data_file:dir { open getattr read search ioctl lock };
#line 80
allow appdomain keychain_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 80

allow appdomain misc_user_data_file:dir { open getattr read search ioctl lock };
allow appdomain misc_user_data_file:file { getattr open read ioctl lock map };

# TextClassifier

#line 85
allow { appdomain -isolated_app } textclassifier_data_file:dir { open getattr read search ioctl lock };
#line 85
allow { appdomain -isolated_app } textclassifier_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 85


# Access to OEM provided data and apps
allow appdomain oemfs:dir { open getattr read search ioctl lock };
allow appdomain oemfs:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Execute the shell or other system executables.
allow { appdomain -ephemeral_app -untrusted_v2_app } shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow { appdomain -ephemeral_app -untrusted_v2_app } toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow { appdomain -ephemeral_app -untrusted_v2_app } system_file:file { getattr execute execute_no_trans map };
allow { appdomain -ephemeral_app -untrusted_v2_app } vendor_file:file { getattr execute execute_no_trans map };

# Renderscript needs the ability to read directories on /system
allow appdomain system_file:dir { open getattr read search ioctl lock };
allow appdomain system_file:lnk_file { getattr open read };
# Renderscript specific permissions to open /system/vendor/lib64.

#line 101
    allow appdomain vendor_file_type:dir { open getattr read search ioctl lock };
#line 101
    allow appdomain vendor_file_type:lnk_file { getattr open read };
#line 104


# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 106

#line 106
    # For looking up Renderscript vendor drivers
#line 106
    allow { appdomain -isolated_app } vendor_file:dir { open read };
#line 106

#line 106
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 109


# Allow apps access to /vendor/app except for privileged
# apps which cannot be in /vendor.

#line 113
allow { appdomain -ephemeral_app -untrusted_v2_app } vendor_app_file:dir { open getattr read search ioctl lock };
#line 113
allow { appdomain -ephemeral_app -untrusted_v2_app } vendor_app_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 113

allow { appdomain -ephemeral_app -untrusted_v2_app } vendor_app_file:file execute;

# Allow apps access to /vendor/overlay

#line 117
allow appdomain vendor_overlay_file:dir { open getattr read search ioctl lock };
#line 117
allow appdomain vendor_overlay_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 117


# Allow apps access to /vendor/framework
# for vendor provided libraries.

#line 121
allow appdomain vendor_framework_file:dir { open getattr read search ioctl lock };
#line 121
allow appdomain vendor_framework_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 121


# Execute dex2oat when apps call dexclassloader
allow appdomain dex2oat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Read/write wallpaper file (opened by system).
allow appdomain wallpaper_file:file { getattr read write };

# Read/write cached ringtones (opened by system).
allow appdomain ringtone_file:file { getattr read write };

# Read ShortcutManager icon files (opened by system).
allow appdomain shortcut_manager_icons:file { getattr read };

# Read icon file (opened by system).
allow appdomain icon_file:file { getattr read };

# Old stack dumping scheme : append to a global trace file (/data/anr/traces.txt).
#
# TODO: All of these permissions except for anr_data_file:file append can be
# withdrawn once we've switched to the new stack dumping mechanism, see b/32064548
# and the rules below.
allow appdomain anr_data_file:dir search;
allow appdomain anr_data_file:file { open append };

# New stack dumping scheme : request an output FD from tombstoned via a unix
# domain socket.
#
# Allow apps to connect and write to the tombstoned java trace socket in
# order to dump their traces. Also allow them to append traces to pipes
# created by dumptrace. (Also see the rules below where they are given
# additional permissions to dumpstate pipes for other aspects of bug report
# creation).

#line 154

#line 154

#line 154
allow appdomain tombstoned_java_trace_socket:sock_file write;
#line 154
allow appdomain tombstoned:unix_stream_socket connectto;
#line 154

#line 154

allow appdomain tombstoned:fd use;
allow appdomain dumpstate:fifo_file append;

# Allow apps to send dump information to dumpstate
allow appdomain dumpstate:fd use;
allow appdomain dumpstate:unix_stream_socket { read write getopt getattr shutdown };
allow appdomain dumpstate:fifo_file { write getattr };
allow appdomain shell_data_file:file { write getattr };

# Write profiles /data/misc/profiles
allow appdomain user_profile_data_file:dir { search write add_name };
allow appdomain user_profile_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Send heap dumps to system_server via an already open file descriptor
# % adb shell am set-watch-heap com.android.systemui 1048576
# % adb shell dumpsys procstats --start-testing
# debuggable builds only.

#line 172
  allow appdomain heapdump_data_file:file append;
#line 174


# Write to /proc/net/xt_qtaguid/ctrl file.
allow appdomain qtaguid_proc:file { { getattr open read ioctl lock map } { open append write lock map } };
# read /proc/net/xt_qtguid/stats

#line 179
allow { appdomain -ephemeral_app} proc_net:dir { open getattr read search ioctl lock };
#line 179
allow { appdomain -ephemeral_app} proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 179

# Everybody can read the xt_qtaguid resource tracking misc dev.
# So allow all apps to read from /dev/xt_qtaguid.
allow appdomain qtaguid_device:chr_file { getattr open read ioctl lock map };

# Grant GPU access to all processes started by Zygote.
# They need that to render the standard UI.
allow { appdomain -isolated_app } gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Use the Binder.

#line 189
# Call the servicemanager and transfer references to it.
#line 189
allow appdomain servicemanager:binder { call transfer };
#line 189
# servicemanager performs getpidcon on clients.
#line 189
allow servicemanager appdomain:dir search;
#line 189
allow servicemanager appdomain:file { read open };
#line 189
allow servicemanager appdomain:process getattr;
#line 189
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 189
# all domains in domain.te.
#line 189

# Perform binder IPC to binder services.

#line 191
# Call the server domain and optionally transfer references to it.
#line 191
allow appdomain binderservicedomain:binder { call transfer };
#line 191
# Allow the serverdomain to transfer references to the client on the reply.
#line 191
allow binderservicedomain appdomain:binder transfer;
#line 191
# Receive and use open files from the server.
#line 191
allow appdomain binderservicedomain:fd use;
#line 191

# Perform binder IPC to other apps.

#line 193
# Call the server domain and optionally transfer references to it.
#line 193
allow appdomain appdomain:binder { call transfer };
#line 193
# Allow the serverdomain to transfer references to the client on the reply.
#line 193
allow appdomain appdomain:binder transfer;
#line 193
# Receive and use open files from the server.
#line 193
allow appdomain appdomain:fd use;
#line 193

# Perform binder IPC to ephemeral apps.

#line 195
# Call the server domain and optionally transfer references to it.
#line 195
allow appdomain ephemeral_app:binder { call transfer };
#line 195
# Allow the serverdomain to transfer references to the client on the reply.
#line 195
allow ephemeral_app appdomain:binder transfer;
#line 195
# Receive and use open files from the server.
#line 195
allow appdomain ephemeral_app:fd use;
#line 195


# TODO(b/36375899): Replace this with hal_client_domain once mediacodec is properly attributized
# as OMX HAL

#line 199
# Call the hwservicemanager and transfer references to it.
#line 199
allow { appdomain  -isolated_app } hwservicemanager:binder { call transfer };
#line 199
# Allow hwservicemanager to send out callbacks
#line 199
allow hwservicemanager { appdomain  -isolated_app }:binder { call transfer };
#line 199
# hwservicemanager performs getpidcon on clients.
#line 199
allow hwservicemanager { appdomain  -isolated_app }:dir search;
#line 199
allow hwservicemanager { appdomain  -isolated_app }:file { read open };
#line 199
allow hwservicemanager { appdomain  -isolated_app }:process getattr;
#line 199
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 199
# all domains in domain.te.
#line 199

allow { appdomain -isolated_app } hal_omx_hwservice:hwservice_manager find;
allow { appdomain -isolated_app } hidl_token_hwservice:hwservice_manager find;

# Talk with graphics composer fences
allow appdomain hal_graphics_composer:fd use;

# Already connected, unnamed sockets being passed over some other IPC
# hence no sock_file or connectto permission. This appears to be how
# Chrome works, may need to be updated as more apps using isolated services
# are examined.
allow appdomain appdomain:unix_stream_socket { getopt getattr read write shutdown };

# Backup ability for every app. BMS opens and passes the fd
# to any app that has backup ability. Hence, no open permissions here.
allow appdomain backup_data_file:file { read write getattr };
allow appdomain cache_backup_file:file { read write getattr };
allow appdomain cache_backup_file:dir getattr;
# Backup ability using 'adb backup'
allow appdomain system_data_file:lnk_file { getattr open read ioctl lock map };
allow appdomain system_data_file:file { getattr read };

# Allow read/stat of /data/media files passed by Binder or local socket IPC.
allow { appdomain -isolated_app } media_rw_data_file:file { read getattr };

# Read and write /data/data/com.android.providers.telephony files passed over Binder.
allow { appdomain -isolated_app } radio_data_file:file { read write getattr };

# Allow access to external storage; we have several visible mount points under /storage
# and symlinks to primary storage at places like /storage/sdcard0 and /mnt/user/0/primary
allow { appdomain -isolated_app -ephemeral_app } storage_file:dir { open getattr read search ioctl lock };
allow { appdomain -isolated_app -ephemeral_app } storage_file:lnk_file { getattr open read ioctl lock map };
allow { appdomain -isolated_app -ephemeral_app } mnt_user_file:dir { open getattr read search ioctl lock };
allow { appdomain -isolated_app -ephemeral_app } mnt_user_file:lnk_file { getattr open read ioctl lock map };

# Read/write visible storage
allow { appdomain -isolated_app -ephemeral_app } fuse:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow { appdomain -isolated_app -ephemeral_app } fuse:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow { appdomain -isolated_app -ephemeral_app } sdcardfs:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow { appdomain -isolated_app -ephemeral_app } sdcardfs:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
# This should be removed if sdcardfs is modified to alter the secontext for its
# accesses to the underlying FS.
allow { appdomain -isolated_app -ephemeral_app } { media_rw_data_file vfat }:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow { appdomain -isolated_app -ephemeral_app } { media_rw_data_file vfat }:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access OBBs (vfat images) mounted by vold (b/17633509)
# File write access allowed for FDs returned through Storage Access Framework
allow { appdomain -isolated_app -ephemeral_app } vfat:dir { open getattr read search ioctl lock };
allow { appdomain -isolated_app -ephemeral_app } vfat:file { { getattr open read ioctl lock map } { open append write lock map } };

# Allow apps to use the USB Accessory interface.
# http://developer.android.com/guide/topics/connectivity/usb/accessory.html
#
# USB devices are first opened by the system server (USBDeviceManagerService)
# and the file descriptor is passed to the right Activity via binder.
allow { appdomain -isolated_app -ephemeral_app } usb_device:chr_file { read write getattr ioctl };
allow { appdomain -isolated_app -ephemeral_app } usbaccessory_device:chr_file { read write getattr };

# For art.
allow appdomain dalvikcache_data_file:file execute;
allow appdomain dalvikcache_data_file:lnk_file { getattr open read ioctl lock map };

# Allow any app to read shared RELRO files.
allow appdomain shared_relro_file:dir search;
allow appdomain shared_relro_file:file { getattr open read ioctl lock map };

# Allow apps to read/execute installed binaries
allow appdomain apk_data_file:dir { open getattr read search ioctl lock };
allow appdomain apk_data_file:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# /data/resource-cache
allow appdomain resourcecache_data_file:file { getattr open read ioctl lock map };
allow appdomain resourcecache_data_file:dir { open getattr read search ioctl lock };

# logd access

#line 274
allow appdomain logcat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 274

#line 274

#line 274

#line 274
allow appdomain logdr_socket:sock_file write;
#line 274
allow appdomain logd:unix_stream_socket connectto;
#line 274

#line 274

#line 274


#line 275
# Group AID_LOG checked by filesystem & logd
#line 275
# to permit control commands
#line 275

#line 275

#line 275

#line 275
allow { appdomain -ephemeral_app untrusted_v2_app } logd_socket:sock_file write;
#line 275
allow { appdomain -ephemeral_app untrusted_v2_app } logd:unix_stream_socket connectto;
#line 275

#line 275

#line 275

# application inherit logd write socket (urge is to deprecate this long term)
allow appdomain zygote:unix_dgram_socket write;

allow { appdomain -isolated_app -ephemeral_app } keystore:keystore_key { get_state get insert delete exist list sign verify };


#line 281
  allow keystore { appdomain -isolated_app -ephemeral_app }:dir search;
#line 281
  allow keystore { appdomain -isolated_app -ephemeral_app }:file { read open };
#line 281
  allow keystore { appdomain -isolated_app -ephemeral_app }:process getattr;
#line 281
  allow { appdomain -isolated_app -ephemeral_app } keystore_service:service_manager find;
#line 281
  
#line 281
# Call the server domain and optionally transfer references to it.
#line 281
allow { appdomain -isolated_app -ephemeral_app } keystore:binder { call transfer };
#line 281
# Allow the serverdomain to transfer references to the client on the reply.
#line 281
allow keystore { appdomain -isolated_app -ephemeral_app }:binder transfer;
#line 281
# Receive and use open files from the server.
#line 281
allow { appdomain -isolated_app -ephemeral_app } keystore:fd use;
#line 281

#line 281


allow appdomain console_device:chr_file { read write };

# only allow unprivileged socket ioctl commands
allowxperm { appdomain -bluetooth } self:{ rawip_socket tcp_socket udp_socket }
  ioctl { 
#line 287
{
#line 287
# Socket ioctls for gathering information about the interface
#line 287
0x00008906 0x00008907
#line 287
0x00008910 0x00008912 0x00008913 0x00008915 0x00008917 0x00008919
#line 287
0x0000891b 0x00008921 0x00008933 0x00008938 0x00008942
#line 287
# Wireless extension ioctls. Primarily get functions.
#line 287
0x00008b01 0x00008b05 0x00008b07 0x00008b09 0x00008b0b 0x00008b0d
#line 287
0x00008b0f 0x00008b11 0x00008b12 0x00008b13 0x00008b21 0x00008b23
#line 287
0x00008b25 0x00008b27 0x00008b29 0x00008b2d
#line 287
} {
#line 287
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 287
  0x0000540b 0x00005410 0x0000540f
#line 287
} };

allow { appdomain -isolated_app } ion_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
# TODO is write really necessary ?
auditallow { appdomain -su } ion_device:chr_file { write append };

# TODO(b/36375899) replace with hal_client_domain for mediacodec (hal_omx)

#line 294
allow { appdomain -isolated_app } hwservicemanager_prop:file { getattr open read ioctl lock map };
#line 294
;

# Allow app access to mediacodec (IOMX HAL)

#line 297
# Call the server domain and optionally transfer references to it.
#line 297
allow { appdomain -isolated_app } mediacodec:binder { call transfer };
#line 297
# Allow the serverdomain to transfer references to the client on the reply.
#line 297
allow mediacodec { appdomain -isolated_app }:binder transfer;
#line 297
# Receive and use open files from the server.
#line 297
allow { appdomain -isolated_app } mediacodec:fd use;
#line 297


# Allow AAudio apps to use shared memory file descriptors from the HAL
allow { appdomain -isolated_app } hal_audio:fd use;

# Allow app to access shared memory created by camera HAL1
allow { appdomain -isolated_app } hal_camera:fd use;

# RenderScript always-passthrough HAL
allow { appdomain -isolated_app } hal_renderscript_hwservice:hwservice_manager find;

# TODO: switch to meminfo service
allow appdomain proc_meminfo:file { getattr open read ioctl lock map };

# For app fuse.
allow appdomain app_fuse_file:file { getattr read append write };


#line 314

#line 314
# Allow client to open the service endpoint file.
#line 314
allow { appdomain -isolated_app -ephemeral_app } pdx_display_client_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 314
allow { appdomain -isolated_app -ephemeral_app } pdx_display_client_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 314
# Allow the client to connect to endpoint socket.
#line 314
allow { appdomain -isolated_app -ephemeral_app } pdx_display_client_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 314

#line 314

#line 314
# Allow the client to use the PDX channel socket.
#line 314
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 314
# than we need (e.g. we don"t need "bind" or "connect").
#line 314
allow { appdomain -isolated_app -ephemeral_app } pdx_display_client_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 314
# Client needs to use an channel event fd from the server.
#line 314
allow { appdomain -isolated_app -ephemeral_app } pdx_display_client_server_type:fd use;
#line 314
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 314
# This could be tightened on a per-server basis, but keeping track of service
#line 314
# clients is error prone.
#line 314
allow pdx_display_client_server_type { appdomain -isolated_app -ephemeral_app }:fd use;
#line 314

#line 314


#line 315

#line 315
# Allow client to open the service endpoint file.
#line 315
allow { appdomain -isolated_app -ephemeral_app } pdx_display_manager_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 315
allow { appdomain -isolated_app -ephemeral_app } pdx_display_manager_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 315
# Allow the client to connect to endpoint socket.
#line 315
allow { appdomain -isolated_app -ephemeral_app } pdx_display_manager_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 315

#line 315

#line 315
# Allow the client to use the PDX channel socket.
#line 315
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 315
# than we need (e.g. we don"t need "bind" or "connect").
#line 315
allow { appdomain -isolated_app -ephemeral_app } pdx_display_manager_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 315
# Client needs to use an channel event fd from the server.
#line 315
allow { appdomain -isolated_app -ephemeral_app } pdx_display_manager_server_type:fd use;
#line 315
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 315
# This could be tightened on a per-server basis, but keeping track of service
#line 315
# clients is error prone.
#line 315
allow pdx_display_manager_server_type { appdomain -isolated_app -ephemeral_app }:fd use;
#line 315

#line 315


#line 316

#line 316
# Allow client to open the service endpoint file.
#line 316
allow { appdomain -isolated_app -ephemeral_app } pdx_display_vsync_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 316
allow { appdomain -isolated_app -ephemeral_app } pdx_display_vsync_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 316
# Allow the client to connect to endpoint socket.
#line 316
allow { appdomain -isolated_app -ephemeral_app } pdx_display_vsync_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 316

#line 316

#line 316
# Allow the client to use the PDX channel socket.
#line 316
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 316
# than we need (e.g. we don"t need "bind" or "connect").
#line 316
allow { appdomain -isolated_app -ephemeral_app } pdx_display_vsync_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 316
# Client needs to use an channel event fd from the server.
#line 316
allow { appdomain -isolated_app -ephemeral_app } pdx_display_vsync_server_type:fd use;
#line 316
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 316
# This could be tightened on a per-server basis, but keeping track of service
#line 316
# clients is error prone.
#line 316
allow pdx_display_vsync_server_type { appdomain -isolated_app -ephemeral_app }:fd use;
#line 316

#line 316


#line 317

#line 317
# Allow client to open the service endpoint file.
#line 317
allow { appdomain -isolated_app -ephemeral_app } pdx_performance_client_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 317
allow { appdomain -isolated_app -ephemeral_app } pdx_performance_client_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 317
# Allow the client to connect to endpoint socket.
#line 317
allow { appdomain -isolated_app -ephemeral_app } pdx_performance_client_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 317

#line 317

#line 317
# Allow the client to use the PDX channel socket.
#line 317
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 317
# than we need (e.g. we don"t need "bind" or "connect").
#line 317
allow { appdomain -isolated_app -ephemeral_app } pdx_performance_client_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 317
# Client needs to use an channel event fd from the server.
#line 317
allow { appdomain -isolated_app -ephemeral_app } pdx_performance_client_server_type:fd use;
#line 317
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 317
# This could be tightened on a per-server basis, but keeping track of service
#line 317
# clients is error prone.
#line 317
allow pdx_performance_client_server_type { appdomain -isolated_app -ephemeral_app }:fd use;
#line 317

#line 317

# Apps do not directly open the IPC socket for bufferhubd.

#line 319
# Allow the client to use the PDX channel socket.
#line 319
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 319
# than we need (e.g. we don"t need "bind" or "connect").
#line 319
allow { appdomain -isolated_app -ephemeral_app } pdx_bufferhub_client_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 319
# Client needs to use an channel event fd from the server.
#line 319
allow { appdomain -isolated_app -ephemeral_app } pdx_bufferhub_client_server_type:fd use;
#line 319
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 319
# This could be tightened on a per-server basis, but keeping track of service
#line 319
# clients is error prone.
#line 319
allow pdx_bufferhub_client_server_type { appdomain -isolated_app -ephemeral_app }:fd use;
#line 319


###
### CTS-specific rules
###

# For cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java.
# testRunAsHasCorrectCapabilities
allow appdomain runas_exec:file getattr;
# Others are either allowed elsewhere or not desired.

# Apps receive an open tun fd from the framework for
# device traffic. Do not allow untrusted app to directly open tun_device
allow { appdomain -isolated_app -ephemeral_app } tun_device:chr_file { read write getattr ioctl append };

# Connect to adbd and use a socket transferred from it.
# This is used for e.g. adb backup/restore.
allow appdomain adbd:unix_stream_socket connectto;
allow appdomain adbd:fd use;
allow appdomain adbd:unix_stream_socket { getattr getopt ioctl read write shutdown };

allow appdomain cache_file:dir getattr;

# Allow apps to run with asanwrapper.


###
### Neverallow rules
###
### These are things that Android apps should NEVER be able to do
###

# Superuser capabilities.
# bluetooth requires net_admin and wake_alarm.
neverallow { appdomain -bluetooth } self:capability *;
neverallow { appdomain -bluetooth } self:capability2 *;

# Block device access.
neverallow appdomain dev_type:blk_file { read write };

# Access to any of the following character devices.
neverallow appdomain {
    audio_device
    camera_device
    dm_device
    radio_device
    rpmsg_device
    video_device
}:chr_file { read write };

# Note: Try expanding list of app domains in the future.
neverallow { untrusted_app isolated_app shell } graphics_device:chr_file { read write };

neverallow { appdomain -nfc } nfc_device:chr_file
    { read write };
neverallow { appdomain -bluetooth } hci_attach_dev:chr_file
    { read write };
neverallow appdomain tee_device:chr_file { read write };

# Privileged netlink socket interfaces.
neverallow appdomain
    domain:{
        netlink_tcpdiag_socket
        netlink_nflog_socket
        netlink_xfrm_socket
        netlink_audit_socket
        netlink_dnrt_socket
    } *;

# These messages are broadcast messages from the kernel to userspace.
# Do not allow the writing of netlink messages, which has been a source
# of rooting vulns in the past.
neverallow appdomain domain:netlink_kobject_uevent_socket { write append };

# Sockets under /dev/socket that are not specifically typed.
neverallow appdomain socket_device:sock_file write;

# Unix domain sockets.
neverallow appdomain adbd_socket:sock_file write;
neverallow { appdomain -radio } rild_socket:sock_file write;
neverallow appdomain vold_socket:sock_file write;
neverallow appdomain zygote_socket:sock_file write;

# ptrace access to non-app domains.
neverallow appdomain { domain -appdomain }:process ptrace;

# Write access to /proc/pid entries for any non-app domain.
neverallow appdomain { domain -appdomain }:file write;

# signal access to non-app domains.
# sigchld allowed for parent death notification.
# signull allowed for kill(pid, 0) existence test.
# All others prohibited.
neverallow appdomain { domain -appdomain }:process
    { sigkill sigstop signal };

# Transition to a non-app domain.
# Exception for the shell and su domains, can transition to runas, etc.
# Exception for crash_dump.
neverallow { appdomain -shell -su } { domain -appdomain -crash_dump }:process
    { transition };
neverallow { appdomain -shell -su } { domain -appdomain }:process
    { dyntransition };

# Write to rootfs.
neverallow appdomain rootfs:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to /system.
neverallow appdomain system_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to entrypoint executables.
neverallow appdomain exec_type:file
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to system-owned parts of /data.
# This is the default type for anything under /data not otherwise
# specified in file_contexts.  Define a different type for portions
# that should be writable by apps.
neverallow appdomain system_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# Write to various other parts of /data.
neverallow appdomain drm_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_tmp_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_private_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -platform_app }
    apk_private_tmp_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -shell }
    shell_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create setattr relabelfrom relabelto append unlink link rename };
neverallow { appdomain -bluetooth }
    bluetooth_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    keystore_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    systemkeys_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    wifi_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };
neverallow appdomain
    dhcp_data_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } }
    { create write setattr relabelfrom relabelto append unlink link rename };

# access tmp apk files
neverallow { appdomain -untrusted_app_all -platform_app -priv_app }
    { apk_tmp_file apk_private_tmp_file }:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } *;

neverallow untrusted_app_all { apk_tmp_file apk_private_tmp_file }:{ { chr_file blk_file } dir fifo_file lnk_file sock_file } *;
neverallow untrusted_app_all { apk_tmp_file apk_private_tmp_file }:file ~{ getattr read };

# Access to factory files.
neverallow appdomain efs_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
neverallow { appdomain -shell } efs_file:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } read;

# Write to various pseudo file systems.
neverallow { appdomain -bluetooth -nfc }
    sysfs:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;
neverallow appdomain
    proc:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } write;

# Access to syslog(2) or /proc/kmsg.
neverallow appdomain kernel:system { syslog_read syslog_mod syslog_console };

# SELinux is not an API for apps to use
neverallow { appdomain -shell } *:security { compute_av check_context };
neverallow { appdomain -shell } *:netlink_selinux_socket *;

# Ability to perform any filesystem operation other than statfs(2).
# i.e. no mount(2), unmount(2), etc.
neverallow appdomain fs_type:filesystem ~getattr;

# prevent creation/manipulation of globally readable symlinks
neverallow appdomain {
  apk_data_file
  cache_file
  cache_recovery_file
  dev_type
  rootfs
  system_file
  tmpfs
}:lnk_file { append create link unlink relabelfrom rename setattr write };

# Blacklist app domains not allowed to execute from /data
neverallow {
  bluetooth
  isolated_app
  nfc
  radio
  shared_relro
  system_app
} {
  data_file_type
  -dalvikcache_data_file
  -system_data_file # shared libs in apks
  -apk_data_file
}:file { execute execute_no_trans };

# Applications should use the activity model for receiving events
neverallow {
  appdomain
  -shell # bugreport
} input_device:chr_file ~getattr;

# Do not allow access to Bluetooth-related system properties except for a few whitelisted domains.
# neverallow rules for access to Bluetooth-related data files are above.
neverallow {
  appdomain
  -bluetooth
  -system_app
} bluetooth_prop:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 1 "system/sepolicy/private/app_neverallows.te"
###
### neverallow rules for untrusted app domains
###

#line 13

# Receive or send uevent messages.
neverallow {
#line 15
  ephemeral_app
#line 15
  isolated_app
#line 15
  mediaprovider
#line 15
  untrusted_app
#line 15
  untrusted_app_25
#line 15
  untrusted_app_all
#line 15
  untrusted_v2_app
#line 15
} domain:netlink_kobject_uevent_socket *;

# Receive or send generic netlink messages
neverallow {
#line 18
  ephemeral_app
#line 18
  isolated_app
#line 18
  mediaprovider
#line 18
  untrusted_app
#line 18
  untrusted_app_25
#line 18
  untrusted_app_all
#line 18
  untrusted_v2_app
#line 18
} domain:netlink_socket *;

# Too much leaky information in debugfs. It's a security
# best practice to ensure these files aren't readable.
neverallow {
#line 22
  ephemeral_app
#line 22
  isolated_app
#line 22
  mediaprovider
#line 22
  untrusted_app
#line 22
  untrusted_app_25
#line 22
  untrusted_app_all
#line 22
  untrusted_v2_app
#line 22
} debugfs_type:file read;

# Do not allow untrusted apps to register services.
# Only trusted components of Android should be registering
# services.
neverallow {
#line 27
  ephemeral_app
#line 27
  isolated_app
#line 27
  mediaprovider
#line 27
  untrusted_app
#line 27
  untrusted_app_25
#line 27
  untrusted_app_all
#line 27
  untrusted_v2_app
#line 27
} service_manager_type:service_manager add;

# Do not allow untrusted apps to use VendorBinder
neverallow {
#line 30
  ephemeral_app
#line 30
  isolated_app
#line 30
  mediaprovider
#line 30
  untrusted_app
#line 30
  untrusted_app_25
#line 30
  untrusted_app_all
#line 30
  untrusted_v2_app
#line 30
} vndbinder_device:chr_file *;
neverallow {
#line 31
  ephemeral_app
#line 31
  isolated_app
#line 31
  mediaprovider
#line 31
  untrusted_app
#line 31
  untrusted_app_25
#line 31
  untrusted_app_all
#line 31
  untrusted_v2_app
#line 31
} vndservice_manager_type:service_manager *;

# Do not allow untrusted apps to connect to the property service
# or set properties. b/10243159
neverallow { {
#line 35
  ephemeral_app
#line 35
  isolated_app
#line 35
  mediaprovider
#line 35
  untrusted_app
#line 35
  untrusted_app_25
#line 35
  untrusted_app_all
#line 35
  untrusted_v2_app
#line 35
} -mediaprovider } property_socket:sock_file write;
neverallow { {
#line 36
  ephemeral_app
#line 36
  isolated_app
#line 36
  mediaprovider
#line 36
  untrusted_app
#line 36
  untrusted_app_25
#line 36
  untrusted_app_all
#line 36
  untrusted_v2_app
#line 36
} -mediaprovider } init:unix_stream_socket connectto;
neverallow { {
#line 37
  ephemeral_app
#line 37
  isolated_app
#line 37
  mediaprovider
#line 37
  untrusted_app
#line 37
  untrusted_app_25
#line 37
  untrusted_app_all
#line 37
  untrusted_v2_app
#line 37
} -mediaprovider } property_type:property_service set;

# Do not allow untrusted apps to be assigned mlstrustedsubject.
# This would undermine the per-user isolation model being
# enforced via levelFrom=user in seapp_contexts and the mls
# constraints.  As there is no direct way to specify a neverallow
# on attribute assignment, this relies on the fact that fork
# permission only makes sense within a domain (hence should
# never be granted to any other domain within mlstrustedsubject)
# and an untrusted app is allowed fork permission to itself.
neverallow {
#line 47
  ephemeral_app
#line 47
  isolated_app
#line 47
  mediaprovider
#line 47
  untrusted_app
#line 47
  untrusted_app_25
#line 47
  untrusted_app_all
#line 47
  untrusted_v2_app
#line 47
} mlstrustedsubject:process fork;

# Do not allow untrusted apps to hard link to any files.
# In particular, if an untrusted app links to other app data
# files, installd will not be able to guarantee the deletion
# of the linked to file. Hard links also contribute to security
# bugs, so we want to ensure untrusted apps never have this
# capability.
neverallow {
#line 55
  ephemeral_app
#line 55
  isolated_app
#line 55
  mediaprovider
#line 55
  untrusted_app
#line 55
  untrusted_app_25
#line 55
  untrusted_app_all
#line 55
  untrusted_v2_app
#line 55
} file_type:file link;

# Do not allow untrusted apps to access network MAC address file
neverallow {
#line 58
  ephemeral_app
#line 58
  isolated_app
#line 58
  mediaprovider
#line 58
  untrusted_app
#line 58
  untrusted_app_25
#line 58
  untrusted_app_all
#line 58
  untrusted_v2_app
#line 58
} sysfs_mac_address:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Restrict socket ioctls. Either 1. disallow privileged ioctls, 2. disallow the
# ioctl permission, or 3. disallow the socket class.
neverallowxperm {
#line 62
  ephemeral_app
#line 62
  isolated_app
#line 62
  mediaprovider
#line 62
  untrusted_app
#line 62
  untrusted_app_25
#line 62
  untrusted_app_all
#line 62
  untrusted_v2_app
#line 62
} domain:{ rawip_socket tcp_socket udp_socket } ioctl 
#line 62
{
#line 62
# qualcomm rmnet ioctls
#line 62
0x00006900 0x00006902
#line 62
# socket ioctls
#line 62
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 62
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 62
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 62
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 62
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 62
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 62
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 62
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 62
0x00008991 0x00008992 0x00008993 0x00008994
#line 62
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 62
# device and protocol specific ioctls
#line 62
0x000089f0-0x000089ff
#line 62
0x000089e0-0x000089ef
#line 62
# Wireless extension ioctls
#line 62
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 62
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 62
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 62
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 62
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 62
0x00008b34 0x00008b35 0x00008b36
#line 62
# Dev private ioctl i.e. hardware specific ioctls
#line 62
0x00008be0-0x00008bff
#line 62
};
neverallow {
#line 63
  ephemeral_app
#line 63
  isolated_app
#line 63
  mediaprovider
#line 63
  untrusted_app
#line 63
  untrusted_app_25
#line 63
  untrusted_app_all
#line 63
  untrusted_v2_app
#line 63
} *:{ netlink_route_socket netlink_selinux_socket } ioctl;
neverallow {
#line 64
  ephemeral_app
#line 64
  isolated_app
#line 64
  mediaprovider
#line 64
  untrusted_app
#line 64
  untrusted_app_25
#line 64
  untrusted_app_all
#line 64
  untrusted_v2_app
#line 64
} *:{
  socket netlink_socket packet_socket key_socket appletalk_socket
  netlink_tcpdiag_socket netlink_nflog_socket
  netlink_xfrm_socket netlink_audit_socket
  netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket
  netlink_iscsi_socket netlink_fib_lookup_socket netlink_connector_socket
  netlink_netfilter_socket netlink_generic_socket netlink_scsitransport_socket
  netlink_rdma_socket netlink_crypto_socket
} *;

# Do not allow untrusted apps access to /cache
neverallow { {
#line 75
  ephemeral_app
#line 75
  isolated_app
#line 75
  mediaprovider
#line 75
  untrusted_app
#line 75
  untrusted_app_25
#line 75
  untrusted_app_all
#line 75
  untrusted_v2_app
#line 75
} -mediaprovider } { cache_file cache_recovery_file }:dir ~{ { open getattr read search ioctl lock } };
neverallow { {
#line 76
  ephemeral_app
#line 76
  isolated_app
#line 76
  mediaprovider
#line 76
  untrusted_app
#line 76
  untrusted_app_25
#line 76
  untrusted_app_all
#line 76
  untrusted_v2_app
#line 76
} -mediaprovider } { cache_file cache_recovery_file }:file ~{ read getattr };

# Do not allow untrusted apps to create/unlink files outside of its sandbox,
# internal storage or sdcard.
# World accessible data locations allow application to fill the device
# with unaccounted for data. This data will not get removed during
# application un-installation.
neverallow { {
#line 83
  ephemeral_app
#line 83
  isolated_app
#line 83
  mediaprovider
#line 83
  untrusted_app
#line 83
  untrusted_app_25
#line 83
  untrusted_app_all
#line 83
  untrusted_v2_app
#line 83
} -mediaprovider } {
  fs_type
  -fuse                     # sdcard
  -sdcardfs                 # sdcard
  -vfat
  file_type
  -app_data_file            # The apps sandbox itself
  -media_rw_data_file       # Internal storage. Known that apps can
                            # leave artfacts here after uninstall.
  -user_profile_data_file   # Access to profile files
  
#line 93
    -method_trace_data_file # only on ro.debuggable=1
#line 93
    -coredump_file          # userdebug/eng only
#line 93
  
#line 97
}:{ dir { { chr_file blk_file } { file lnk_file sock_file fifo_file } } } { create unlink };

# No untrusted component should be touching /dev/fuse
neverallow {
#line 100
  ephemeral_app
#line 100
  isolated_app
#line 100
  mediaprovider
#line 100
  untrusted_app
#line 100
  untrusted_app_25
#line 100
  untrusted_app_all
#line 100
  untrusted_v2_app
#line 100
} fuse_device:chr_file *;

# Do not allow untrusted apps to directly open tun_device
neverallow {
#line 103
  ephemeral_app
#line 103
  isolated_app
#line 103
  mediaprovider
#line 103
  untrusted_app
#line 103
  untrusted_app_25
#line 103
  untrusted_app_all
#line 103
  untrusted_v2_app
#line 103
} tun_device:chr_file open;

# Only allow appending to /data/anr/traces.txt (b/27853304, b/18340553)
neverallow {
#line 106
  ephemeral_app
#line 106
  isolated_app
#line 106
  mediaprovider
#line 106
  untrusted_app
#line 106
  untrusted_app_25
#line 106
  untrusted_app_all
#line 106
  untrusted_v2_app
#line 106
} anr_data_file:file ~{ open append };
neverallow {
#line 107
  ephemeral_app
#line 107
  isolated_app
#line 107
  mediaprovider
#line 107
  untrusted_app
#line 107
  untrusted_app_25
#line 107
  untrusted_app_all
#line 107
  untrusted_v2_app
#line 107
} anr_data_file:dir ~search;

# Avoid reads from generically labeled /proc files
# Create a more specific label if needed
neverallow {
#line 111
  ephemeral_app
#line 111
  isolated_app
#line 111
  mediaprovider
#line 111
  untrusted_app
#line 111
  untrusted_app_25
#line 111
  untrusted_app_all
#line 111
  untrusted_v2_app
#line 111
} proc:file { { { append create link unlink relabelfrom rename setattr write } open read ioctl lock } { execute execute_no_trans } };

# Avoid all access to kernel configuration
neverallow {
#line 114
  ephemeral_app
#line 114
  isolated_app
#line 114
  mediaprovider
#line 114
  untrusted_app
#line 114
  untrusted_app_25
#line 114
  untrusted_app_all
#line 114
  untrusted_v2_app
#line 114
} config_gz:file { { { append create link unlink relabelfrom rename setattr write } open read ioctl lock } { execute execute_no_trans } };

# Do not allow untrusted apps access to preloads data files
neverallow {
#line 117
  ephemeral_app
#line 117
  isolated_app
#line 117
  mediaprovider
#line 117
  untrusted_app
#line 117
  untrusted_app_25
#line 117
  untrusted_app_all
#line 117
  untrusted_v2_app
#line 117
} preloads_data_file:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Locking of files on /system could lead to denial of service attacks
# against privileged system components
neverallow {
#line 121
  ephemeral_app
#line 121
  isolated_app
#line 121
  mediaprovider
#line 121
  untrusted_app
#line 121
  untrusted_app_25
#line 121
  untrusted_app_all
#line 121
  untrusted_v2_app
#line 121
} system_file:file lock;

# Do not permit untrusted apps to perform actions on HwBinder service_manager
# other than find actions for services listed below
neverallow {
#line 125
  ephemeral_app
#line 125
  isolated_app
#line 125
  mediaprovider
#line 125
  untrusted_app
#line 125
  untrusted_app_25
#line 125
  untrusted_app_all
#line 125
  untrusted_v2_app
#line 125
} *:hwservice_manager ~find;

# Do not permit access from apps which host arbitrary code to HwBinder services,
# except those considered sufficiently safe for access from such apps.
# The two main reasons for this are:
# 1. HwBinder servers do not perform client authentication because HIDL
#    currently does not expose caller UID information and, even if it did, many
#    HwBinder services either operate at a level below that of apps (e.g., HALs)
#    or must not rely on app identity for authorization. Thus, to be safe, the
#    default assumption is that every HwBinder service treats all its clients as
#    equally authorized to perform operations offered by the service.
# 2. HAL servers (a subset of HwBinder services) contain code with higher
#    incidence rate of security issues than system/core components and have
#    access to lower layes of the stack (all the way down to hardware) thus
#    increasing opportunities for bypassing the Android security model.
#
# Safe services include:
# - same process services: because they by definition run in the process
#   of the client and thus have the same access as the client domain in which
#   the process runs
# - coredomain_hwservice: are considered safe because they do not pose risks
#   associated with reason #2 above.
# - hal_configstore_ISurfaceFlingerConfigs:  becuase it has specifically been
#   designed for use by any domain.
# - hal_graphics_allocator_hwservice: because these operations are also offered
#   by surfaceflinger Binder service, which apps are permitted to access
# - hal_omx_hwservice: because this is a HwBinder version of the mediacodec
#   Binder service which apps were permitted to access.
neverallow {
#line 153
  ephemeral_app
#line 153
  isolated_app
#line 153
  mediaprovider
#line 153
  untrusted_app
#line 153
  untrusted_app_25
#line 153
  untrusted_app_all
#line 153
  untrusted_v2_app
#line 153
} {
  hwservice_manager_type
  -same_process_hwservice
  -coredomain_hwservice
  -hal_configstore_ISurfaceFlingerConfigs
  -hal_graphics_allocator_hwservice
  -hal_omx_hwservice
  -hal_cas_hwservice
  -untrusted_app_visible_hwservice
}:hwservice_manager find;

# Make sure that the following services are never accessible by untrusted_apps
neverallow {
#line 165
  ephemeral_app
#line 165
  isolated_app
#line 165
  mediaprovider
#line 165
  untrusted_app
#line 165
  untrusted_app_25
#line 165
  untrusted_app_all
#line 165
  untrusted_v2_app
#line 165
} {
  default_android_hwservice
  hal_audio_hwservice
  hal_bluetooth_hwservice
  hal_bootctl_hwservice
  hal_camera_hwservice
  hal_contexthub_hwservice
  hal_drm_hwservice
  hal_dumpstate_hwservice
  hal_fingerprint_hwservice
  hal_gatekeeper_hwservice
  hal_gnss_hwservice
  hal_graphics_composer_hwservice
  hal_health_hwservice
  hal_ir_hwservice
  hal_keymaster_hwservice
  hal_light_hwservice
  hal_memtrack_hwservice
  hal_neuralnetworks_hwservice
  hal_nfc_hwservice
  hal_oemlock_hwservice
  hal_power_hwservice
  hal_sensors_hwservice
  hal_telephony_hwservice
  hal_thermal_hwservice
  hal_tv_cec_hwservice
  hal_tv_input_hwservice
  hal_usb_hwservice
  hal_vibrator_hwservice
  hal_vr_hwservice
  hal_weaver_hwservice
  hal_wifi_hwservice
  hal_wifi_offload_hwservice
  hal_wifi_supplicant_hwservice
  hidl_base_hwservice
  system_net_netd_hwservice
  thermalcallback_hwservice
}:hwservice_manager find;
# HwBinder services offered by core components (as opposed to vendor components)
# are considered somewhat safer due to point #2 above.
neverallow {
#line 205
  ephemeral_app
#line 205
  isolated_app
#line 205
  mediaprovider
#line 205
  untrusted_app
#line 205
  untrusted_app_25
#line 205
  untrusted_app_all
#line 205
  untrusted_v2_app
#line 205
} {
  coredomain_hwservice
  -same_process_hwservice
  -hidl_allocator_hwservice # Designed for use by any domain
  -hidl_manager_hwservice # Designed for use by any domain
  -hidl_memory_hwservice # Designed for use by any domain
  -hidl_token_hwservice # Designed for use by any domain
}:hwservice_manager find;

# SELinux is not an API for untrusted apps to use
neverallow {
#line 215
  ephemeral_app
#line 215
  isolated_app
#line 215
  mediaprovider
#line 215
  untrusted_app
#line 215
  untrusted_app_25
#line 215
  untrusted_app_all
#line 215
  untrusted_v2_app
#line 215
} selinuxfs:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Restrict *Binder access from apps to HAL domains. We can only do this on full
# Treble devices where *Binder communications between apps and HALs are tightly
# restricted.
# BEGIN_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 220

#line 220
  neverallow {
#line 220
  ephemeral_app
#line 220
  isolated_app
#line 220
  mediaprovider
#line 220
  untrusted_app
#line 220
  untrusted_app_25
#line 220
  untrusted_app_all
#line 220
  untrusted_v2_app
#line 220
} {
#line 220
    halserverdomain
#line 220
    -coredomain
#line 220
    -hal_configstore_server
#line 220
    -hal_graphics_allocator_server
#line 220
    -hal_cas_server
#line 220
    -binder_in_vendor_violators # TODO(b/35870313): Remove once all violations are gone
#line 220
    -untrusted_app_visible_halserver
#line 220
  }:binder { call transfer };
#line 220

#line 220
# END_TREBLE_ONLY -- this marker is used by CTS -- do not modify
#line 230

#line 1 "system/sepolicy/private/asan_extract.te"
# type_transition must be private policy the domain_trans rules could stay
# public, but conceptually should go with this
# Technically not a daemon but we do want the transition from init domain to
# asan_extract to occur.
#line 8

#line 1 "system/sepolicy/private/atrace.te"
# Domain for atrace process spawned by boottrace service.

type atrace_exec, exec_type, file_type;


#line 5
  type atrace, domain, coredomain, domain_deprecated;
#line 5

#line 5
  
#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init atrace_exec:file { getattr open read execute map };
#line 5
allow init atrace:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow atrace atrace_exec:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5

#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init atrace:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init atrace:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init atrace_exec:process atrace;
#line 5

#line 5

#line 5
type atrace_tmpfs, file_type;
#line 5
type_transition atrace tmpfs:file atrace_tmpfs;
#line 5
allow atrace atrace_tmpfs:file { read write getattr };
#line 5
allow atrace tmpfs:dir { getattr search };
#line 5

#line 5

#line 5

#line 5
  # boottrace services uses /data/misc/boottrace/categories
#line 5
  allow atrace boottrace_data_file:dir search;
#line 5
  allow atrace boottrace_data_file:file { getattr open read ioctl lock map };
#line 5

#line 5
  # Allow atrace to access tracefs.
#line 5
  allow atrace debugfs_tracing:dir { open getattr read search ioctl lock };
#line 5
  allow atrace debugfs_tracing:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 5
  allow atrace debugfs_tracing_debug:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 5
  allow atrace debugfs_trace_marker:file getattr;
#line 5

#line 5
  # atrace sets debug.atrace.* properties
#line 5
  
#line 5

#line 5
allow atrace property_socket:sock_file write;
#line 5
allow atrace init:unix_stream_socket connectto;
#line 5

#line 5
allow atrace debug_prop:property_service set;
#line 5

#line 5
allow atrace debug_prop:file { getattr open read ioctl lock map };
#line 5

#line 5

#line 5

#line 5
  # atrace pokes all the binder-enabled processes at startup.
#line 5
  
#line 5
# Call the servicemanager and transfer references to it.
#line 5
allow atrace servicemanager:binder { call transfer };
#line 5
# servicemanager performs getpidcon on clients.
#line 5
allow servicemanager atrace:dir search;
#line 5
allow servicemanager atrace:file { read open };
#line 5
allow servicemanager atrace:process getattr;
#line 5
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 5
# all domains in domain.te.
#line 5

#line 5
  allow atrace healthd:binder call;
#line 5
  allow atrace surfaceflinger:binder call;
#line 27

#line 1 "system/sepolicy/private/audioserver.te"
# audioserver - audio services daemon

typeattribute audioserver coredomain;

type audioserver_exec, exec_type, file_type;

#line 6

#line 6
# Allow the necessary permissions.
#line 6

#line 6
# Old domain may exec the file and transition to the new domain.
#line 6
allow init audioserver_exec:file { getattr open read execute map };
#line 6
allow init audioserver:process transition;
#line 6
# New domain is entered by executing the file.
#line 6
allow audioserver audioserver_exec:file { entrypoint open read execute getattr map };
#line 6
# New domain can send SIGCHLD to its caller.
#line 6

#line 6
# Enable AT_SECURE, i.e. libc secure mode.
#line 6
dontaudit init audioserver:process noatsecure;
#line 6
# XXX dontaudit candidate but requires further study.
#line 6
allow init audioserver:process { siginh rlimitinh };
#line 6

#line 6
# Make the transition occur by default.
#line 6
type_transition init audioserver_exec:process audioserver;
#line 6

#line 6

#line 6
type audioserver_tmpfs, file_type;
#line 6
type_transition audioserver tmpfs:file audioserver_tmpfs;
#line 6
allow audioserver audioserver_tmpfs:file { read write getattr };
#line 6
allow audioserver tmpfs:dir { getattr search };
#line 6

#line 6



#line 8
allow audioserver sdcard_type:dir { open getattr read search ioctl lock };
#line 8
allow audioserver sdcard_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 8



#line 10
# Call the servicemanager and transfer references to it.
#line 10
allow audioserver servicemanager:binder { call transfer };
#line 10
# servicemanager performs getpidcon on clients.
#line 10
allow servicemanager audioserver:dir search;
#line 10
allow servicemanager audioserver:file { read open };
#line 10
allow servicemanager audioserver:process getattr;
#line 10
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 10
# all domains in domain.te.
#line 10


#line 11
# Call the server domain and optionally transfer references to it.
#line 11
allow audioserver binderservicedomain:binder { call transfer };
#line 11
# Allow the serverdomain to transfer references to the client on the reply.
#line 11
allow binderservicedomain audioserver:binder transfer;
#line 11
# Receive and use open files from the server.
#line 11
allow audioserver binderservicedomain:fd use;
#line 11


#line 12
# Call the server domain and optionally transfer references to it.
#line 12
allow audioserver appdomain:binder { call transfer };
#line 12
# Allow the serverdomain to transfer references to the client on the reply.
#line 12
allow appdomain audioserver:binder transfer;
#line 12
# Receive and use open files from the server.
#line 12
allow audioserver appdomain:fd use;
#line 12


#line 13
typeattribute audioserver binderservicedomain;
#line 13



#line 15
typeattribute audioserver halclientdomain;
#line 15
typeattribute audioserver hal_allocator_client;
#line 15

#line 15
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 15
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 15
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 15

#line 15
typeattribute audioserver hal_allocator;
#line 15
# Find passthrough HAL implementations
#line 15
allow hal_allocator system_file:dir { open getattr read search ioctl lock };
#line 15
allow hal_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 15
allow hal_allocator vendor_file:file { read open getattr execute map };
#line 15

#line 15

# /system/lib64/hw for always-passthrough Allocator HAL ashmem / mapper .so

#line 17
allow audioserver system_file:dir { open getattr read search ioctl lock };
#line 17
allow audioserver system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 17



#line 19
typeattribute audioserver halclientdomain;
#line 19
typeattribute audioserver hal_audio_client;
#line 19

#line 19
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 19
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 19
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 19

#line 19
typeattribute audioserver hal_audio;
#line 19
# Find passthrough HAL implementations
#line 19
allow hal_audio system_file:dir { open getattr read search ioctl lock };
#line 19
allow hal_audio vendor_file:dir { open getattr read search ioctl lock };
#line 19
allow hal_audio vendor_file:file { read open getattr execute map };
#line 19

#line 19



#line 21
  # used for TEE sink - pcm capture for debug.
#line 21
  allow audioserver media_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
#line 21
  allow audioserver audioserver_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
#line 21
  allow audioserver audioserver_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 21

#line 21
  # ptrace to processes in the same domain for memory leak detection
#line 21
  allow audioserver self:process ptrace;
#line 29



#line 31
  allow audioserver audioserver_service:service_manager { add find };
#line 31
  neverallow { domain -audioserver } audioserver_service:service_manager add;
#line 31

allow audioserver appops_service:service_manager find;
allow audioserver batterystats_service:service_manager find;
allow audioserver permission_service:service_manager find;
allow audioserver power_service:service_manager find;
allow audioserver scheduling_policy_service:service_manager find;

# Grant access to audio files to audioserver
allow audioserver audio_data_file:dir { { open getattr read search ioctl lock } add_name write };
allow audioserver audio_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# allow access to ALSA MMAP FDs for AAudio API
allow audioserver audio_device:chr_file { read write };

# For A2DP bridge which is loaded directly into audioserver

#line 46

#line 46

#line 46
allow audioserver bluetooth_socket:sock_file write;
#line 46
allow audioserver bluetooth:unix_stream_socket connectto;
#line 46

#line 46


###
### neverallow rules
###

# audioserver should never execute any executable without a
# domain transition
neverallow audioserver { file_type fs_type }:file execute_no_trans;

# The goal of the mediaserver split is to place media processing code into
# restrictive sandboxes with limited responsibilities and thus limited
# permissions. Example: Audioserver is only responsible for controlling audio
# hardware and processing audio content. Cameraserver does the same for camera
# hardware/content. Etc.
#
# Media processing code is inherently risky and thus should have limited
# permissions and be isolated from the rest of the system and network.
# Lengthier explanation here:
# https://android-developers.googleblog.com/2016/05/hardening-media-stack.html
neverallow audioserver domain:{ tcp_socket udp_socket rawip_socket } *;
#line 1 "system/sepolicy/private/binder_in_vendor_violators.te"
allow binder_in_vendor_violators binder_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 1 "system/sepolicy/private/binderservicedomain.te"
# Rules common to all binder service domains

# Allow dumpstate and incidentd to collect information from binder services
allow binderservicedomain { dumpstate incidentd }:fd use;
allow binderservicedomain { dumpstate incidentd }:unix_stream_socket { read write getopt getattr };
allow binderservicedomain { dumpstate incidentd }:fifo_file  { getattr write };
allow binderservicedomain shell_data_file:file { getattr write };

# Allow dumpsys to work from adb shell or the serial console
allow binderservicedomain devpts:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow binderservicedomain console_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Receive and write to a pipe received over Binder from an app.
allow binderservicedomain appdomain:fd use;
allow binderservicedomain appdomain:fifo_file write;

# allow all services to run permission checks
allow binderservicedomain permission_service:service_manager find;

allow binderservicedomain keystore:keystore_key { get_state get insert delete exist list sign verify };


#line 22
  allow keystore binderservicedomain:dir search;
#line 22
  allow keystore binderservicedomain:file { read open };
#line 22
  allow keystore binderservicedomain:process getattr;
#line 22
  allow binderservicedomain keystore_service:service_manager find;
#line 22
  
#line 22
# Call the server domain and optionally transfer references to it.
#line 22
allow binderservicedomain keystore:binder { call transfer };
#line 22
# Allow the serverdomain to transfer references to the client on the reply.
#line 22
allow keystore binderservicedomain:binder transfer;
#line 22
# Receive and use open files from the server.
#line 22
allow binderservicedomain keystore:fd use;
#line 22

#line 22

#line 1 "system/sepolicy/private/blkid.te"
# blkid called from vold

typeattribute blkid coredomain;

type blkid_exec, exec_type, file_type;

# Allowed read-only access to encrypted devices to extract UUID/label
allow blkid block_device:dir search;
allow blkid userdata_block_device:blk_file { getattr open read ioctl lock map };
allow blkid dm_device:blk_file { getattr open read ioctl lock map };

# Allow stdin/out back to vold
allow blkid vold:fd use;
allow blkid vold:fifo_file { read write getattr };

# For blkid launched through popen()
allow blkid blkid_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Only allow entry from vold
neverallow { domain -vold } blkid:process transition;
neverallow * blkid:process dyntransition;
neverallow blkid { file_type fs_type -blkid_exec -shell_exec }:file entrypoint;
#line 1 "system/sepolicy/private/blkid_untrusted.te"
# blkid for untrusted block devices

typeattribute blkid_untrusted coredomain;

# Allowed read-only access to vold block devices to extract UUID/label
allow blkid_untrusted block_device:dir search;
allow blkid_untrusted vold_device:blk_file { getattr open read ioctl lock map };

# Allow stdin/out back to vold
allow blkid_untrusted vold:fd use;
allow blkid_untrusted vold:fifo_file { read write getattr };

# For blkid launched through popen()
allow blkid_untrusted blkid_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

###
### neverallow rules
###

# Untrusted blkid should never be run on block devices holding sensitive data
neverallow blkid_untrusted {
  boot_block_device
  frp_block_device
  metadata_block_device
  recovery_block_device
  root_block_device
  swap_block_device
  system_block_device
  userdata_block_device
  cache_block_device
  dm_device
}:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# Only allow entry from vold via blkid binary
neverallow { domain -vold } blkid_untrusted:process transition;
neverallow * blkid_untrusted:process dyntransition;
neverallow blkid_untrusted { file_type fs_type -blkid_exec -shell_exec }:file entrypoint;
#line 1 "system/sepolicy/private/bluetooth.te"
# bluetooth app

typeattribute bluetooth coredomain;


#line 5
typeattribute bluetooth appdomain;
#line 5
# Label ashmem objects with our own unique type.
#line 5

#line 5
type bluetooth_tmpfs, file_type;
#line 5
type_transition bluetooth tmpfs:file bluetooth_tmpfs;
#line 5
allow bluetooth bluetooth_tmpfs:file { read write getattr };
#line 5
allow bluetooth tmpfs:dir { getattr search };
#line 5

#line 5
# Map with PROT_EXEC.
#line 5
allow bluetooth bluetooth_tmpfs:file execute;
#line 5


#line 6
typeattribute bluetooth netdomain;
#line 6


# Socket creation under /data/misc/bluedroid.
type_transition bluetooth bluetooth_data_file:sock_file bluetooth_socket;

# Allow access to net_admin ioctls
allowxperm bluetooth self:udp_socket ioctl 
#line 12
{
#line 12
# qualcomm rmnet ioctls
#line 12
0x00006900 0x00006902
#line 12
# socket ioctls
#line 12
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 12
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 12
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 12
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 12
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 12
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 12
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 12
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 12
0x00008991 0x00008992 0x00008993 0x00008994
#line 12
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 12
# device and protocol specific ioctls
#line 12
0x000089f0-0x000089ff
#line 12
0x000089e0-0x000089ef
#line 12
# Wireless extension ioctls
#line 12
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 12
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 12
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 12
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 12
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 12
0x00008b34 0x00008b35 0x00008b36
#line 12
# Dev private ioctl i.e. hardware specific ioctls
#line 12
0x00008be0-0x00008bff
#line 12
};


#line 14
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 14
allow bluetooth sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 14
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 14
allow bluetooth self:capability2 block_suspend;
#line 14
;

# Data file accesses.
allow bluetooth bluetooth_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow bluetooth bluetooth_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow bluetooth bluetooth_logs_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow bluetooth bluetooth_logs_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Socket creation under /data/misc/bluedroid.
allow bluetooth bluetooth_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

allow bluetooth self:capability net_admin;
allow bluetooth self:capability2 wake_alarm;

# tethering
allow bluetooth self:packet_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow bluetooth self:capability { net_admin net_raw net_bind_service };
allow bluetooth self:tun_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow bluetooth tun_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow bluetooth efs_file:dir search;

# allow Bluetooth to access uhid device for HID profile
allow bluetooth uhid_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# proc access.
allow bluetooth proc_bluetooth_writable:file { { getattr open read ioctl lock map } { open append write lock map } };

# Allow write access to bluetooth specific properties

#line 42

#line 42
allow bluetooth property_socket:sock_file write;
#line 42
allow bluetooth init:unix_stream_socket connectto;
#line 42

#line 42
allow bluetooth bluetooth_prop:property_service set;
#line 42

#line 42
allow bluetooth bluetooth_prop:file { getattr open read ioctl lock map };
#line 42

#line 42


#line 43

#line 43
allow bluetooth property_socket:sock_file write;
#line 43
allow bluetooth init:unix_stream_socket connectto;
#line 43

#line 43
allow bluetooth pan_result_prop:property_service set;
#line 43

#line 43
allow bluetooth pan_result_prop:file { getattr open read ioctl lock map };
#line 43

#line 43


allow bluetooth audioserver_service:service_manager find;
allow bluetooth bluetooth_service:service_manager find;
allow bluetooth drmserver_service:service_manager find;
allow bluetooth mediaserver_service:service_manager find;
allow bluetooth radio_service:service_manager find;
allow bluetooth surfaceflinger_service:service_manager find;
allow bluetooth app_api_service:service_manager find;
allow bluetooth system_api_service:service_manager find;

# already open bugreport file descriptors may be shared with
# the bluetooth process, from a file in
# /data/data/com.android.shell/files/bugreports/bugreport-*.
allow bluetooth shell_data_file:file read;

# Bluetooth audio needs RT scheduling to meet deadlines, allow sys_nice
allow bluetooth self:capability sys_nice;


#line 62
typeattribute bluetooth halclientdomain;
#line 62
typeattribute bluetooth hal_bluetooth_client;
#line 62

#line 62
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 62
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 62
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 62

#line 62
typeattribute bluetooth hal_bluetooth;
#line 62
# Find passthrough HAL implementations
#line 62
allow hal_bluetooth system_file:dir { open getattr read search ioctl lock };
#line 62
allow hal_bluetooth vendor_file:dir { open getattr read search ioctl lock };
#line 62
allow hal_bluetooth vendor_file:file { read open getattr execute map };
#line 62

#line 62


#line 63
typeattribute bluetooth halclientdomain;
#line 63
typeattribute bluetooth hal_telephony_client;
#line 63

#line 63
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 63
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 63
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 63

#line 63
typeattribute bluetooth hal_telephony;
#line 63
# Find passthrough HAL implementations
#line 63
allow hal_telephony system_file:dir { open getattr read search ioctl lock };
#line 63
allow hal_telephony vendor_file:dir { open getattr read search ioctl lock };
#line 63
allow hal_telephony vendor_file:file { read open getattr execute map };
#line 63

#line 63



#line 65
allow bluetooth runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 65


###
### Neverallow rules
###
### These are things that the bluetooth app should NEVER be able to do
###

# Superuser capabilities.
# Bluetooth requires net_{admin,raw,bind_service} and wake_alarm and block_suspend and sys_nice.
neverallow bluetooth self:capability ~{ net_admin net_raw net_bind_service sys_nice};
neverallow bluetooth self:capability2 ~{ wake_alarm block_suspend };
#line 1 "system/sepolicy/private/bluetoothdomain.te"
# Allow clients to use a socket provided by the bluetooth app.
allow bluetoothdomain bluetooth:unix_stream_socket { getopt setopt getattr read write ioctl shutdown };
#line 1 "system/sepolicy/private/bootanim.te"
typeattribute bootanim coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init bootanim_exec:file { getattr open read execute map };
#line 3
allow init bootanim:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow bootanim bootanim_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init bootanim:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init bootanim:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init bootanim_exec:process bootanim;
#line 3

#line 3

#line 3
type bootanim_tmpfs, file_type;
#line 3
type_transition bootanim tmpfs:file bootanim_tmpfs;
#line 3
allow bootanim bootanim_tmpfs:file { read write getattr };
#line 3
allow bootanim tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/bootstat.te"
typeattribute bootstat coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init bootstat_exec:file { getattr open read execute map };
#line 3
allow init bootstat:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow bootstat bootstat_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init bootstat:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init bootstat:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init bootstat_exec:process bootstat;
#line 3

#line 3

#line 3
type bootstat_tmpfs, file_type;
#line 3
type_transition bootstat tmpfs:file bootstat_tmpfs;
#line 3
allow bootstat bootstat_tmpfs:file { read write getattr };
#line 3
allow bootstat tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/bufferhubd.te"
typeattribute bufferhubd coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init bufferhubd_exec:file { getattr open read execute map };
#line 3
allow init bufferhubd:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow bufferhubd bufferhubd_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init bufferhubd:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init bufferhubd:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init bufferhubd_exec:process bufferhubd;
#line 3

#line 3

#line 3
type bufferhubd_tmpfs, file_type;
#line 3
type_transition bufferhubd tmpfs:file bufferhubd_tmpfs;
#line 3
allow bufferhubd bufferhubd_tmpfs:file { read write getattr };
#line 3
allow bufferhubd tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/cameraserver.te"
typeattribute cameraserver coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init cameraserver_exec:file { getattr open read execute map };
#line 3
allow init cameraserver:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow cameraserver cameraserver_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init cameraserver:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init cameraserver:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init cameraserver_exec:process cameraserver;
#line 3

#line 3

#line 3
type cameraserver_tmpfs, file_type;
#line 3
type_transition cameraserver tmpfs:file cameraserver_tmpfs;
#line 3
allow cameraserver cameraserver_tmpfs:file { read write getattr };
#line 3
allow cameraserver tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/charger.te"
typeattribute charger coredomain;
#line 1 "system/sepolicy/private/clatd.te"
typeattribute clatd coredomain;
typeattribute clatd domain_deprecated;
#line 1 "system/sepolicy/private/cppreopts.te"
typeattribute cppreopts coredomain;

# Technically not a daemon but we do want the transition from init domain to
# cppreopts to occur.

#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init cppreopts_exec:file { getattr open read execute map };
#line 5
allow init cppreopts:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow cppreopts cppreopts_exec:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5

#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init cppreopts:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init cppreopts:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init cppreopts_exec:process cppreopts;
#line 5

#line 5

#line 5
type cppreopts_tmpfs, file_type;
#line 5
type_transition cppreopts tmpfs:file cppreopts_tmpfs;
#line 5
allow cppreopts cppreopts_tmpfs:file { read write getattr };
#line 5
allow cppreopts tmpfs:dir { getattr search };
#line 5

#line 5


#line 6
# Allow the necessary permissions.
#line 6

#line 6
# Old domain may exec the file and transition to the new domain.
#line 6
allow cppreopts preopt2cachename_exec:file { getattr open read execute map };
#line 6
allow cppreopts preopt2cachename:process transition;
#line 6
# New domain is entered by executing the file.
#line 6
allow preopt2cachename preopt2cachename_exec:file { entrypoint open read execute getattr map };
#line 6
# New domain can send SIGCHLD to its caller.
#line 6
allow preopt2cachename cppreopts:process sigchld;
#line 6
# Enable AT_SECURE, i.e. libc secure mode.
#line 6
dontaudit cppreopts preopt2cachename:process noatsecure;
#line 6
# XXX dontaudit candidate but requires further study.
#line 6
allow cppreopts preopt2cachename:process { siginh rlimitinh };
#line 6

#line 6
# Make the transition occur by default.
#line 6
type_transition cppreopts preopt2cachename_exec:process preopt2cachename;
#line 6
;
#line 1 "system/sepolicy/private/crash_dump.te"
typeattribute crash_dump coredomain;
#line 1 "system/sepolicy/private/dex2oat.te"
typeattribute dex2oat coredomain;
typeattribute dex2oat domain_deprecated;
#line 1 "system/sepolicy/private/dexoptanalyzer.te"
# dexoptanalyzer
type dexoptanalyzer, domain, coredomain, mlstrustedsubject;
type dexoptanalyzer_exec, exec_type, file_type;

# Reading an APK opens a ZipArchive, which unpack to tmpfs.
# Use tmpfs_domain() which will give tmpfs files created by dexoptanalyzer their
# own label, which differs from other labels created by other processes.
# This allows to distinguish in policy files created by dexoptanalyzer vs other
#processes.

#line 10
type dexoptanalyzer_tmpfs, file_type;
#line 10
type_transition dexoptanalyzer tmpfs:file dexoptanalyzer_tmpfs;
#line 10
allow dexoptanalyzer dexoptanalyzer_tmpfs:file { read write getattr };
#line 10
allow dexoptanalyzer tmpfs:dir { getattr search };
#line 10


# Read symlinks in /data/dalvik-cache. This is required for PIC mode boot
# app_data_file the oat file is symlinked to the original file in /system.
allow dexoptanalyzer dalvikcache_data_file:dir { getattr search };
allow dexoptanalyzer dalvikcache_data_file:file { getattr open read ioctl lock map };
allow dexoptanalyzer dalvikcache_data_file:lnk_file read;

allow dexoptanalyzer installd:fd use;

# Allow reading secondary dex files that were reported by the app to the
# package manager.
allow dexoptanalyzer app_data_file:dir { getattr search };
allow dexoptanalyzer app_data_file:file { getattr open read ioctl lock map };
# dexoptanalyzer calls access(2) with W_OK flag on app data. We can use the
# "dontaudit...audit_access" policy line to suppress the audit access without
# suppressing denial on actual access.
dontaudit dexoptanalyzer app_data_file:dir audit_access;

# Allow testing /data/user/0 which symlinks to /data/data
allow dexoptanalyzer system_data_file:lnk_file { getattr };
#line 1 "system/sepolicy/private/dhcp.te"
typeattribute dhcp coredomain;
typeattribute dhcp domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init dhcp_exec:file { getattr open read execute map };
#line 4
allow init dhcp:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow dhcp dhcp_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init dhcp:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init dhcp:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init dhcp_exec:process dhcp;
#line 4

#line 4

#line 4
type dhcp_tmpfs, file_type;
#line 4
type_transition dhcp tmpfs:file dhcp_tmpfs;
#line 4
allow dhcp dhcp_tmpfs:file { read write getattr };
#line 4
allow dhcp tmpfs:dir { getattr search };
#line 4

#line 4

type_transition dhcp system_data_file:{ dir file } dhcp_data_file;
#line 1 "system/sepolicy/private/dnsmasq.te"
typeattribute dnsmasq coredomain;
#line 1 "system/sepolicy/private/domain.te"
# Transition to crash_dump when /system/bin/crash_dump* is executed.
# This occurs when the process crashes.

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow domain crash_dump_exec:file { getattr open read execute map };
#line 3
allow domain crash_dump:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow crash_dump crash_dump_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3
allow crash_dump domain:process sigchld;
#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit domain crash_dump:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow domain crash_dump:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition domain crash_dump_exec:process crash_dump;
#line 3
;
allow domain crash_dump:process sigchld;

# Limit ability to ptrace or read sensitive /proc/pid files of processes
# with other UIDs to these whitelisted domains.
neverallow {
  domain
  -vold
  -dumpstate
  -storaged
  -system_server
  -perfprofd
} self:capability sys_ptrace;

# Limit ability to generate hardware unique device ID attestations to priv_apps
neverallow { domain -priv_app } *:keystore_key gen_unique_id;
#line 1 "system/sepolicy/private/domain_deprecated.te"
# rules removed from the domain attribute

# Read files already opened under /data.
allow domain_deprecated system_data_file:file { getattr read };
allow domain_deprecated system_data_file:lnk_file { getattr open read ioctl lock map };

# Read apk files under /data/app.
allow domain_deprecated apk_data_file:dir { getattr search };
allow domain_deprecated apk_data_file:file { getattr open read ioctl lock map };
allow domain_deprecated apk_data_file:lnk_file { getattr open read ioctl lock map };

# Read access to pseudo filesystems.

#line 13
allow domain_deprecated proc:dir { open getattr read search ioctl lock };
#line 13
allow domain_deprecated proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 13


#line 14
allow domain_deprecated sysfs:dir { open getattr read search ioctl lock };
#line 14
allow domain_deprecated sysfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 14

#line 1 "system/sepolicy/private/drmserver.te"
typeattribute drmserver coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init drmserver_exec:file { getattr open read execute map };
#line 3
allow init drmserver:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow drmserver drmserver_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init drmserver:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init drmserver:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init drmserver_exec:process drmserver;
#line 3

#line 3

#line 3
type drmserver_tmpfs, file_type;
#line 3
type_transition drmserver tmpfs:file drmserver_tmpfs;
#line 3
allow drmserver drmserver_tmpfs:file { read write getattr };
#line 3
allow drmserver tmpfs:dir { getattr search };
#line 3

#line 3


type_transition drmserver apk_data_file:sock_file drmserver_socket;

typeattribute drmserver_socket coredomain_socket;
#line 1 "system/sepolicy/private/dumpstate.te"
typeattribute dumpstate coredomain;
typeattribute dumpstate domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init dumpstate_exec:file { getattr open read execute map };
#line 4
allow init dumpstate:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow dumpstate dumpstate_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init dumpstate:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init dumpstate:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init dumpstate_exec:process dumpstate;
#line 4

#line 4

#line 4
type dumpstate_tmpfs, file_type;
#line 4
type_transition dumpstate tmpfs:file dumpstate_tmpfs;
#line 4
allow dumpstate dumpstate_tmpfs:file { read write getattr };
#line 4
allow dumpstate tmpfs:dir { getattr search };
#line 4

#line 4


# Execute and transition to the vdc domain

#line 7
# Allow the necessary permissions.
#line 7

#line 7
# Old domain may exec the file and transition to the new domain.
#line 7
allow dumpstate vdc_exec:file { getattr open read execute map };
#line 7
allow dumpstate vdc:process transition;
#line 7
# New domain is entered by executing the file.
#line 7
allow vdc vdc_exec:file { entrypoint open read execute getattr map };
#line 7
# New domain can send SIGCHLD to its caller.
#line 7
allow vdc dumpstate:process sigchld;
#line 7
# Enable AT_SECURE, i.e. libc secure mode.
#line 7
dontaudit dumpstate vdc:process noatsecure;
#line 7
# XXX dontaudit candidate but requires further study.
#line 7
allow dumpstate vdc:process { siginh rlimitinh };
#line 7

#line 7
# Make the transition occur by default.
#line 7
type_transition dumpstate vdc_exec:process vdc;
#line 7


# Acquire advisory lock on /system/etc/xtables.lock from ip[6]tables
allow dumpstate system_file:file lock;

# TODO: deal with tmpfs_domain pub/priv split properly
allow dumpstate dumpstate_tmpfs:file execute;

# systrace support - allow atrace to run
allow dumpstate debugfs_tracing:dir { open getattr read search ioctl lock };
allow dumpstate debugfs_tracing:file { { getattr open read ioctl lock map } { open append write lock map } };
allow dumpstate debugfs_trace_marker:file getattr;
allow dumpstate atrace_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow dumpstate storaged_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Allow dumpstate to make binder calls to storaged service

#line 23
# Call the server domain and optionally transfer references to it.
#line 23
allow dumpstate storaged:binder { call transfer };
#line 23
# Allow the serverdomain to transfer references to the client on the reply.
#line 23
allow storaged dumpstate:binder transfer;
#line 23
# Receive and use open files from the server.
#line 23
allow dumpstate storaged:fd use;
#line 23


# Collect metrics on boot time created by init

#line 26
allow dumpstate boottime_prop:file { getattr open read ioctl lock map };
#line 26

#line 1 "system/sepolicy/private/ephemeral_app.te"
###
### Ephemeral apps.
###
### This file defines the security policy for apps with the ephemeral
### feature.
###
### The ephemeral_app domain is a reduced permissions sandbox allowing
### ephemeral applications to be safely installed and run. Non ephemeral
### applications may also opt-in to ephemeral to take advantage of the
### additional security features.
###
### PackageManager flags an app as ephemeral at install time.

typeattribute ephemeral_app coredomain;


#line 16
typeattribute ephemeral_app netdomain;
#line 16


#line 17
typeattribute ephemeral_app appdomain;
#line 17
# Label ashmem objects with our own unique type.
#line 17

#line 17
type ephemeral_app_tmpfs, file_type;
#line 17
type_transition ephemeral_app tmpfs:file ephemeral_app_tmpfs;
#line 17
allow ephemeral_app ephemeral_app_tmpfs:file { read write getattr };
#line 17
allow ephemeral_app tmpfs:dir { getattr search };
#line 17

#line 17
# Map with PROT_EXEC.
#line 17
allow ephemeral_app ephemeral_app_tmpfs:file execute;
#line 17


# Allow ephemeral apps to read/write files in visible storage if provided fds
allow ephemeral_app { sdcard_type media_rw_data_file }:file {read write getattr ioctl lock append};

# Some apps ship with shared libraries and binaries that they write out
# to their sandbox directory and then execute.
allow ephemeral_app app_data_file:file {{ getattr open read ioctl lock map } execute};

# services
allow ephemeral_app audioserver_service:service_manager find;
allow ephemeral_app cameraserver_service:service_manager find;
allow ephemeral_app mediaserver_service:service_manager find;
allow ephemeral_app mediaextractor_service:service_manager find;
allow ephemeral_app mediacodec_service:service_manager find;
allow ephemeral_app mediametrics_service:service_manager find;
allow ephemeral_app mediadrmserver_service:service_manager find;
allow ephemeral_app surfaceflinger_service:service_manager find;
allow ephemeral_app radio_service:service_manager find;
allow ephemeral_app ephemeral_app_api_service:service_manager find;

###
### neverallow rules
###

neverallow ephemeral_app app_data_file:file execute_no_trans;

# Receive or send uevent messages.
neverallow ephemeral_app domain:netlink_kobject_uevent_socket *;

# Receive or send generic netlink messages
neverallow ephemeral_app domain:netlink_socket *;

# Too much leaky information in debugfs. It's a security
# best practice to ensure these files aren't readable.
neverallow ephemeral_app debugfs:file read;

# execute gpu_device
neverallow ephemeral_app gpu_device:chr_file execute;

# access files in /sys with the default sysfs label
neverallow ephemeral_app sysfs:file *;

# Avoid reads from generically labeled /proc files
# Create a more specific label if needed
neverallow ephemeral_app proc:file { { { append create link unlink relabelfrom rename setattr write } open read ioctl lock } { execute execute_no_trans } };

# Directly access external storage
neverallow ephemeral_app { sdcard_type media_rw_data_file }:file {open create};
neverallow ephemeral_app { sdcard_type media_rw_data_file }:dir search;

# Avoid reads to proc_net, it contains too much device wide information about
# ongoing connections.
neverallow ephemeral_app proc_net:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
#line 1 "system/sepolicy/private/file.te"
# Compatibility with type names used in vanilla Android 4.3 and 4.4.
typealias audio_data_file alias audio_firmware_file;
typealias app_data_file alias platform_app_data_file;
typealias app_data_file alias download_file;

# /proc/config.gz
type config_gz, fs_type;
#line 1 "system/sepolicy/private/fingerprintd.te"
typeattribute fingerprintd coredomain;
typeattribute fingerprintd domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init fingerprintd_exec:file { getattr open read execute map };
#line 4
allow init fingerprintd:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow fingerprintd fingerprintd_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init fingerprintd:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init fingerprintd:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init fingerprintd_exec:process fingerprintd;
#line 4

#line 4

#line 4
type fingerprintd_tmpfs, file_type;
#line 4
type_transition fingerprintd tmpfs:file fingerprintd_tmpfs;
#line 4
allow fingerprintd fingerprintd_tmpfs:file { read write getattr };
#line 4
allow fingerprintd tmpfs:dir { getattr search };
#line 4

#line 4

#line 1 "system/sepolicy/private/fsck.te"
typeattribute fsck coredomain;
typeattribute fsck domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init fsck_exec:file { getattr open read execute map };
#line 4
allow init fsck:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow fsck fsck_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init fsck:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init fsck:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init fsck_exec:process fsck;
#line 4

#line 4

#line 4
type fsck_tmpfs, file_type;
#line 4
type_transition fsck tmpfs:file fsck_tmpfs;
#line 4
allow fsck fsck_tmpfs:file { read write getattr };
#line 4
allow fsck tmpfs:dir { getattr search };
#line 4

#line 4

#line 1 "system/sepolicy/private/fsck_untrusted.te"
typeattribute fsck_untrusted coredomain;
typeattribute fsck_untrusted domain_deprecated;
#line 1 "system/sepolicy/private/gatekeeperd.te"
typeattribute gatekeeperd coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init gatekeeperd_exec:file { getattr open read execute map };
#line 3
allow init gatekeeperd:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow gatekeeperd gatekeeperd_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init gatekeeperd:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init gatekeeperd:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init gatekeeperd_exec:process gatekeeperd;
#line 3

#line 3

#line 3
type gatekeeperd_tmpfs, file_type;
#line 3
type_transition gatekeeperd tmpfs:file gatekeeperd_tmpfs;
#line 3
allow gatekeeperd gatekeeperd_tmpfs:file { read write getattr };
#line 3
allow gatekeeperd tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/hal_allocator_default.te"
type hal_allocator_default, domain, coredomain;

#line 2
typeattribute hal_allocator_default halserverdomain;
#line 2
typeattribute hal_allocator_default hal_allocator_server;
#line 2
typeattribute hal_allocator_default hal_allocator;
#line 2


type hal_allocator_default_exec, exec_type, file_type;

#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init hal_allocator_default_exec:file { getattr open read execute map };
#line 5
allow init hal_allocator_default:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow hal_allocator_default hal_allocator_default_exec:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5

#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init hal_allocator_default:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init hal_allocator_default:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init hal_allocator_default_exec:process hal_allocator_default;
#line 5

#line 5

#line 5
type hal_allocator_default_tmpfs, file_type;
#line 5
type_transition hal_allocator_default tmpfs:file hal_allocator_default_tmpfs;
#line 5
allow hal_allocator_default hal_allocator_default_tmpfs:file { read write getattr };
#line 5
allow hal_allocator_default tmpfs:dir { getattr search };
#line 5

#line 5

#line 1 "system/sepolicy/private/halclientdomain.te"
###
### Rules for all domains which are clients of a HAL
###

# Find out whether a HAL in passthrough/in-process mode or
# binderized/out-of-process mode

#line 7
# Call the hwservicemanager and transfer references to it.
#line 7
allow halclientdomain hwservicemanager:binder { call transfer };
#line 7
# Allow hwservicemanager to send out callbacks
#line 7
allow hwservicemanager halclientdomain:binder { call transfer };
#line 7
# hwservicemanager performs getpidcon on clients.
#line 7
allow hwservicemanager halclientdomain:dir search;
#line 7
allow hwservicemanager halclientdomain:file { read open };
#line 7
allow hwservicemanager halclientdomain:process getattr;
#line 7
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 7
# all domains in domain.te.
#line 7


# Used to wait for hwservicemanager

#line 10
allow halclientdomain hwservicemanager_prop:file { getattr open read ioctl lock map };
#line 10


# Wait for HAL server to be up (used by getService)
allow halclientdomain hidl_manager_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/private/halserverdomain.te"
###
### Rules for all domains which offer a HAL service over HwBinder
###

# Register the HAL service with hwservicemanager

#line 6
# Call the hwservicemanager and transfer references to it.
#line 6
allow halserverdomain hwservicemanager:binder { call transfer };
#line 6
# Allow hwservicemanager to send out callbacks
#line 6
allow hwservicemanager halserverdomain:binder { call transfer };
#line 6
# hwservicemanager performs getpidcon on clients.
#line 6
allow hwservicemanager halserverdomain:dir search;
#line 6
allow hwservicemanager halserverdomain:file { read open };
#line 6
allow hwservicemanager halserverdomain:process getattr;
#line 6
# rw access to /dev/hwbinder and /dev/ashmem is presently granted to
#line 6
# all domains in domain.te.
#line 6


# Find HAL implementations
allow halserverdomain system_file:dir { open getattr read search ioctl lock };

# Used to wait for hwservicemanager

#line 12
allow halserverdomain hwservicemanager_prop:file { getattr open read ioctl lock map };
#line 12

#line 1 "system/sepolicy/private/healthd.te"
typeattribute healthd coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init healthd_exec:file { getattr open read execute map };
#line 3
allow init healthd:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow healthd healthd_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init healthd:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init healthd:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init healthd_exec:process healthd;
#line 3

#line 3

#line 3
type healthd_tmpfs, file_type;
#line 3
type_transition healthd tmpfs:file healthd_tmpfs;
#line 3
allow healthd healthd_tmpfs:file { read write getattr };
#line 3
allow healthd tmpfs:dir { getattr search };
#line 3

#line 3


# Allow callback to storaged batteryproperties listener

#line 6
# Call the server domain and optionally transfer references to it.
#line 6
allow healthd storaged:binder { call transfer };
#line 6
# Allow the serverdomain to transfer references to the client on the reply.
#line 6
allow storaged healthd:binder transfer;
#line 6
# Receive and use open files from the server.
#line 6
allow healthd storaged:fd use;
#line 6

#line 1 "system/sepolicy/private/hwservicemanager.te"
typeattribute hwservicemanager coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init hwservicemanager_exec:file { getattr open read execute map };
#line 3
allow init hwservicemanager:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow hwservicemanager hwservicemanager_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init hwservicemanager:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init hwservicemanager:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init hwservicemanager_exec:process hwservicemanager;
#line 3

#line 3

#line 3
type hwservicemanager_tmpfs, file_type;
#line 3
type_transition hwservicemanager tmpfs:file hwservicemanager_tmpfs;
#line 3
allow hwservicemanager hwservicemanager_tmpfs:file { read write getattr };
#line 3
allow hwservicemanager tmpfs:dir { getattr search };
#line 3

#line 3



#line 5
  allow hwservicemanager hidl_manager_hwservice:hwservice_manager { add find };
#line 5
  allow hwservicemanager hidl_base_hwservice:hwservice_manager add;
#line 5
  neverallow { domain -hwservicemanager } hidl_manager_hwservice:hwservice_manager add;
#line 5


#line 6
  allow hwservicemanager hidl_token_hwservice:hwservice_manager { add find };
#line 6
  allow hwservicemanager hidl_base_hwservice:hwservice_manager add;
#line 6
  neverallow { domain -hwservicemanager } hidl_token_hwservice:hwservice_manager add;
#line 6

#line 1 "system/sepolicy/private/idmap.te"
typeattribute idmap coredomain;
#line 1 "system/sepolicy/private/incident.te"
typeattribute incident coredomain;

type incident_exec, exec_type, file_type;

# switch to incident domain for incident command

#line 6
# Allow the necessary permissions.
#line 6

#line 6
# Old domain may exec the file and transition to the new domain.
#line 6
allow shell incident_exec:file { getattr open read execute map };
#line 6
allow shell incident:process transition;
#line 6
# New domain is entered by executing the file.
#line 6
allow incident incident_exec:file { entrypoint open read execute getattr map };
#line 6
# New domain can send SIGCHLD to its caller.
#line 6
allow incident shell:process sigchld;
#line 6
# Enable AT_SECURE, i.e. libc secure mode.
#line 6
dontaudit shell incident:process noatsecure;
#line 6
# XXX dontaudit candidate but requires further study.
#line 6
allow shell incident:process { siginh rlimitinh };
#line 6

#line 6
# Make the transition occur by default.
#line 6
type_transition shell incident_exec:process incident;
#line 6


# allow incident access to stdout from its parent shell.
allow incident shell:fd use;

# allow incident to communicate use, read and write over the adb
# connection.
allow incident adbd:fd use;
allow incident adbd:unix_stream_socket { read write };

# allow adbd to reap incident
allow incident adbd:process { sigchld };

# Allow the incident command to talk to the incidentd over the binder, and get
# back the incident report data from a ParcelFileDescriptor.

#line 21
# Call the servicemanager and transfer references to it.
#line 21
allow incident servicemanager:binder { call transfer };
#line 21
# servicemanager performs getpidcon on clients.
#line 21
allow servicemanager incident:dir search;
#line 21
allow servicemanager incident:file { read open };
#line 21
allow servicemanager incident:process getattr;
#line 21
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 21
# all domains in domain.te.
#line 21

allow incident incident_service:service_manager find;

#line 23
# Call the server domain and optionally transfer references to it.
#line 23
allow incident incidentd:binder { call transfer };
#line 23
# Allow the serverdomain to transfer references to the client on the reply.
#line 23
allow incidentd incident:binder transfer;
#line 23
# Receive and use open files from the server.
#line 23
allow incident incidentd:fd use;
#line 23

allow incident incidentd:fifo_file write;

#line 1 "system/sepolicy/private/incidentd.te"
typeattribute incidentd coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init incidentd_exec:file { getattr open read execute map };
#line 3
allow init incidentd:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow incidentd incidentd_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init incidentd:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init incidentd:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init incidentd_exec:process incidentd;
#line 3

#line 3

#line 3
type incidentd_tmpfs, file_type;
#line 3
type_transition incidentd tmpfs:file incidentd_tmpfs;
#line 3
allow incidentd incidentd_tmpfs:file { read write getattr };
#line 3
allow incidentd tmpfs:dir { getattr search };
#line 3

#line 3

type incidentd_exec, exec_type, file_type;

#line 5
# Call the servicemanager and transfer references to it.
#line 5
allow incidentd servicemanager:binder { call transfer };
#line 5
# servicemanager performs getpidcon on clients.
#line 5
allow servicemanager incidentd:dir search;
#line 5
allow servicemanager incidentd:file { read open };
#line 5
allow servicemanager incidentd:process getattr;
#line 5
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 5
# all domains in domain.te.
#line 5


#line 6
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 6
allow incidentd sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 6
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 6
allow incidentd self:capability2 block_suspend;
#line 6


# Allow setting process priority, protect from OOM killer, and dropping
# privileges by switching UID / GID
# TODO allow incidentd self:capability { setuid setgid sys_resource };

# Allow incidentd to scan through /proc/pid for all processes

#line 13
allow incidentd domain:dir { open getattr read search ioctl lock };
#line 13
allow incidentd domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 13


allow incidentd self:capability {
    # Send signals to processes
    kill
};

# Allow executing files on system, such as:
#   /system/bin/toolbox
#   /system/bin/logcat
#   /system/bin/dumpsys
allow incidentd system_file:file execute_no_trans;
allow incidentd toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Create and write into /data/misc/incidents
allow incidentd incident_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow incidentd incident_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Get process attributes
# TODO allow incidentd domain:process getattr;

# Signal java processes to dump their stack and get the results
# TODO allow incidentd { appdomain ephemeral_app system_server }:process signal;
# TODO allow incidentd anr_data_file:dir rw_dir_perms;
# TODO allow incidentd anr_data_file:file create_file_perms;

# Signal native processes to dump their stack.
# This list comes from native_processes_to_dump in incidentd/utils.c
allow incidentd {
  audioserver
  cameraserver
  drmserver
  inputflinger
  mediacodec
  mediadrmserver
  mediaextractor
  mediaserver
  sdcardd
  surfaceflinger
}:process signal;

# Allow incidentd to make binder calls to any binder service

#line 55
# Call the server domain and optionally transfer references to it.
#line 55
allow incidentd binderservicedomain:binder { call transfer };
#line 55
# Allow the serverdomain to transfer references to the client on the reply.
#line 55
allow binderservicedomain incidentd:binder transfer;
#line 55
# Receive and use open files from the server.
#line 55
allow incidentd binderservicedomain:fd use;
#line 55


#line 56
# Call the server domain and optionally transfer references to it.
#line 56
allow incidentd appdomain:binder { call transfer };
#line 56
# Allow the serverdomain to transfer references to the client on the reply.
#line 56
allow appdomain incidentd:binder transfer;
#line 56
# Receive and use open files from the server.
#line 56
allow incidentd appdomain:fd use;
#line 56


# Reading /proc/PID/maps of other processes
# TODO allow incidentd self:capability sys_ptrace;

# Run a shell.
allow incidentd shell_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# logd access - work to be done is a PII safe log (possibly an event log?)
# TODO read_logd(incidentd)
# TODO control_logd(incidentd)

# Allow incidentd to find these standard groups of services.
# Others can be whitelisted individually.
allow incidentd {
  system_server_service
  app_api_service
  system_api_service
}:service_manager find;

# Only incidentd can publish the binder service

#line 77
  allow incidentd incident_service:service_manager { add find };
#line 77
  neverallow { domain -incidentd } incident_service:service_manager add;
#line 77


# Allow pipes from (and only from) incident
allow incidentd incident:fd use;
allow incidentd incident:fifo_file write;

# Allow incident to call back to incident with status updates.

#line 84
# Call the server domain and optionally transfer references to it.
#line 84
allow incidentd incident:binder { call transfer };
#line 84
# Allow the serverdomain to transfer references to the client on the reply.
#line 84
allow incident incidentd:binder transfer;
#line 84
# Receive and use open files from the server.
#line 84
allow incidentd incident:fd use;
#line 84


###
### neverallow rules
###

# only system_server, system_app and incident command can find the incident service
neverallow { domain -system_server -system_app -incident -incidentd } incident_service:service_manager find;

# only incidentd and the other root services in limited circumstances
# can get to the files in /data/misc/incidents
#
# write, execute, append are forbidden almost everywhere
neverallow { domain -incidentd -init -vold } incident_data_file:file {
  { open append write lock map }
  { getattr execute execute_no_trans map }
  create
  rename
  setattr
  unlink
  append
};
# read is also allowed by system_server, for when the file is handed to dropbox
neverallow { domain -incidentd -init -vold -system_server } incident_data_file:file { getattr open read ioctl lock map };
# limited access to the directory itself
neverallow { domain -incidentd -init -vold } incident_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };

#line 1 "system/sepolicy/private/init.te"
typeattribute init coredomain;


#line 3
type init_tmpfs, file_type;
#line 3
type_transition init tmpfs:file init_tmpfs;
#line 3
allow init init_tmpfs:file { read write getattr };
#line 3
allow init tmpfs:dir { getattr search };
#line 3


# Transitions to seclabel processes in init.rc

#line 6
# Old domain may exec the file and transition to the new domain.
#line 6
allow init rootfs:file { getattr open read execute map };
#line 6
allow init charger:process transition;
#line 6
# New domain is entered by executing the file.
#line 6
allow charger rootfs:file { entrypoint open read execute getattr map };
#line 6
# New domain can send SIGCHLD to its caller.
#line 6

#line 6
# Enable AT_SECURE, i.e. libc secure mode.
#line 6
dontaudit init charger:process noatsecure;
#line 6
# XXX dontaudit candidate but requires further study.
#line 6
allow init charger:process { siginh rlimitinh };
#line 6


#line 7
# Old domain may exec the file and transition to the new domain.
#line 7
allow init rootfs:file { getattr open read execute map };
#line 7
allow init healthd:process transition;
#line 7
# New domain is entered by executing the file.
#line 7
allow healthd rootfs:file { entrypoint open read execute getattr map };
#line 7
# New domain can send SIGCHLD to its caller.
#line 7

#line 7
# Enable AT_SECURE, i.e. libc secure mode.
#line 7
dontaudit init healthd:process noatsecure;
#line 7
# XXX dontaudit candidate but requires further study.
#line 7
allow init healthd:process { siginh rlimitinh };
#line 7


#line 8
# Old domain may exec the file and transition to the new domain.
#line 8
allow init rootfs:file { getattr open read execute map };
#line 8
allow init slideshow:process transition;
#line 8
# New domain is entered by executing the file.
#line 8
allow slideshow rootfs:file { entrypoint open read execute getattr map };
#line 8
# New domain can send SIGCHLD to its caller.
#line 8

#line 8
# Enable AT_SECURE, i.e. libc secure mode.
#line 8
dontaudit init slideshow:process noatsecure;
#line 8
# XXX dontaudit candidate but requires further study.
#line 8
allow init slideshow:process { siginh rlimitinh };
#line 8


#line 9
# Allow the necessary permissions.
#line 9

#line 9
# Old domain may exec the file and transition to the new domain.
#line 9
allow init e2fs_exec:file { getattr open read execute map };
#line 9
allow init e2fs:process transition;
#line 9
# New domain is entered by executing the file.
#line 9
allow e2fs e2fs_exec:file { entrypoint open read execute getattr map };
#line 9
# New domain can send SIGCHLD to its caller.
#line 9

#line 9
# Enable AT_SECURE, i.e. libc secure mode.
#line 9
dontaudit init e2fs:process noatsecure;
#line 9
# XXX dontaudit candidate but requires further study.
#line 9
allow init e2fs:process { siginh rlimitinh };
#line 9

#line 9
# Make the transition occur by default.
#line 9
type_transition init e2fs_exec:process e2fs;
#line 9

#line 13


#line 14
# Old domain may exec the file and transition to the new domain.
#line 14
allow init shell_exec:file { getattr open read execute map };
#line 14
allow init shell:process transition;
#line 14
# New domain is entered by executing the file.
#line 14
allow shell shell_exec:file { entrypoint open read execute getattr map };
#line 14
# New domain can send SIGCHLD to its caller.
#line 14

#line 14
# Enable AT_SECURE, i.e. libc secure mode.
#line 14
dontaudit init shell:process noatsecure;
#line 14
# XXX dontaudit candidate but requires further study.
#line 14
allow init shell:process { siginh rlimitinh };
#line 14


#line 15
# Old domain may exec the file and transition to the new domain.
#line 15
allow init init_exec:file { getattr open read execute map };
#line 15
allow init ueventd:process transition;
#line 15
# New domain is entered by executing the file.
#line 15
allow ueventd init_exec:file { entrypoint open read execute getattr map };
#line 15
# New domain can send SIGCHLD to its caller.
#line 15

#line 15
# Enable AT_SECURE, i.e. libc secure mode.
#line 15
dontaudit init ueventd:process noatsecure;
#line 15
# XXX dontaudit candidate but requires further study.
#line 15
allow init ueventd:process { siginh rlimitinh };
#line 15


#line 16
# Old domain may exec the file and transition to the new domain.
#line 16
allow init init_exec:file { getattr open read execute map };
#line 16
allow init watchdogd:process transition;
#line 16
# New domain is entered by executing the file.
#line 16
allow watchdogd init_exec:file { entrypoint open read execute getattr map };
#line 16
# New domain can send SIGCHLD to its caller.
#line 16

#line 16
# Enable AT_SECURE, i.e. libc secure mode.
#line 16
dontaudit init watchdogd:process noatsecure;
#line 16
# XXX dontaudit candidate but requires further study.
#line 16
allow init watchdogd:process { siginh rlimitinh };
#line 16


#line 17
# Old domain may exec the file and transition to the new domain.
#line 17
allow init { rootfs toolbox_exec }:file { getattr open read execute map };
#line 17
allow init modprobe:process transition;
#line 17
# New domain is entered by executing the file.
#line 17
allow modprobe { rootfs toolbox_exec }:file { entrypoint open read execute getattr map };
#line 17
# New domain can send SIGCHLD to its caller.
#line 17

#line 17
# Enable AT_SECURE, i.e. libc secure mode.
#line 17
dontaudit init modprobe:process noatsecure;
#line 17
# XXX dontaudit candidate but requires further study.
#line 17
allow init modprobe:process { siginh rlimitinh };
#line 17

# case where logpersistd is actually logcat -f in logd context (nee: logcatd)

#line 19
  
#line 19
# Allow the necessary permissions.
#line 19

#line 19
# Old domain may exec the file and transition to the new domain.
#line 19
allow init logcat_exec:file { getattr open read execute map };
#line 19
allow init logpersist:process transition;
#line 19
# New domain is entered by executing the file.
#line 19
allow logpersist logcat_exec:file { entrypoint open read execute getattr map };
#line 19
# New domain can send SIGCHLD to its caller.
#line 19

#line 19
# Enable AT_SECURE, i.e. libc secure mode.
#line 19
dontaudit init logpersist:process noatsecure;
#line 19
# XXX dontaudit candidate but requires further study.
#line 19
allow init logpersist:process { siginh rlimitinh };
#line 19

#line 19
# Make the transition occur by default.
#line 19
type_transition init logcat_exec:process logpersist;
#line 19

#line 21


# Creating files on sysfs is impossible so this isn't a threat
# Sometimes we have to write to non-existent files to avoid conditional
# init behavior. See b/35303861 for an example.
dontaudit init sysfs:dir write;
#line 1 "system/sepolicy/private/inputflinger.te"
typeattribute inputflinger coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init inputflinger_exec:file { getattr open read execute map };
#line 3
allow init inputflinger:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow inputflinger inputflinger_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init inputflinger:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init inputflinger:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init inputflinger_exec:process inputflinger;
#line 3

#line 3

#line 3
type inputflinger_tmpfs, file_type;
#line 3
type_transition inputflinger tmpfs:file inputflinger_tmpfs;
#line 3
allow inputflinger inputflinger_tmpfs:file { read write getattr };
#line 3
allow inputflinger tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/install_recovery.te"
typeattribute install_recovery coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init install_recovery_exec:file { getattr open read execute map };
#line 3
allow init install_recovery:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow install_recovery install_recovery_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init install_recovery:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init install_recovery:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init install_recovery_exec:process install_recovery;
#line 3

#line 3

#line 3
type install_recovery_tmpfs, file_type;
#line 3
type_transition install_recovery tmpfs:file install_recovery_tmpfs;
#line 3
allow install_recovery install_recovery_tmpfs:file { read write getattr };
#line 3
allow install_recovery tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/installd.te"
typeattribute installd coredomain;
typeattribute installd domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init installd_exec:file { getattr open read execute map };
#line 4
allow init installd:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow installd installd_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init installd:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init installd:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init installd_exec:process installd;
#line 4

#line 4

#line 4
type installd_tmpfs, file_type;
#line 4
type_transition installd tmpfs:file installd_tmpfs;
#line 4
allow installd installd_tmpfs:file { read write getattr };
#line 4
allow installd tmpfs:dir { getattr search };
#line 4

#line 4


# Run dex2oat in its own sandbox.

#line 7
# Allow the necessary permissions.
#line 7

#line 7
# Old domain may exec the file and transition to the new domain.
#line 7
allow installd dex2oat_exec:file { getattr open read execute map };
#line 7
allow installd dex2oat:process transition;
#line 7
# New domain is entered by executing the file.
#line 7
allow dex2oat dex2oat_exec:file { entrypoint open read execute getattr map };
#line 7
# New domain can send SIGCHLD to its caller.
#line 7
allow dex2oat installd:process sigchld;
#line 7
# Enable AT_SECURE, i.e. libc secure mode.
#line 7
dontaudit installd dex2oat:process noatsecure;
#line 7
# XXX dontaudit candidate but requires further study.
#line 7
allow installd dex2oat:process { siginh rlimitinh };
#line 7

#line 7
# Make the transition occur by default.
#line 7
type_transition installd dex2oat_exec:process dex2oat;
#line 7


# Run dexoptanalyzer in its own sandbox.

#line 10
# Allow the necessary permissions.
#line 10

#line 10
# Old domain may exec the file and transition to the new domain.
#line 10
allow installd dexoptanalyzer_exec:file { getattr open read execute map };
#line 10
allow installd dexoptanalyzer:process transition;
#line 10
# New domain is entered by executing the file.
#line 10
allow dexoptanalyzer dexoptanalyzer_exec:file { entrypoint open read execute getattr map };
#line 10
# New domain can send SIGCHLD to its caller.
#line 10
allow dexoptanalyzer installd:process sigchld;
#line 10
# Enable AT_SECURE, i.e. libc secure mode.
#line 10
dontaudit installd dexoptanalyzer:process noatsecure;
#line 10
# XXX dontaudit candidate but requires further study.
#line 10
allow installd dexoptanalyzer:process { siginh rlimitinh };
#line 10

#line 10
# Make the transition occur by default.
#line 10
type_transition installd dexoptanalyzer_exec:process dexoptanalyzer;
#line 10


# Run profman in its own sandbox.

#line 13
# Allow the necessary permissions.
#line 13

#line 13
# Old domain may exec the file and transition to the new domain.
#line 13
allow installd profman_exec:file { getattr open read execute map };
#line 13
allow installd profman:process transition;
#line 13
# New domain is entered by executing the file.
#line 13
allow profman profman_exec:file { entrypoint open read execute getattr map };
#line 13
# New domain can send SIGCHLD to its caller.
#line 13
allow profman installd:process sigchld;
#line 13
# Enable AT_SECURE, i.e. libc secure mode.
#line 13
dontaudit installd profman:process noatsecure;
#line 13
# XXX dontaudit candidate but requires further study.
#line 13
allow installd profman:process { siginh rlimitinh };
#line 13

#line 13
# Make the transition occur by default.
#line 13
type_transition installd profman_exec:process profman;
#line 13


# Run idmap in its own sandbox.

#line 16
# Allow the necessary permissions.
#line 16

#line 16
# Old domain may exec the file and transition to the new domain.
#line 16
allow installd idmap_exec:file { getattr open read execute map };
#line 16
allow installd idmap:process transition;
#line 16
# New domain is entered by executing the file.
#line 16
allow idmap idmap_exec:file { entrypoint open read execute getattr map };
#line 16
# New domain can send SIGCHLD to its caller.
#line 16
allow idmap installd:process sigchld;
#line 16
# Enable AT_SECURE, i.e. libc secure mode.
#line 16
dontaudit installd idmap:process noatsecure;
#line 16
# XXX dontaudit candidate but requires further study.
#line 16
allow installd idmap:process { siginh rlimitinh };
#line 16

#line 16
# Make the transition occur by default.
#line 16
type_transition installd idmap_exec:process idmap;
#line 16


# Create /data/.layout_version.* file
type_transition installd system_data_file:file install_data_file;
#line 1 "system/sepolicy/private/isolated_app.te"
###
### Services with isolatedProcess=true in their manifest.
###
### This file defines the rules for isolated apps. An "isolated
### app" is an APP with UID between AID_ISOLATED_START (99000)
### and AID_ISOLATED_END (99999).
###

typeattribute isolated_app coredomain;


#line 11
typeattribute isolated_app appdomain;
#line 11
# Label ashmem objects with our own unique type.
#line 11

#line 11
type isolated_app_tmpfs, file_type;
#line 11
type_transition isolated_app tmpfs:file isolated_app_tmpfs;
#line 11
allow isolated_app isolated_app_tmpfs:file { read write getattr };
#line 11
allow isolated_app tmpfs:dir { getattr search };
#line 11

#line 11
# Map with PROT_EXEC.
#line 11
allow isolated_app isolated_app_tmpfs:file execute;
#line 11


# Access already open app data files received over Binder or local socket IPC.
allow isolated_app app_data_file:file { append read write getattr lock };

allow isolated_app activity_service:service_manager find;
allow isolated_app display_service:service_manager find;
allow isolated_app webviewupdate_service:service_manager find;

# Google Breakpad (crash reporter for Chrome) relies on ptrace
# functionality. Without the ability to ptrace, the crash reporter
# tool is broken.
# b/20150694
# https://code.google.com/p/chromium/issues/detail?id=475270
allow isolated_app self:process ptrace;

# b/32896414: Allow accessing sdcard file descriptors passed to isolated_apps
# by other processes. Open should never be allowed, and is blocked by
# neverallow rules below.
# TODO: consider removing write/append. We want to limit isolated_apps
# ability to mutate files of any type.
# media_rw_data_file is included for sdcardfs, and can be removed if sdcardfs
# is modified to change the secontext when accessing the lower filesystem.
allow isolated_app { sdcard_type media_rw_data_file }:file { read write append getattr lock };
auditallow isolated_app { sdcard_type media_rw_data_file }:file { write append };

# For webviews, isolated_app processes can be forked from the webview_zygote
# in addition to the zygote. Allow access to resources inherited from the
# webview_zygote process. These rules are specialized copies of the ones in app.te.
# Inherit FDs from the webview_zygote.
allow isolated_app webview_zygote:fd use;
# Notify webview_zygote of child death.
allow isolated_app webview_zygote:process sigchld;
# Inherit logd write socket.
allow isolated_app webview_zygote:unix_dgram_socket write;
# Read system properties managed by webview_zygote.
allow isolated_app webview_zygote_tmpfs:file read;

# TODO (b/63631799) fix this access
# suppress denials to /data/local/tmp
dontaudit isolated_app shell_data_file:dir search;

#####
##### Neverallow
#####

# Do not allow isolated_app to directly open tun_device
neverallow isolated_app tun_device:chr_file open;

# Isolated apps should not directly open app data files themselves.
neverallow isolated_app app_data_file:file open;

# Only allow appending to /data/anr/traces.txt (b/27853304, b/18340553)
# TODO: are there situations where isolated_apps write to this file?
# TODO: should we tighten these restrictions further?
neverallow isolated_app anr_data_file:file ~{ open append };
neverallow isolated_app anr_data_file:dir ~search;

# Isolated apps must not be permitted to use HwBinder
neverallow isolated_app hwbinder_device:chr_file *;
neverallow isolated_app *:hwservice_manager *;

# Isolated apps must not be permitted to use VndBinder
neverallow isolated_app vndbinder_device:chr_file *;

# Isolated apps must not be permitted to perform actions on Binder and VndBinder service_manager
# except the find actions for services whitelisted below.
neverallow isolated_app *:service_manager ~find;

# b/17487348
# Isolated apps can only access three services,
# activity_service, display_service and webviewupdate_service.
neverallow isolated_app {
    service_manager_type
    -activity_service
    -display_service
    -webviewupdate_service
}:service_manager find;

# Isolated apps shouldn't be able to access the driver directly.
neverallow isolated_app gpu_device:chr_file { { { getattr open read ioctl lock map } { open append write lock map } } execute };

# Do not allow isolated_app access to /cache
neverallow isolated_app cache_file:dir ~{ { open getattr read search ioctl lock } };
neverallow isolated_app cache_file:file ~{ read getattr };

# Do not allow isolated_app to access external storage, except for files passed
# via file descriptors (b/32896414).
neverallow isolated_app { storage_file mnt_user_file sdcard_type }:dir ~getattr;
neverallow isolated_app { storage_file mnt_user_file }:{ { chr_file blk_file } { file lnk_file sock_file fifo_file } } *;
neverallow isolated_app sdcard_type:{ { chr_file blk_file } lnk_file sock_file fifo_file } *;
neverallow isolated_app sdcard_type:file ~{ read write append getattr lock };

# Do not allow USB access
neverallow isolated_app { usb_device usbaccessory_device }:chr_file *;

# Restrict the webview_zygote control socket.
neverallow isolated_app webview_zygote_socket:sock_file write;
#line 1 "system/sepolicy/private/kernel.te"
typeattribute kernel coredomain;


#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow kernel init_exec:file { getattr open read execute map };
#line 3
allow kernel init:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow init init_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3
allow init kernel:process sigchld;
#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit kernel init:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow kernel init:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition kernel init_exec:process init;
#line 3

#line 1 "system/sepolicy/private/keystore.te"
typeattribute keystore coredomain;
typeattribute keystore domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init keystore_exec:file { getattr open read execute map };
#line 4
allow init keystore:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow keystore keystore_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init keystore:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init keystore:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init keystore_exec:process keystore;
#line 4

#line 4

#line 4
type keystore_tmpfs, file_type;
#line 4
type_transition keystore tmpfs:file keystore_tmpfs;
#line 4
allow keystore keystore_tmpfs:file { read write getattr };
#line 4
allow keystore tmpfs:dir { getattr search };
#line 4

#line 4


# talk to keymaster

#line 7
typeattribute keystore halclientdomain;
#line 7
typeattribute keystore hal_keymaster_client;
#line 7

#line 7
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 7
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 7
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 7

#line 7
typeattribute keystore hal_keymaster;
#line 7
# Find passthrough HAL implementations
#line 7
allow hal_keymaster system_file:dir { open getattr read search ioctl lock };
#line 7
allow hal_keymaster vendor_file:dir { open getattr read search ioctl lock };
#line 7
allow hal_keymaster vendor_file:file { read open getattr execute map };
#line 7

#line 7


# Offer the Wifi Keystore HwBinder service
typeattribute keystore wifi_keystore_service_server;

#line 11
  allow keystore system_wifi_keystore_hwservice:hwservice_manager { add find };
#line 11
  allow keystore hidl_base_hwservice:hwservice_manager add;
#line 11
  neverallow { domain -keystore } system_wifi_keystore_hwservice:hwservice_manager add;
#line 11

#line 1 "system/sepolicy/private/lmkd.te"
typeattribute lmkd coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init lmkd_exec:file { getattr open read execute map };
#line 3
allow init lmkd:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow lmkd lmkd_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init lmkd:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init lmkd:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init lmkd_exec:process lmkd;
#line 3

#line 3

#line 3
type lmkd_tmpfs, file_type;
#line 3
type_transition lmkd tmpfs:file lmkd_tmpfs;
#line 3
allow lmkd lmkd_tmpfs:file { read write getattr };
#line 3
allow lmkd tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/logd.te"
typeattribute logd coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init logd_exec:file { getattr open read execute map };
#line 3
allow init logd:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow logd logd_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init logd:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init logd:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init logd_exec:process logd;
#line 3

#line 3

#line 3
type logd_tmpfs, file_type;
#line 3
type_transition logd tmpfs:file logd_tmpfs;
#line 3
allow logd logd_tmpfs:file { read write getattr };
#line 3
allow logd tmpfs:dir { getattr search };
#line 3

#line 3


# logd is not allowed to write anywhere other than /data/misc/logd, and then
# only on userdebug or eng builds
# TODO: deal with tmpfs_domain pub/priv split properly
neverallow logd {
  file_type
  -logd_tmpfs
  -runtime_event_log_tags_file
  -coredump_file -misc_logd_file
}:file { create write append };

# protect the event-log-tags file
neverallow {
  domain
  -appdomain # covered below
  -bootstat
  -dumpstate
  -init
  -logd
  -logpersist
  -servicemanager
  -system_server
  -surfaceflinger
  -zygote
} runtime_event_log_tags_file:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

neverallow {
  appdomain
  -bluetooth
  -platform_app
  -priv_app
  -radio
  -shell
  -su
  -system_app
} runtime_event_log_tags_file:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
#line 1 "system/sepolicy/private/logpersist.te"
typeattribute logpersist coredomain;

# android debug log storage in logpersist domains (eng and userdebug only)

#line 4

#line 4
  
#line 4
allow logpersist cgroup:dir { open getattr read search ioctl lock };
#line 4
allow logpersist cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 4

#line 4

#line 4
  allow logpersist misc_logd_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 4
  allow logpersist misc_logd_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
#line 4

#line 4
  allow logpersist self:capability sys_nice;
#line 4
  allow logpersist pstorefs:dir search;
#line 4
  allow logpersist pstorefs:file { getattr open read ioctl lock map };
#line 4

#line 4
  
#line 4
# Group AID_LOG checked by filesystem & logd
#line 4
# to permit control commands
#line 4

#line 4

#line 4

#line 4
allow logpersist logd_socket:sock_file write;
#line 4
allow logpersist logd:unix_stream_socket connectto;
#line 4

#line 4

#line 4

#line 4
  
#line 4

#line 4

#line 4
allow logpersist logdr_socket:sock_file write;
#line 4
allow logpersist logd:unix_stream_socket connectto;
#line 4

#line 4

#line 4
  
#line 4
allow logpersist runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 4

#line 4

#line 19


# logpersist is allowed to write to /data/misc/log for userdebug and eng builds
neverallow logpersist { file_type -misc_logd_file -coredump_file }:file { create write append };
neverallow { domain -init -logpersist -logd -dumpstate } misc_logd_file:file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };
neverallow { domain -init -logpersist -logd } misc_logd_file:dir { add_name link relabelfrom remove_name rename reparent rmdir write };
#line 1 "system/sepolicy/private/mdnsd.te"
# mdns daemon

typeattribute mdnsd coredomain;
typeattribute mdnsd mlstrustedsubject;

type mdnsd_exec, exec_type, file_type;

#line 7

#line 7
# Allow the necessary permissions.
#line 7

#line 7
# Old domain may exec the file and transition to the new domain.
#line 7
allow init mdnsd_exec:file { getattr open read execute map };
#line 7
allow init mdnsd:process transition;
#line 7
# New domain is entered by executing the file.
#line 7
allow mdnsd mdnsd_exec:file { entrypoint open read execute getattr map };
#line 7
# New domain can send SIGCHLD to its caller.
#line 7

#line 7
# Enable AT_SECURE, i.e. libc secure mode.
#line 7
dontaudit init mdnsd:process noatsecure;
#line 7
# XXX dontaudit candidate but requires further study.
#line 7
allow init mdnsd:process { siginh rlimitinh };
#line 7

#line 7
# Make the transition occur by default.
#line 7
type_transition init mdnsd_exec:process mdnsd;
#line 7

#line 7

#line 7
type mdnsd_tmpfs, file_type;
#line 7
type_transition mdnsd tmpfs:file mdnsd_tmpfs;
#line 7
allow mdnsd mdnsd_tmpfs:file { read write getattr };
#line 7
allow mdnsd tmpfs:dir { getattr search };
#line 7

#line 7



#line 9
typeattribute mdnsd netdomain;
#line 9


# Read from /proc/net

#line 12
allow mdnsd proc_net:dir { open getattr read search ioctl lock };
#line 12
allow mdnsd proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 12

#line 1 "system/sepolicy/private/mediadrmserver.te"
typeattribute mediadrmserver coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init mediadrmserver_exec:file { getattr open read execute map };
#line 3
allow init mediadrmserver:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow mediadrmserver mediadrmserver_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init mediadrmserver:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init mediadrmserver:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init mediadrmserver_exec:process mediadrmserver;
#line 3

#line 3

#line 3
type mediadrmserver_tmpfs, file_type;
#line 3
type_transition mediadrmserver tmpfs:file mediadrmserver_tmpfs;
#line 3
allow mediadrmserver mediadrmserver_tmpfs:file { read write getattr };
#line 3
allow mediadrmserver tmpfs:dir { getattr search };
#line 3

#line 3


# allocate and use graphic buffers

#line 6
typeattribute mediadrmserver halclientdomain;
#line 6
typeattribute mediadrmserver hal_graphics_allocator_client;
#line 6

#line 6
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 6
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 6
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 6

#line 6
typeattribute mediadrmserver hal_graphics_allocator;
#line 6
# Find passthrough HAL implementations
#line 6
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 6
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 6
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 6

#line 6

auditallow mediadrmserver hal_graphics_allocator_server:binder call;

#line 1 "system/sepolicy/private/mediaextractor.te"
typeattribute mediaextractor coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init mediaextractor_exec:file { getattr open read execute map };
#line 3
allow init mediaextractor:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow mediaextractor mediaextractor_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init mediaextractor:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init mediaextractor:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init mediaextractor_exec:process mediaextractor;
#line 3

#line 3

#line 3
type mediaextractor_tmpfs, file_type;
#line 3
type_transition mediaextractor tmpfs:file mediaextractor_tmpfs;
#line 3
allow mediaextractor mediaextractor_tmpfs:file { read write getattr };
#line 3
allow mediaextractor tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/mediametrics.te"
typeattribute mediametrics coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init mediametrics_exec:file { getattr open read execute map };
#line 3
allow init mediametrics:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow mediametrics mediametrics_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init mediametrics:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init mediametrics:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init mediametrics_exec:process mediametrics;
#line 3

#line 3

#line 3
type mediametrics_tmpfs, file_type;
#line 3
type_transition mediametrics tmpfs:file mediametrics_tmpfs;
#line 3
allow mediametrics mediametrics_tmpfs:file { read write getattr };
#line 3
allow mediametrics tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/mediaprovider.te"
###
### A domain for android.process.media, which contains both
### MediaProvider and DownloadProvider and associated services.
###

typeattribute mediaprovider coredomain;

#line 7
typeattribute mediaprovider appdomain;
#line 7
# Label ashmem objects with our own unique type.
#line 7

#line 7
type mediaprovider_tmpfs, file_type;
#line 7
type_transition mediaprovider tmpfs:file mediaprovider_tmpfs;
#line 7
allow mediaprovider mediaprovider_tmpfs:file { read write getattr };
#line 7
allow mediaprovider tmpfs:dir { getattr search };
#line 7

#line 7
# Map with PROT_EXEC.
#line 7
allow mediaprovider mediaprovider_tmpfs:file execute;
#line 7


# DownloadProvider accesses the network.

#line 10
typeattribute mediaprovider netdomain;
#line 10


# DownloadProvider uses /cache.
allow mediaprovider cache_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow mediaprovider cache_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
# /cache is a symlink to /data/cache on some devices. Allow reading the link.
allow mediaprovider cache_file:lnk_file { getattr open read ioctl lock map };

allow mediaprovider app_api_service:service_manager find;
allow mediaprovider audioserver_service:service_manager find;
allow mediaprovider drmserver_service:service_manager find;
allow mediaprovider mediaserver_service:service_manager find;
allow mediaprovider surfaceflinger_service:service_manager find;

# Allow MediaProvider to read/write cached ringtones (opened by system).
allow mediaprovider ringtone_file:file { getattr read write };

# MtpServer uses /dev/mtp_usb
allow mediaprovider mtp_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# MtpServer uses /dev/usb-ffs/mtp
allow mediaprovider functionfs:dir search;
allow mediaprovider functionfs:file { { getattr open read ioctl lock map } { open append write lock map } };

# MtpServer sets sys.usb.ffs.mtp.ready

#line 35

#line 35
allow mediaprovider property_socket:sock_file write;
#line 35
allow mediaprovider init:unix_stream_socket connectto;
#line 35

#line 35
allow mediaprovider ffs_prop:property_service set;
#line 35

#line 35
allow mediaprovider ffs_prop:file { getattr open read ioctl lock map };
#line 35

#line 35

#line 1 "system/sepolicy/private/mediaserver.te"
typeattribute mediaserver coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init mediaserver_exec:file { getattr open read execute map };
#line 3
allow init mediaserver:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow mediaserver mediaserver_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init mediaserver:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init mediaserver:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init mediaserver_exec:process mediaserver;
#line 3

#line 3

#line 3
type mediaserver_tmpfs, file_type;
#line 3
type_transition mediaserver tmpfs:file mediaserver_tmpfs;
#line 3
allow mediaserver mediaserver_tmpfs:file { read write getattr };
#line 3
allow mediaserver tmpfs:dir { getattr search };
#line 3

#line 3


# allocate and use graphic buffers

#line 6
typeattribute mediaserver halclientdomain;
#line 6
typeattribute mediaserver hal_graphics_allocator_client;
#line 6

#line 6
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 6
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 6
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 6

#line 6
typeattribute mediaserver hal_graphics_allocator;
#line 6
# Find passthrough HAL implementations
#line 6
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 6
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 6
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 6

#line 6


# TODO(b/36375899): Remove this once OMX HAL is attributized and mediaserver is marked as a client
# of OMX HAL.
allow mediaserver hal_omx_hwservice:hwservice_manager find;
#line 1 "system/sepolicy/private/modprobe.te"
typeattribute modprobe coredomain;
#line 1 "system/sepolicy/private/mtp.te"
typeattribute mtp coredomain;
typeattribute mtp domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init mtp_exec:file { getattr open read execute map };
#line 4
allow init mtp:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow mtp mtp_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init mtp:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init mtp:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init mtp_exec:process mtp;
#line 4

#line 4

#line 4
type mtp_tmpfs, file_type;
#line 4
type_transition mtp tmpfs:file mtp_tmpfs;
#line 4
allow mtp mtp_tmpfs:file { read write getattr };
#line 4
allow mtp tmpfs:dir { getattr search };
#line 4

#line 4

#line 1 "system/sepolicy/private/net.te"
###
### Domain with network access
###

# Use network sockets.
allow netdomain self:tcp_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
allow netdomain self:{ udp_socket rawip_socket } { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
# Connect to ports.
allow netdomain port_type:tcp_socket name_connect;
# Bind to ports.
allow {netdomain -ephemeral_app} node_type:{ tcp_socket udp_socket } node_bind;
allow {netdomain -ephemeral_app} port_type:udp_socket name_bind;
allow {netdomain -ephemeral_app} port_type:tcp_socket name_bind;
# See changes to the routing table.
allow netdomain self:netlink_route_socket { create read getattr write setattr lock append bind connect getopt setopt shutdown nlmsg_read };

# Talks to netd via dnsproxyd socket.

#line 18

#line 18

#line 18
allow netdomain dnsproxyd_socket:sock_file write;
#line 18
allow netdomain netd:unix_stream_socket connectto;
#line 18

#line 18


# Talks to netd via fwmarkd socket.

#line 21

#line 21

#line 21
allow netdomain fwmarkd_socket:sock_file write;
#line 21
allow netdomain netd:unix_stream_socket connectto;
#line 21

#line 21


# Connect to mdnsd via mdnsd socket.

#line 24

#line 24

#line 24
allow netdomain mdnsd_socket:sock_file write;
#line 24
allow netdomain mdnsd:unix_stream_socket connectto;
#line 24

#line 24

#line 1 "system/sepolicy/private/netd.te"
typeattribute netd coredomain;
typeattribute netd domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init netd_exec:file { getattr open read execute map };
#line 4
allow init netd:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow netd netd_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init netd:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init netd:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init netd_exec:process netd;
#line 4

#line 4

#line 4
type netd_tmpfs, file_type;
#line 4
type_transition netd tmpfs:file netd_tmpfs;
#line 4
allow netd netd_tmpfs:file { read write getattr };
#line 4
allow netd tmpfs:dir { getattr search };
#line 4

#line 4


# Allow netd to spawn dnsmasq in it's own domain

#line 7
# Allow the necessary permissions.
#line 7

#line 7
# Old domain may exec the file and transition to the new domain.
#line 7
allow netd dnsmasq_exec:file { getattr open read execute map };
#line 7
allow netd dnsmasq:process transition;
#line 7
# New domain is entered by executing the file.
#line 7
allow dnsmasq dnsmasq_exec:file { entrypoint open read execute getattr map };
#line 7
# New domain can send SIGCHLD to its caller.
#line 7
allow dnsmasq netd:process sigchld;
#line 7
# Enable AT_SECURE, i.e. libc secure mode.
#line 7
dontaudit netd dnsmasq:process noatsecure;
#line 7
# XXX dontaudit candidate but requires further study.
#line 7
allow netd dnsmasq:process { siginh rlimitinh };
#line 7

#line 7
# Make the transition occur by default.
#line 7
type_transition netd dnsmasq_exec:process dnsmasq;
#line 7


# Allow netd to start clatd in its own domain

#line 10
# Allow the necessary permissions.
#line 10

#line 10
# Old domain may exec the file and transition to the new domain.
#line 10
allow netd clatd_exec:file { getattr open read execute map };
#line 10
allow netd clatd:process transition;
#line 10
# New domain is entered by executing the file.
#line 10
allow clatd clatd_exec:file { entrypoint open read execute getattr map };
#line 10
# New domain can send SIGCHLD to its caller.
#line 10
allow clatd netd:process sigchld;
#line 10
# Enable AT_SECURE, i.e. libc secure mode.
#line 10
dontaudit netd clatd:process noatsecure;
#line 10
# XXX dontaudit candidate but requires further study.
#line 10
allow netd clatd:process { siginh rlimitinh };
#line 10

#line 10
# Make the transition occur by default.
#line 10
type_transition netd clatd_exec:process clatd;
#line 10

#line 1 "system/sepolicy/private/netutils_wrapper.te"
typeattribute netutils_wrapper coredomain;


#line 3
allow netutils_wrapper system_file:dir { open getattr read search ioctl lock };
#line 3
allow netutils_wrapper system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 3
;

# For netutils (ip, iptables, tc)
allow netutils_wrapper self:capability net_raw;

allow netutils_wrapper system_file:file { execute execute_no_trans };
allow netutils_wrapper proc_net:file { open read getattr };
allow netutils_wrapper self:rawip_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netutils_wrapper self:udp_socket { create { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow netutils_wrapper self:capability net_admin;
# ip utils need everything but ioctl
allow netutils_wrapper self:netlink_route_socket ~ioctl;
allow netutils_wrapper self:netlink_xfrm_socket ~ioctl;

# For netutils (ndc) to be able to talk to netd
allow netutils_wrapper netd_socket:sock_file { open getattr read write append };
allow netutils_wrapper netd:unix_stream_socket { read getattr connectto };

# For /data/misc/net access to ndc and ip

#line 22
allow netutils_wrapper net_data_file:dir { open getattr read search ioctl lock };
#line 22
allow netutils_wrapper net_data_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 22



#line 24
# Allow the necessary permissions.
#line 24

#line 24
# Old domain may exec the file and transition to the new domain.
#line 24
allow {
#line 24
    domain
#line 24
    -coredomain
#line 24
    -appdomain
#line 24
} netutils_wrapper_exec:file { getattr open read execute map };
#line 24
allow {
#line 24
    domain
#line 24
    -coredomain
#line 24
    -appdomain
#line 24
} netutils_wrapper:process transition;
#line 24
# New domain is entered by executing the file.
#line 24
allow netutils_wrapper netutils_wrapper_exec:file { entrypoint open read execute getattr map };
#line 24
# New domain can send SIGCHLD to its caller.
#line 24
allow netutils_wrapper {
#line 24
    domain
#line 24
    -coredomain
#line 24
    -appdomain
#line 24
}:process sigchld;
#line 24
# Enable AT_SECURE, i.e. libc secure mode.
#line 24
dontaudit {
#line 24
    domain
#line 24
    -coredomain
#line 24
    -appdomain
#line 24
} netutils_wrapper:process noatsecure;
#line 24
# XXX dontaudit candidate but requires further study.
#line 24
allow {
#line 24
    domain
#line 24
    -coredomain
#line 24
    -appdomain
#line 24
} netutils_wrapper:process { siginh rlimitinh };
#line 24

#line 24
# Make the transition occur by default.
#line 24
type_transition {
#line 24
    domain
#line 24
    -coredomain
#line 24
    -appdomain
#line 24
} netutils_wrapper_exec:process netutils_wrapper;
#line 28

#line 1 "system/sepolicy/private/nfc.te"
# nfc subsystem
typeattribute nfc coredomain;

#line 3
typeattribute nfc appdomain;
#line 3
# Label ashmem objects with our own unique type.
#line 3

#line 3
type nfc_tmpfs, file_type;
#line 3
type_transition nfc tmpfs:file nfc_tmpfs;
#line 3
allow nfc nfc_tmpfs:file { read write getattr };
#line 3
allow nfc tmpfs:dir { getattr search };
#line 3

#line 3
# Map with PROT_EXEC.
#line 3
allow nfc nfc_tmpfs:file execute;
#line 3


#line 4
typeattribute nfc netdomain;
#line 4



#line 6
typeattribute nfc binderservicedomain;
#line 6


#line 7
  allow nfc nfc_service:service_manager { add find };
#line 7
  neverallow { domain -nfc } nfc_service:service_manager add;
#line 7



#line 9
typeattribute nfc halclientdomain;
#line 9
typeattribute nfc hal_nfc_client;
#line 9

#line 9
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 9
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 9
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 9

#line 9
typeattribute nfc hal_nfc;
#line 9
# Find passthrough HAL implementations
#line 9
allow hal_nfc system_file:dir { open getattr read search ioctl lock };
#line 9
allow hal_nfc vendor_file:dir { open getattr read search ioctl lock };
#line 9
allow hal_nfc vendor_file:file { read open getattr execute map };
#line 9

#line 9


# Data file accesses.
allow nfc nfc_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow nfc nfc_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# SoundPool loading and playback
allow nfc audioserver_service:service_manager find;
allow nfc drmserver_service:service_manager find;
allow nfc mediacodec_service:service_manager find;
allow nfc mediametrics_service:service_manager find;
allow nfc mediaextractor_service:service_manager find;
allow nfc mediaserver_service:service_manager find;

allow nfc radio_service:service_manager find;
allow nfc surfaceflinger_service:service_manager find;
allow nfc app_api_service:service_manager find;
allow nfc system_api_service:service_manager find;
allow nfc vr_manager_service:service_manager find;


#line 29

#line 29
allow nfc property_socket:sock_file write;
#line 29
allow nfc init:unix_stream_socket connectto;
#line 29

#line 29
allow nfc nfc_prop:property_service set;
#line 29

#line 29
allow nfc nfc_prop:file { getattr open read ioctl lock map };
#line 29

#line 29
;

# already open bugreport file descriptors may be shared with
# the nfc process, from a file in
# /data/data/com.android.shell/files/bugreports/bugreport-*.
allow nfc shell_data_file:file read;
#line 1 "system/sepolicy/private/otapreopt_chroot.te"
typeattribute otapreopt_chroot coredomain;

# Allow to transition to postinstall_ota, to run otapreopt in its own sandbox.

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow otapreopt_chroot postinstall_file:file { getattr open read execute map };
#line 4
allow otapreopt_chroot postinstall_dexopt:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow postinstall_dexopt postinstall_file:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4
allow postinstall_dexopt otapreopt_chroot:process sigchld;
#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit otapreopt_chroot postinstall_dexopt:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow otapreopt_chroot postinstall_dexopt:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition otapreopt_chroot postinstall_file:process postinstall_dexopt;
#line 4

#line 1 "system/sepolicy/private/otapreopt_slot.te"
typeattribute otapreopt_slot coredomain;

# Technically not a daemon but we do want the transition from init domain to
# cppreopts to occur.

#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init otapreopt_slot_exec:file { getattr open read execute map };
#line 5
allow init otapreopt_slot:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow otapreopt_slot otapreopt_slot_exec:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5

#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init otapreopt_slot:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init otapreopt_slot:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init otapreopt_slot_exec:process otapreopt_slot;
#line 5

#line 5

#line 5
type otapreopt_slot_tmpfs, file_type;
#line 5
type_transition otapreopt_slot tmpfs:file otapreopt_slot_tmpfs;
#line 5
allow otapreopt_slot otapreopt_slot_tmpfs:file { read write getattr };
#line 5
allow otapreopt_slot tmpfs:dir { getattr search };
#line 5

#line 5

#line 1 "system/sepolicy/private/performanced.te"
typeattribute performanced coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init performanced_exec:file { getattr open read execute map };
#line 3
allow init performanced:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow performanced performanced_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init performanced:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init performanced:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init performanced_exec:process performanced;
#line 3

#line 3

#line 3
type performanced_tmpfs, file_type;
#line 3
type_transition performanced tmpfs:file performanced_tmpfs;
#line 3
allow performanced performanced_tmpfs:file { read write getattr };
#line 3
allow performanced tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/perfprofd.te"

#line 1
  typeattribute perfprofd coredomain;
#line 1
  typeattribute perfprofd domain_deprecated;
#line 1
  
#line 1

#line 1
# Allow the necessary permissions.
#line 1

#line 1
# Old domain may exec the file and transition to the new domain.
#line 1
allow init perfprofd_exec:file { getattr open read execute map };
#line 1
allow init perfprofd:process transition;
#line 1
# New domain is entered by executing the file.
#line 1
allow perfprofd perfprofd_exec:file { entrypoint open read execute getattr map };
#line 1
# New domain can send SIGCHLD to its caller.
#line 1

#line 1
# Enable AT_SECURE, i.e. libc secure mode.
#line 1
dontaudit init perfprofd:process noatsecure;
#line 1
# XXX dontaudit candidate but requires further study.
#line 1
allow init perfprofd:process { siginh rlimitinh };
#line 1

#line 1
# Make the transition occur by default.
#line 1
type_transition init perfprofd_exec:process perfprofd;
#line 1

#line 1

#line 1
type perfprofd_tmpfs, file_type;
#line 1
type_transition perfprofd tmpfs:file perfprofd_tmpfs;
#line 1
allow perfprofd perfprofd_tmpfs:file { read write getattr };
#line 1
allow perfprofd tmpfs:dir { getattr search };
#line 1

#line 1

#line 5

#line 1 "system/sepolicy/private/platform_app.te"
###
### Apps signed with the platform key.
###

typeattribute platform_app coredomain;
typeattribute platform_app domain_deprecated;


#line 8
typeattribute platform_app appdomain;
#line 8
# Label ashmem objects with our own unique type.
#line 8

#line 8
type platform_app_tmpfs, file_type;
#line 8
type_transition platform_app tmpfs:file platform_app_tmpfs;
#line 8
allow platform_app platform_app_tmpfs:file { read write getattr };
#line 8
allow platform_app tmpfs:dir { getattr search };
#line 8

#line 8
# Map with PROT_EXEC.
#line 8
allow platform_app platform_app_tmpfs:file execute;
#line 8


# Access the network.

#line 11
typeattribute platform_app netdomain;
#line 11

# Access bluetooth.

#line 13
typeattribute platform_app bluetoothdomain;
#line 13

# Read from /data/local/tmp or /data/data/com.android.shell.
allow platform_app shell_data_file:dir search;
allow platform_app shell_data_file:file { open getattr read };
allow platform_app icon_file:file { open getattr read };
# Populate /data/app/vmdl*.tmp, /data/app-private/vmdl*.tmp files
# created by system server.
allow platform_app { apk_tmp_file apk_private_tmp_file }:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow platform_app { apk_tmp_file apk_private_tmp_file }:file { { getattr open read ioctl lock map } { open append write lock map } };
allow platform_app apk_private_data_file:dir search;
# ASEC
allow platform_app asec_apk_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow platform_app asec_apk_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access to /data/media.
allow platform_app media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow platform_app media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Write to /cache.
allow platform_app cache_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow platform_app cache_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Direct access to vold-mounted storage under /mnt/media_rw
# This is a performance optimization that allows platform apps to bypass the FUSE layer
allow platform_app mnt_media_rw_file:dir { open getattr read search ioctl lock };
allow platform_app vfat:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow platform_app vfat:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# com.android.systemui
allow platform_app rootfs:dir getattr;

allow platform_app audioserver_service:service_manager find;
allow platform_app cameraserver_service:service_manager find;
allow platform_app drmserver_service:service_manager find;
allow platform_app mediaserver_service:service_manager find;
allow platform_app mediametrics_service:service_manager find;
allow platform_app mediaextractor_service:service_manager find;
allow platform_app mediacodec_service:service_manager find;
allow platform_app mediadrmserver_service:service_manager find;
allow platform_app persistent_data_block_service:service_manager find;
allow platform_app radio_service:service_manager find;
allow platform_app surfaceflinger_service:service_manager find;
allow platform_app timezone_service:service_manager find;
allow platform_app app_api_service:service_manager find;
allow platform_app system_api_service:service_manager find;
allow platform_app vr_manager_service:service_manager find;

# Access to /data/preloads
allow platform_app preloads_data_file:file { getattr open read ioctl lock map };
allow platform_app preloads_data_file:dir { open getattr read search ioctl lock };
allow platform_app preloads_media_file:file { getattr open read ioctl lock map };
allow platform_app preloads_media_file:dir { open getattr read search ioctl lock };


#line 66
allow platform_app runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 66


###
### Neverallow rules
###

# app domains which access /dev/fuse should not run as platform_app
neverallow platform_app fuse_device:chr_file *;
#line 1 "system/sepolicy/private/postinstall.te"
typeattribute postinstall coredomain;


#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow postinstall otapreopt_chroot_exec:file { getattr open read execute map };
#line 3
allow postinstall otapreopt_chroot:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow otapreopt_chroot otapreopt_chroot_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3
allow otapreopt_chroot postinstall:process sigchld;
#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit postinstall otapreopt_chroot:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow postinstall otapreopt_chroot:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition postinstall otapreopt_chroot_exec:process otapreopt_chroot;
#line 3

#line 1 "system/sepolicy/private/postinstall_dexopt.te"
typeattribute postinstall_dexopt coredomain;

# Run dex2oat/patchoat in its own sandbox.
# We have to manually transition, as we don't have an entrypoint.

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow postinstall_dexopt postinstall_file:file { getattr open read execute map };
#line 5
allow postinstall_dexopt dex2oat:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow dex2oat postinstall_file:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow dex2oat postinstall_dexopt:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit postinstall_dexopt dex2oat:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow postinstall_dexopt dex2oat:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition postinstall_dexopt postinstall_file:process dex2oat;
#line 5

#line 1 "system/sepolicy/private/ppp.te"
typeattribute ppp coredomain;
typeattribute ppp domain_deprecated;


#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow mtp ppp_exec:file { getattr open read execute map };
#line 4
allow mtp ppp:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow ppp ppp_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4
allow ppp mtp:process sigchld;
#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit mtp ppp:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow mtp ppp:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition mtp ppp_exec:process ppp;
#line 4

#line 1 "system/sepolicy/private/preopt2cachename.te"
typeattribute preopt2cachename coredomain;
#line 1 "system/sepolicy/private/priv_app.te"
###
### A domain for further sandboxing privileged apps.
###

typeattribute priv_app coredomain;

#line 6
typeattribute priv_app appdomain;
#line 6
# Label ashmem objects with our own unique type.
#line 6

#line 6
type priv_app_tmpfs, file_type;
#line 6
type_transition priv_app tmpfs:file priv_app_tmpfs;
#line 6
allow priv_app priv_app_tmpfs:file { read write getattr };
#line 6
allow priv_app tmpfs:dir { getattr search };
#line 6

#line 6
# Map with PROT_EXEC.
#line 6
allow priv_app priv_app_tmpfs:file execute;
#line 6


# Access the network.

#line 9
typeattribute priv_app netdomain;
#line 9

# Access bluetooth.

#line 11
typeattribute priv_app bluetoothdomain;
#line 11


# Allow the allocation and use of ptys
# Used by: https://play.privileged.com/store/apps/details?id=jackpal.androidterm

#line 15
# Each domain gets a unique devpts type.
#line 15
type priv_app_devpts, fs_type;
#line 15
# Label the pty with the unique type when created.
#line 15
type_transition priv_app devpts:chr_file priv_app_devpts;
#line 15
# Allow use of the pty after creation.
#line 15
allow priv_app priv_app_devpts:chr_file { open getattr read write ioctl };
#line 15
allowxperm priv_app priv_app_devpts:chr_file ioctl {
#line 15
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 15
  0x0000540b 0x00005410 0x0000540f
#line 15
};
#line 15
# TIOCSTI is only ever used for exploits. Block it.
#line 15
# b/33073072, b/7530569
#line 15
# http://www.openwall.com/lists/oss-security/2016/09/26/14
#line 15
neverallowxperm * priv_app_devpts:chr_file ioctl 0x00005412;
#line 15
# Note: devpts:dir search and ptmx_device:chr_file rw_file_perms
#line 15
# allowed to everyone via domain.te.
#line 15


# webview crash handling depends on self ptrace (b/27697529, b/20150694, b/19277529#comment7)
allow priv_app self:process ptrace;

# Some apps ship with shared libraries that they write out
# to their sandbox directory and then dlopen().
allow priv_app app_data_file:file execute;

allow priv_app audioserver_service:service_manager find;
allow priv_app cameraserver_service:service_manager find;
allow priv_app drmserver_service:service_manager find;
allow priv_app mediacodec_service:service_manager find;
allow priv_app mediametrics_service:service_manager find;
allow priv_app mediadrmserver_service:service_manager find;
allow priv_app mediaextractor_service:service_manager find;
allow priv_app mediaserver_service:service_manager find;
allow priv_app nfc_service:service_manager find;
allow priv_app oem_lock_service:service_manager find;
allow priv_app radio_service:service_manager find;
allow priv_app surfaceflinger_service:service_manager find;
allow priv_app app_api_service:service_manager find;
allow priv_app system_api_service:service_manager find;
allow priv_app persistent_data_block_service:service_manager find;
allow priv_app recovery_service:service_manager find;

# Write to /cache.
allow priv_app { cache_file cache_recovery_file }:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow priv_app { cache_file cache_recovery_file }:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
# /cache is a symlink to /data/cache on some devices. Allow reading the link.
allow priv_app cache_file:lnk_file { getattr open read ioctl lock map };

# Write to /data/ota_package for OTA packages.
allow priv_app ota_package_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow priv_app ota_package_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access to /data/media.
allow priv_app media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow priv_app media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Used by Finsky / Android "Verify Apps" functionality when
# running "adb install foo.apk".
allow priv_app shell_data_file:file { getattr open read ioctl lock map };
allow priv_app shell_data_file:dir { open getattr read search ioctl lock };

# Allow verifier to access staged apks.
allow priv_app { apk_tmp_file apk_private_tmp_file }:dir { open getattr read search ioctl lock };
allow priv_app { apk_tmp_file apk_private_tmp_file }:file { getattr open read ioctl lock map };

# b/18504118: Allow reads from /data/anr/traces.txt
allow priv_app anr_data_file:file { getattr open read ioctl lock map };

# Allow GMS core to access perfprofd output, which is stored
# in /data/misc/perfprofd/. GMS core will need to list all
# data stored in that directory to process them one by one.

#line 70
  allow priv_app perfprofd_data_file:file { getattr open read ioctl lock map };
#line 70
  allow priv_app perfprofd_data_file:dir { open getattr read search ioctl lock };
#line 73


# For AppFuse.
allow priv_app vold:fd use;
allow priv_app fuse_device:chr_file { read write };

# /sys and /proc access

#line 80
allow priv_app sysfs_type:dir { open getattr read search ioctl lock };
#line 80
allow priv_app sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 80


#line 81
allow priv_app proc:dir { open getattr read search ioctl lock };
#line 81
allow priv_app proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 81


#line 82
allow priv_app rootfs:dir { open getattr read search ioctl lock };
#line 82
allow priv_app rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 82


# Allow GMS core to open kernel config for OTA matching through libvintf
allow priv_app config_gz:file { open read getattr };

# access the mac address
allowxperm priv_app self:udp_socket ioctl 0x00008927;

# Allow GMS core to communicate with update_engine for A/B update.

#line 91
# Call the server domain and optionally transfer references to it.
#line 91
allow priv_app update_engine:binder { call transfer };
#line 91
# Allow the serverdomain to transfer references to the client on the reply.
#line 91
allow update_engine priv_app:binder transfer;
#line 91
# Receive and use open files from the server.
#line 91
allow priv_app update_engine:fd use;
#line 91

allow priv_app update_engine_service:service_manager find;

# Allow GMS core to communicate with dumpsys storaged.

#line 95
# Call the server domain and optionally transfer references to it.
#line 95
allow priv_app storaged:binder { call transfer };
#line 95
# Allow the serverdomain to transfer references to the client on the reply.
#line 95
allow storaged priv_app:binder transfer;
#line 95
# Receive and use open files from the server.
#line 95
allow priv_app storaged:fd use;
#line 95

allow priv_app storaged_service:service_manager find;

# Allow Phone to read/write cached ringtones (opened by system).
allow priv_app ringtone_file:file { getattr read write };

# Access to /data/preloads
allow priv_app preloads_data_file:file { getattr open read ioctl lock map };
allow priv_app preloads_data_file:dir { open getattr read search ioctl lock };
allow priv_app preloads_media_file:file { getattr open read ioctl lock map };
allow priv_app preloads_media_file:dir { open getattr read search ioctl lock };

# Allow privileged apps (e.g. GMS core) to generate unique hardware IDs
allow priv_app keystore:keystore_key gen_unique_id;

# Allow GMS core to access /sys/fs/selinux/policyvers for compatibility check
allow priv_app selinuxfs:file { getattr open read ioctl lock map };


#line 113
allow priv_app runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 113


# suppress denials when safetynet scans /system
dontaudit priv_app exec_type:file getattr;

###
### neverallow rules
###

# Receive or send uevent messages.
neverallow priv_app domain:netlink_kobject_uevent_socket *;

# Receive or send generic netlink messages
neverallow priv_app domain:netlink_socket *;

# Too much leaky information in debugfs. It's a security
# best practice to ensure these files aren't readable.
neverallow priv_app debugfs:file read;

# Do not allow privileged apps to register services.
# Only trusted components of Android should be registering
# services.
neverallow priv_app service_manager_type:service_manager add;

# Do not allow privileged apps to connect to the property service
# or set properties. b/10243159
neverallow priv_app property_socket:sock_file write;
neverallow priv_app init:unix_stream_socket connectto;
neverallow priv_app property_type:property_service set;

# Do not allow priv_app to be assigned mlstrustedsubject.
# This would undermine the per-user isolation model being
# enforced via levelFrom=user in seapp_contexts and the mls
# constraints.  As there is no direct way to specify a neverallow
# on attribute assignment, this relies on the fact that fork
# permission only makes sense within a domain (hence should
# never be granted to any other domain within mlstrustedsubject)
# and priv_app is allowed fork permission to itself.
neverallow priv_app mlstrustedsubject:process fork;

# Do not allow priv_app to hard link to any files.
# In particular, if priv_app links to other app data
# files, installd will not be able to guarantee the deletion
# of the linked to file. Hard links also contribute to security
# bugs, so we want to ensure priv_app never has this
# capability.
neverallow priv_app file_type:file link;
#line 1 "system/sepolicy/private/profman.te"
typeattribute profman coredomain;
#line 1 "system/sepolicy/private/racoon.te"
typeattribute racoon coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init racoon_exec:file { getattr open read execute map };
#line 3
allow init racoon:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow racoon racoon_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init racoon:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init racoon:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init racoon_exec:process racoon;
#line 3

#line 3

#line 3
type racoon_tmpfs, file_type;
#line 3
type_transition racoon tmpfs:file racoon_tmpfs;
#line 3
allow racoon racoon_tmpfs:file { read write getattr };
#line 3
allow racoon tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/radio.te"
typeattribute radio coredomain;
typeattribute radio domain_deprecated;


#line 4
typeattribute radio appdomain;
#line 4
# Label ashmem objects with our own unique type.
#line 4

#line 4
type radio_tmpfs, file_type;
#line 4
type_transition radio tmpfs:file radio_tmpfs;
#line 4
allow radio radio_tmpfs:file { read write getattr };
#line 4
allow radio tmpfs:dir { getattr search };
#line 4

#line 4
# Map with PROT_EXEC.
#line 4
allow radio radio_tmpfs:file execute;
#line 4



#line 6
allow radio runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 6

#line 1 "system/sepolicy/private/recovery.te"
typeattribute recovery coredomain;
typeattribute recovery domain_deprecated;
#line 1 "system/sepolicy/private/recovery_persist.te"
typeattribute recovery_persist coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init recovery_persist_exec:file { getattr open read execute map };
#line 3
allow init recovery_persist:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow recovery_persist recovery_persist_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init recovery_persist:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init recovery_persist:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init recovery_persist_exec:process recovery_persist;
#line 3

#line 3

#line 3
type recovery_persist_tmpfs, file_type;
#line 3
type_transition recovery_persist tmpfs:file recovery_persist_tmpfs;
#line 3
allow recovery_persist recovery_persist_tmpfs:file { read write getattr };
#line 3
allow recovery_persist tmpfs:dir { getattr search };
#line 3

#line 3


# recovery_persist is not allowed to write anywhere other than recovery_data_file
# TODO: deal with tmpfs_domain pub/priv split properly
neverallow recovery_persist { file_type -recovery_data_file -recovery_persist_tmpfs -coredump_file }:file write;
#line 1 "system/sepolicy/private/recovery_refresh.te"
typeattribute recovery_refresh coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init recovery_refresh_exec:file { getattr open read execute map };
#line 3
allow init recovery_refresh:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow recovery_refresh recovery_refresh_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init recovery_refresh:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init recovery_refresh:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init recovery_refresh_exec:process recovery_refresh;
#line 3

#line 3

#line 3
type recovery_refresh_tmpfs, file_type;
#line 3
type_transition recovery_refresh tmpfs:file recovery_refresh_tmpfs;
#line 3
allow recovery_refresh recovery_refresh_tmpfs:file { read write getattr };
#line 3
allow recovery_refresh tmpfs:dir { getattr search };
#line 3

#line 3


# recovery_refresh is not allowed to write anywhere
# TODO: deal with tmpfs_domain pub/priv split properly
neverallow recovery_refresh { file_type -recovery_refresh_tmpfs -coredump_file }:file write;
#line 1 "system/sepolicy/private/runas.te"
typeattribute runas coredomain;
typeattribute runas domain_deprecated;

# ndk-gdb invokes adb shell run-as.

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow shell runas_exec:file { getattr open read execute map };
#line 5
allow shell runas:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow runas runas_exec:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow runas shell:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit shell runas:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow shell runas:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition shell runas_exec:process runas;
#line 5

#line 1 "system/sepolicy/private/sdcardd.te"
typeattribute sdcardd coredomain;
typeattribute sdcardd domain_deprecated;

type_transition sdcardd system_data_file:{ dir file } media_rw_data_file;
#line 1 "system/sepolicy/private/servicemanager.te"
typeattribute servicemanager coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init servicemanager_exec:file { getattr open read execute map };
#line 3
allow init servicemanager:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow servicemanager servicemanager_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init servicemanager:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init servicemanager:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init servicemanager_exec:process servicemanager;
#line 3

#line 3

#line 3
type servicemanager_tmpfs, file_type;
#line 3
type_transition servicemanager tmpfs:file servicemanager_tmpfs;
#line 3
allow servicemanager servicemanager_tmpfs:file { read write getattr };
#line 3
allow servicemanager tmpfs:dir { getattr search };
#line 3

#line 3



#line 5
allow servicemanager runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 5

#line 1 "system/sepolicy/private/sgdisk.te"
typeattribute sgdisk coredomain;
#line 1 "system/sepolicy/private/shared_relro.te"
typeattribute shared_relro coredomain;
typeattribute shared_relro domain_deprecated;

# The shared relro process is a Java program forked from the zygote, so it
# inherits from app to get basic permissions it needs to run.

#line 6
typeattribute shared_relro appdomain;
#line 6
# Label ashmem objects with our own unique type.
#line 6

#line 6
type shared_relro_tmpfs, file_type;
#line 6
type_transition shared_relro tmpfs:file shared_relro_tmpfs;
#line 6
allow shared_relro shared_relro_tmpfs:file { read write getattr };
#line 6
allow shared_relro tmpfs:dir { getattr search };
#line 6

#line 6
# Map with PROT_EXEC.
#line 6
allow shared_relro shared_relro_tmpfs:file execute;
#line 6

#line 1 "system/sepolicy/private/shell.te"
typeattribute shell coredomain;

# allow shell input injection
allow shell uhid_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# systrace support - allow atrace to run
allow shell debugfs_tracing:dir { open getattr read search ioctl lock };
allow shell debugfs_tracing:file { { getattr open read ioctl lock map } { open append write lock map } };
allow shell debugfs_trace_marker:file getattr;
allow shell atrace_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# read config.gz for CTS purposes
allow shell config_gz:file { getattr open read ioctl lock map };


#line 15
  allow shell debugfs_tracing_debug:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 17


# Run app_process.
# XXX Transition into its own domain?

#line 21
typeattribute shell appdomain;
#line 21
# Label ashmem objects with our own unique type.
#line 21

#line 21
type shell_tmpfs, file_type;
#line 21
type_transition shell tmpfs:file shell_tmpfs;
#line 21
allow shell shell_tmpfs:file { read write getattr };
#line 21
allow shell tmpfs:dir { getattr search };
#line 21

#line 21
# Map with PROT_EXEC.
#line 21
allow shell shell_tmpfs:file execute;
#line 21


# allow shell to call dumpsys storaged

#line 24
# Call the server domain and optionally transfer references to it.
#line 24
allow shell storaged:binder { call transfer };
#line 24
# Allow the serverdomain to transfer references to the client on the reply.
#line 24
allow storaged shell:binder transfer;
#line 24
# Receive and use open files from the server.
#line 24
allow shell storaged:fd use;
#line 24


# Perform SELinux access checks, needed for CTS

#line 27

#line 27
allow shell selinuxfs:dir { open getattr read search ioctl lock };
#line 27
allow shell selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 27

#line 27
allow shell selinuxfs:file { open append write lock map };
#line 27
allow shell kernel:security compute_av;
#line 27
allow shell self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 27


#line 28

#line 28
allow shell selinuxfs:dir { open getattr read search ioctl lock };
#line 28
allow shell selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 28

#line 28
allow shell selinuxfs:file { open append write lock map };
#line 28
allow shell kernel:security check_context;
#line 28

#line 1 "system/sepolicy/private/slideshow.te"
typeattribute slideshow coredomain;
#line 1 "system/sepolicy/private/storaged.te"
# storaged daemon
type storaged, domain, coredomain, mlstrustedsubject;
type storaged_exec, exec_type, file_type;


#line 5

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow init storaged_exec:file { getattr open read execute map };
#line 5
allow init storaged:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow storaged storaged_exec:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5

#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit init storaged:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow init storaged:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition init storaged_exec:process storaged;
#line 5

#line 5

#line 5
type storaged_tmpfs, file_type;
#line 5
type_transition storaged tmpfs:file storaged_tmpfs;
#line 5
allow storaged storaged_tmpfs:file { read write getattr };
#line 5
allow storaged tmpfs:dir { getattr search };
#line 5

#line 5


# Read access to pseudo filesystems

#line 8
allow storaged sysfs_type:dir { open getattr read search ioctl lock };
#line 8
allow storaged sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 8


#line 9
allow storaged proc_net:dir { open getattr read search ioctl lock };
#line 9
allow storaged proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 9


#line 10
allow storaged domain:dir { open getattr read search ioctl lock };
#line 10
allow storaged domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 10


# Read /proc/uid_io/stats
allow storaged proc_uid_io_stats:file { getattr open read ioctl lock map };

# Read /data/system/packages.list
allow storaged system_data_file:file { getattr open read ioctl lock map };


#line 18
  # Read access to debugfs
#line 18
  allow storaged debugfs_mmc:dir search;
#line 18
  allow storaged debugfs_mmc:file { getattr open read ioctl lock map };
#line 22


# Needed to provide debug dump output via dumpsys pipes.
allow storaged shell:fd use;
allow storaged shell:fifo_file write;

# Needed for GMScore to call dumpsys storaged
allow storaged priv_app:fd use;
allow storaged app_data_file:file write;
allow storaged permission_service:service_manager find;

# Binder permissions

#line 34
  allow storaged storaged_service:service_manager { add find };
#line 34
  neverallow { domain -storaged } storaged_service:service_manager add;
#line 34



#line 36
# Call the servicemanager and transfer references to it.
#line 36
allow storaged servicemanager:binder { call transfer };
#line 36
# servicemanager performs getpidcon on clients.
#line 36
allow servicemanager storaged:dir search;
#line 36
allow servicemanager storaged:file { read open };
#line 36
allow servicemanager storaged:process getattr;
#line 36
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 36
# all domains in domain.te.
#line 36


#line 37
# Call the server domain and optionally transfer references to it.
#line 37
allow storaged system_server:binder { call transfer };
#line 37
# Allow the serverdomain to transfer references to the client on the reply.
#line 37
allow system_server storaged:binder transfer;
#line 37
# Receive and use open files from the server.
#line 37
allow storaged system_server:fd use;
#line 37


# use batteryproperties service
allow storaged batteryproperties_service:service_manager find;

#line 41
# Call the server domain and optionally transfer references to it.
#line 41
allow storaged healthd:binder { call transfer };
#line 41
# Allow the serverdomain to transfer references to the client on the reply.
#line 41
allow healthd storaged:binder transfer;
#line 41
# Receive and use open files from the server.
#line 41
allow storaged healthd:fd use;
#line 41


# Implements a dumpsys interface.
allow storaged dumpstate:fd use;

# use a subset of the package manager service
allow storaged package_native_service:service_manager find;

# Kernel does extra check on CAP_DAC_OVERRIDE for libbinder when storaged is
# running as root. See b/35323867 #3.
dontaudit storaged self:capability dac_override;

###
### neverallow
###
neverallow storaged domain:process ptrace;
neverallow storaged self:{ capability capability2 } *;
#line 1 "system/sepolicy/private/su.te"

#line 1
  typeattribute su coredomain;
#line 1

#line 1
  
#line 1
# Allow the necessary permissions.
#line 1

#line 1
# Old domain may exec the file and transition to the new domain.
#line 1
allow shell su_exec:file { getattr open read execute map };
#line 1
allow shell su:process transition;
#line 1
# New domain is entered by executing the file.
#line 1
allow su su_exec:file { entrypoint open read execute getattr map };
#line 1
# New domain can send SIGCHLD to its caller.
#line 1
allow su shell:process sigchld;
#line 1
# Enable AT_SECURE, i.e. libc secure mode.
#line 1
dontaudit shell su:process noatsecure;
#line 1
# XXX dontaudit candidate but requires further study.
#line 1
allow shell su:process { siginh rlimitinh };
#line 1

#line 1
# Make the transition occur by default.
#line 1
type_transition shell su_exec:process su;
#line 1

#line 1
  # Allow dumpstate to call su on userdebug / eng builds to collect
#line 1
  # additional information.
#line 1
  
#line 1
# Allow the necessary permissions.
#line 1

#line 1
# Old domain may exec the file and transition to the new domain.
#line 1
allow dumpstate su_exec:file { getattr open read execute map };
#line 1
allow dumpstate su:process transition;
#line 1
# New domain is entered by executing the file.
#line 1
allow su su_exec:file { entrypoint open read execute getattr map };
#line 1
# New domain can send SIGCHLD to its caller.
#line 1
allow su dumpstate:process sigchld;
#line 1
# Enable AT_SECURE, i.e. libc secure mode.
#line 1
dontaudit dumpstate su:process noatsecure;
#line 1
# XXX dontaudit candidate but requires further study.
#line 1
allow dumpstate su:process { siginh rlimitinh };
#line 1

#line 1
# Make the transition occur by default.
#line 1
type_transition dumpstate su_exec:process su;
#line 1

#line 1

#line 1
  # Make sure that dumpstate runs the same from the "su" domain as
#line 1
  # from the "init" domain.
#line 1
  
#line 1
# Allow the necessary permissions.
#line 1

#line 1
# Old domain may exec the file and transition to the new domain.
#line 1
allow su dumpstate_exec:file { getattr open read execute map };
#line 1
allow su dumpstate:process transition;
#line 1
# New domain is entered by executing the file.
#line 1
allow dumpstate dumpstate_exec:file { entrypoint open read execute getattr map };
#line 1
# New domain can send SIGCHLD to its caller.
#line 1
allow dumpstate su:process sigchld;
#line 1
# Enable AT_SECURE, i.e. libc secure mode.
#line 1
dontaudit su dumpstate:process noatsecure;
#line 1
# XXX dontaudit candidate but requires further study.
#line 1
allow su dumpstate:process { siginh rlimitinh };
#line 1

#line 1
# Make the transition occur by default.
#line 1
type_transition su dumpstate_exec:process dumpstate;
#line 1

#line 1

#line 1
  # Put the incident command into its domain so it is the same on user, userdebug and eng.
#line 1
  
#line 1
# Allow the necessary permissions.
#line 1

#line 1
# Old domain may exec the file and transition to the new domain.
#line 1
allow su incident_exec:file { getattr open read execute map };
#line 1
allow su incident:process transition;
#line 1
# New domain is entered by executing the file.
#line 1
allow incident incident_exec:file { entrypoint open read execute getattr map };
#line 1
# New domain can send SIGCHLD to its caller.
#line 1
allow incident su:process sigchld;
#line 1
# Enable AT_SECURE, i.e. libc secure mode.
#line 1
dontaudit su incident:process noatsecure;
#line 1
# XXX dontaudit candidate but requires further study.
#line 1
allow su incident:process { siginh rlimitinh };
#line 1

#line 1
# Make the transition occur by default.
#line 1
type_transition su incident_exec:process incident;
#line 1

#line 1

#line 1
# su is also permissive to permit setenforce.
#line 1
  permissive su;
#line 1

#line 1
  
#line 1
typeattribute su appdomain;
#line 1
# Label ashmem objects with our own unique type.
#line 1

#line 1
type su_tmpfs, file_type;
#line 1
type_transition su tmpfs:file su_tmpfs;
#line 1
allow su su_tmpfs:file { read write getattr };
#line 1
allow su tmpfs:dir { getattr search };
#line 1

#line 1
# Map with PROT_EXEC.
#line 1
allow su su_tmpfs:file execute;
#line 1

#line 20

#line 1 "system/sepolicy/private/surfaceflinger.te"
# surfaceflinger - display compositor service

typeattribute surfaceflinger coredomain;

type surfaceflinger_exec, exec_type, file_type;

#line 6

#line 6
# Allow the necessary permissions.
#line 6

#line 6
# Old domain may exec the file and transition to the new domain.
#line 6
allow init surfaceflinger_exec:file { getattr open read execute map };
#line 6
allow init surfaceflinger:process transition;
#line 6
# New domain is entered by executing the file.
#line 6
allow surfaceflinger surfaceflinger_exec:file { entrypoint open read execute getattr map };
#line 6
# New domain can send SIGCHLD to its caller.
#line 6

#line 6
# Enable AT_SECURE, i.e. libc secure mode.
#line 6
dontaudit init surfaceflinger:process noatsecure;
#line 6
# XXX dontaudit candidate but requires further study.
#line 6
allow init surfaceflinger:process { siginh rlimitinh };
#line 6

#line 6
# Make the transition occur by default.
#line 6
type_transition init surfaceflinger_exec:process surfaceflinger;
#line 6

#line 6

#line 6
type surfaceflinger_tmpfs, file_type;
#line 6
type_transition surfaceflinger tmpfs:file surfaceflinger_tmpfs;
#line 6
allow surfaceflinger surfaceflinger_tmpfs:file { read write getattr };
#line 6
allow surfaceflinger tmpfs:dir { getattr search };
#line 6

#line 6


typeattribute surfaceflinger mlstrustedsubject;
typeattribute surfaceflinger display_service_server;


#line 11
allow surfaceflinger runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 11


# Perform HwBinder IPC.

#line 14
typeattribute surfaceflinger halclientdomain;
#line 14
typeattribute surfaceflinger hal_graphics_allocator_client;
#line 14

#line 14
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 14
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 14
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 14

#line 14
typeattribute surfaceflinger hal_graphics_allocator;
#line 14
# Find passthrough HAL implementations
#line 14
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 14
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 14
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 14

#line 14


#line 15
typeattribute surfaceflinger halclientdomain;
#line 15
typeattribute surfaceflinger hal_graphics_composer_client;
#line 15

#line 15
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 15
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 15
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 15

#line 15
typeattribute surfaceflinger hal_graphics_composer;
#line 15
# Find passthrough HAL implementations
#line 15
allow hal_graphics_composer system_file:dir { open getattr read search ioctl lock };
#line 15
allow hal_graphics_composer vendor_file:dir { open getattr read search ioctl lock };
#line 15
allow hal_graphics_composer vendor_file:file { read open getattr execute map };
#line 15

#line 15


#line 16
typeattribute surfaceflinger halclientdomain;
#line 16
typeattribute surfaceflinger hal_configstore_client;
#line 16

#line 16
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 16
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 16
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 16

#line 16
typeattribute surfaceflinger hal_configstore;
#line 16
# Find passthrough HAL implementations
#line 16
allow hal_configstore system_file:dir { open getattr read search ioctl lock };
#line 16
allow hal_configstore vendor_file:dir { open getattr read search ioctl lock };
#line 16
allow hal_configstore vendor_file:file { read open getattr execute map };
#line 16

#line 16

allow surfaceflinger hidl_token_hwservice:hwservice_manager find;

# Perform Binder IPC.

#line 20
# Call the servicemanager and transfer references to it.
#line 20
allow surfaceflinger servicemanager:binder { call transfer };
#line 20
# servicemanager performs getpidcon on clients.
#line 20
allow servicemanager surfaceflinger:dir search;
#line 20
allow servicemanager surfaceflinger:file { read open };
#line 20
allow servicemanager surfaceflinger:process getattr;
#line 20
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 20
# all domains in domain.te.
#line 20


#line 21
# Call the server domain and optionally transfer references to it.
#line 21
allow surfaceflinger binderservicedomain:binder { call transfer };
#line 21
# Allow the serverdomain to transfer references to the client on the reply.
#line 21
allow binderservicedomain surfaceflinger:binder transfer;
#line 21
# Receive and use open files from the server.
#line 21
allow surfaceflinger binderservicedomain:fd use;
#line 21


#line 22
# Call the server domain and optionally transfer references to it.
#line 22
allow surfaceflinger appdomain:binder { call transfer };
#line 22
# Allow the serverdomain to transfer references to the client on the reply.
#line 22
allow appdomain surfaceflinger:binder transfer;
#line 22
# Receive and use open files from the server.
#line 22
allow surfaceflinger appdomain:fd use;
#line 22


#line 23
# Call the server domain and optionally transfer references to it.
#line 23
allow surfaceflinger bootanim:binder { call transfer };
#line 23
# Allow the serverdomain to transfer references to the client on the reply.
#line 23
allow bootanim surfaceflinger:binder transfer;
#line 23
# Receive and use open files from the server.
#line 23
allow surfaceflinger bootanim:fd use;
#line 23


#line 24
typeattribute surfaceflinger binderservicedomain;
#line 24


# Binder IPC to bu, presently runs in adbd domain.

#line 27
# Call the server domain and optionally transfer references to it.
#line 27
allow surfaceflinger adbd:binder { call transfer };
#line 27
# Allow the serverdomain to transfer references to the client on the reply.
#line 27
allow adbd surfaceflinger:binder transfer;
#line 27
# Receive and use open files from the server.
#line 27
allow surfaceflinger adbd:fd use;
#line 27


# Read /proc/pid files for Binder clients.

#line 30
allow surfaceflinger binderservicedomain:dir { open getattr read search ioctl lock };
#line 30
allow surfaceflinger binderservicedomain:{ file lnk_file } { getattr open read ioctl lock map };
#line 30


#line 31
allow surfaceflinger appdomain:dir { open getattr read search ioctl lock };
#line 31
allow surfaceflinger appdomain:{ file lnk_file } { getattr open read ioctl lock map };
#line 31


# Access the GPU.
allow surfaceflinger gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Access /dev/graphics/fb0.
allow surfaceflinger graphics_device:dir search;
allow surfaceflinger graphics_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Access /dev/video1.
allow surfaceflinger video_device:dir { open getattr read search ioctl lock };
allow surfaceflinger video_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Create and use netlink kobject uevent sockets.
allow surfaceflinger self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Set properties.

#line 48

#line 48
allow surfaceflinger property_socket:sock_file write;
#line 48
allow surfaceflinger init:unix_stream_socket connectto;
#line 48

#line 48
allow surfaceflinger system_prop:property_service set;
#line 48

#line 48
allow surfaceflinger system_prop:file { getattr open read ioctl lock map };
#line 48

#line 48


#line 49

#line 49
allow surfaceflinger property_socket:sock_file write;
#line 49
allow surfaceflinger init:unix_stream_socket connectto;
#line 49

#line 49
allow surfaceflinger ctl_bootanim_prop:property_service set;
#line 49

#line 49
allow surfaceflinger ctl_bootanim_prop:file { getattr open read ioctl lock map };
#line 49

#line 49


# Use open files supplied by an app.
allow surfaceflinger appdomain:fd use;
allow surfaceflinger app_data_file:file { read write };

# Use socket supplied by adbd, for cmd gpu vkjson etc.
allow surfaceflinger adbd:unix_stream_socket { read write getattr };

# Allow a dumpstate triggered screenshot

#line 59
# Call the server domain and optionally transfer references to it.
#line 59
allow surfaceflinger dumpstate:binder { call transfer };
#line 59
# Allow the serverdomain to transfer references to the client on the reply.
#line 59
allow dumpstate surfaceflinger:binder transfer;
#line 59
# Receive and use open files from the server.
#line 59
allow surfaceflinger dumpstate:fd use;
#line 59


#line 60
# Call the server domain and optionally transfer references to it.
#line 60
allow surfaceflinger shell:binder { call transfer };
#line 60
# Allow the serverdomain to transfer references to the client on the reply.
#line 60
allow shell surfaceflinger:binder transfer;
#line 60
# Receive and use open files from the server.
#line 60
allow surfaceflinger shell:fd use;
#line 60


#line 61
allow surfaceflinger dumpstate:dir { open getattr read search ioctl lock };
#line 61
allow surfaceflinger dumpstate:{ file lnk_file } { getattr open read ioctl lock map };
#line 61


# Needed on some devices for playing DRM protected content,
# but seems expected and appropriate for all devices.
allow surfaceflinger tee_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };


# media.player service

#line 69
  allow surfaceflinger gpu_service:service_manager { add find };
#line 69
  neverallow { domain -surfaceflinger } gpu_service:service_manager add;
#line 69


# do not use add_service() as hal_graphics_composer_default may be the
# provider as well
#add_service(surfaceflinger, surfaceflinger_service)
allow surfaceflinger surfaceflinger_service:service_manager { add find };

allow surfaceflinger mediaserver_service:service_manager find;
allow surfaceflinger permission_service:service_manager find;
allow surfaceflinger power_service:service_manager find;
allow surfaceflinger vr_manager_service:service_manager find;
allow surfaceflinger window_service:service_manager find;


# allow self to set SCHED_FIFO
allow surfaceflinger self:capability sys_nice;
allow surfaceflinger proc_meminfo:file { getattr open read ioctl lock map };

#line 86
allow surfaceflinger cgroup:dir { open getattr read search ioctl lock };
#line 86
allow surfaceflinger cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 86


#line 87
allow surfaceflinger sysfs_type:dir { open getattr read search ioctl lock };
#line 87
allow surfaceflinger sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 87


#line 88
allow surfaceflinger system_file:dir { open getattr read search ioctl lock };
#line 88
allow surfaceflinger system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 88

allow surfaceflinger tmpfs:dir { open getattr read search ioctl lock };
allow surfaceflinger system_server:fd use;
allow surfaceflinger ion_device:chr_file { getattr open read ioctl lock map };

# pdx IPC

#line 94
# Mark the server domain as a PDX server.
#line 94
typeattribute surfaceflinger pdx_display_client_server_type;
#line 94
# Allow the init process to create the initial endpoint socket.
#line 94
allow init pdx_display_client_endpoint_socket_type:unix_stream_socket { create bind };
#line 94
# Allow the server domain to use the endpoint socket and accept connections on it.
#line 94
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 94
# than we need (e.g. we don"t need "bind" or "connect").
#line 94
allow surfaceflinger pdx_display_client_endpoint_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown listen accept };
#line 94
# Allow the server domain to apply security context label to the channel socket pair (allow process to use setsockcreatecon_raw()).
#line 94
allow surfaceflinger self:process setsockcreate;
#line 94
# Allow the server domain to create a client channel socket.
#line 94
allow surfaceflinger pdx_display_client_channel_socket_type:unix_stream_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
#line 94
# Prevent other processes from claiming to be a server for the same service.
#line 94
neverallow {domain -surfaceflinger} pdx_display_client_endpoint_socket_type:unix_stream_socket { listen accept };
#line 94


#line 95
# Mark the server domain as a PDX server.
#line 95
typeattribute surfaceflinger pdx_display_manager_server_type;
#line 95
# Allow the init process to create the initial endpoint socket.
#line 95
allow init pdx_display_manager_endpoint_socket_type:unix_stream_socket { create bind };
#line 95
# Allow the server domain to use the endpoint socket and accept connections on it.
#line 95
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 95
# than we need (e.g. we don"t need "bind" or "connect").
#line 95
allow surfaceflinger pdx_display_manager_endpoint_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown listen accept };
#line 95
# Allow the server domain to apply security context label to the channel socket pair (allow process to use setsockcreatecon_raw()).
#line 95
allow surfaceflinger self:process setsockcreate;
#line 95
# Allow the server domain to create a client channel socket.
#line 95
allow surfaceflinger pdx_display_manager_channel_socket_type:unix_stream_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
#line 95
# Prevent other processes from claiming to be a server for the same service.
#line 95
neverallow {domain -surfaceflinger} pdx_display_manager_endpoint_socket_type:unix_stream_socket { listen accept };
#line 95


#line 96
# Mark the server domain as a PDX server.
#line 96
typeattribute surfaceflinger pdx_display_screenshot_server_type;
#line 96
# Allow the init process to create the initial endpoint socket.
#line 96
allow init pdx_display_screenshot_endpoint_socket_type:unix_stream_socket { create bind };
#line 96
# Allow the server domain to use the endpoint socket and accept connections on it.
#line 96
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 96
# than we need (e.g. we don"t need "bind" or "connect").
#line 96
allow surfaceflinger pdx_display_screenshot_endpoint_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown listen accept };
#line 96
# Allow the server domain to apply security context label to the channel socket pair (allow process to use setsockcreatecon_raw()).
#line 96
allow surfaceflinger self:process setsockcreate;
#line 96
# Allow the server domain to create a client channel socket.
#line 96
allow surfaceflinger pdx_display_screenshot_channel_socket_type:unix_stream_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
#line 96
# Prevent other processes from claiming to be a server for the same service.
#line 96
neverallow {domain -surfaceflinger} pdx_display_screenshot_endpoint_socket_type:unix_stream_socket { listen accept };
#line 96


#line 97
# Mark the server domain as a PDX server.
#line 97
typeattribute surfaceflinger pdx_display_vsync_server_type;
#line 97
# Allow the init process to create the initial endpoint socket.
#line 97
allow init pdx_display_vsync_endpoint_socket_type:unix_stream_socket { create bind };
#line 97
# Allow the server domain to use the endpoint socket and accept connections on it.
#line 97
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 97
# than we need (e.g. we don"t need "bind" or "connect").
#line 97
allow surfaceflinger pdx_display_vsync_endpoint_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown listen accept };
#line 97
# Allow the server domain to apply security context label to the channel socket pair (allow process to use setsockcreatecon_raw()).
#line 97
allow surfaceflinger self:process setsockcreate;
#line 97
# Allow the server domain to create a client channel socket.
#line 97
allow surfaceflinger pdx_display_vsync_channel_socket_type:unix_stream_socket { create { { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown } listen accept } };
#line 97
# Prevent other processes from claiming to be a server for the same service.
#line 97
neverallow {domain -surfaceflinger} pdx_display_vsync_endpoint_socket_type:unix_stream_socket { listen accept };
#line 97



#line 99

#line 99
# Allow client to open the service endpoint file.
#line 99
allow surfaceflinger pdx_bufferhub_client_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 99
allow surfaceflinger pdx_bufferhub_client_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 99
# Allow the client to connect to endpoint socket.
#line 99
allow surfaceflinger pdx_bufferhub_client_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 99

#line 99

#line 99
# Allow the client to use the PDX channel socket.
#line 99
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 99
# than we need (e.g. we don"t need "bind" or "connect").
#line 99
allow surfaceflinger pdx_bufferhub_client_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 99
# Client needs to use an channel event fd from the server.
#line 99
allow surfaceflinger pdx_bufferhub_client_server_type:fd use;
#line 99
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 99
# This could be tightened on a per-server basis, but keeping track of service
#line 99
# clients is error prone.
#line 99
allow pdx_bufferhub_client_server_type surfaceflinger:fd use;
#line 99

#line 99


#line 100

#line 100
# Allow client to open the service endpoint file.
#line 100
allow surfaceflinger pdx_performance_client_endpoint_dir_type:dir { open getattr read search ioctl lock };
#line 100
allow surfaceflinger pdx_performance_client_endpoint_socket_type:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
#line 100
# Allow the client to connect to endpoint socket.
#line 100
allow surfaceflinger pdx_performance_client_endpoint_socket_type:unix_stream_socket { connectto read write shutdown };
#line 100

#line 100

#line 100
# Allow the client to use the PDX channel socket.
#line 100
# Not using macro like "rw_socket_perms_no_ioctl" because it provides more rights
#line 100
# than we need (e.g. we don"t need "bind" or "connect").
#line 100
allow surfaceflinger pdx_performance_client_channel_socket_type:unix_stream_socket { read getattr write setattr lock append getopt setopt shutdown };
#line 100
# Client needs to use an channel event fd from the server.
#line 100
allow surfaceflinger pdx_performance_client_server_type:fd use;
#line 100
# Servers may receive sync fences, gralloc buffers, etc, from clients.
#line 100
# This could be tightened on a per-server basis, but keeping track of service
#line 100
# clients is error prone.
#line 100
allow pdx_performance_client_server_type surfaceflinger:fd use;
#line 100

#line 100


###
### Neverallow rules
###
### surfaceflinger should NEVER do any of this

# Do not allow accessing SDcard files as unsafe ejection could
# cause the kernel to kill the process.
neverallow surfaceflinger sdcard_type:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 1 "system/sepolicy/private/system_app.te"
###
### Apps that run with the system UID, e.g. com.android.system.ui,
### com.android.settings.  These are not as privileged as the system
### server.
###

typeattribute system_app coredomain;
typeattribute system_app domain_deprecated;


#line 10
typeattribute system_app appdomain;
#line 10
# Label ashmem objects with our own unique type.
#line 10

#line 10
type system_app_tmpfs, file_type;
#line 10
type_transition system_app tmpfs:file system_app_tmpfs;
#line 10
allow system_app system_app_tmpfs:file { read write getattr };
#line 10
allow system_app tmpfs:dir { getattr search };
#line 10

#line 10
# Map with PROT_EXEC.
#line 10
allow system_app system_app_tmpfs:file execute;
#line 10


#line 11
typeattribute system_app netdomain;
#line 11


#line 12
typeattribute system_app binderservicedomain;
#line 12


# android.ui and system.ui
allow system_app rootfs:dir getattr;

# Read and write /data/data subdirectory.
allow system_app system_app_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_app system_app_data_file:{ file lnk_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Read and write to /data/misc/user.
allow system_app misc_user_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_app misc_user_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access to vold-mounted storage for measuring free space
allow system_app mnt_media_rw_file:dir search;

# Read wallpaper file.
allow system_app wallpaper_file:file { getattr open read ioctl lock map };

# Read icon file.
allow system_app icon_file:file { getattr open read ioctl lock map };

# Write to properties

#line 35

#line 35
allow system_app property_socket:sock_file write;
#line 35
allow system_app init:unix_stream_socket connectto;
#line 35

#line 35
allow system_app bluetooth_prop:property_service set;
#line 35

#line 35
allow system_app bluetooth_prop:file { getattr open read ioctl lock map };
#line 35

#line 35


#line 36

#line 36
allow system_app property_socket:sock_file write;
#line 36
allow system_app init:unix_stream_socket connectto;
#line 36

#line 36
allow system_app debug_prop:property_service set;
#line 36

#line 36
allow system_app debug_prop:file { getattr open read ioctl lock map };
#line 36

#line 36


#line 37

#line 37
allow system_app property_socket:sock_file write;
#line 37
allow system_app init:unix_stream_socket connectto;
#line 37

#line 37
allow system_app system_prop:property_service set;
#line 37

#line 37
allow system_app system_prop:file { getattr open read ioctl lock map };
#line 37

#line 37


#line 38

#line 38
allow system_app property_socket:sock_file write;
#line 38
allow system_app init:unix_stream_socket connectto;
#line 38

#line 38
allow system_app logd_prop:property_service set;
#line 38

#line 38
allow system_app logd_prop:file { getattr open read ioctl lock map };
#line 38

#line 38


#line 39

#line 39
allow system_app property_socket:sock_file write;
#line 39
allow system_app init:unix_stream_socket connectto;
#line 39

#line 39
allow system_app net_radio_prop:property_service set;
#line 39

#line 39
allow system_app net_radio_prop:file { getattr open read ioctl lock map };
#line 39

#line 39


#line 40

#line 40
allow system_app property_socket:sock_file write;
#line 40
allow system_app init:unix_stream_socket connectto;
#line 40

#line 40
allow system_app system_radio_prop:property_service set;
#line 40

#line 40
allow system_app system_radio_prop:file { getattr open read ioctl lock map };
#line 40

#line 40


#line 41

#line 41
allow system_app property_socket:sock_file write;
#line 41
allow system_app init:unix_stream_socket connectto;
#line 41

#line 41
allow system_app log_tag_prop:property_service set;
#line 41

#line 41
allow system_app log_tag_prop:file { getattr open read ioctl lock map };
#line 41

#line 41


#line 42

#line 42
allow system_app property_socket:sock_file write;
#line 42
allow system_app init:unix_stream_socket connectto;
#line 42

#line 42
allow system_app logpersistd_logging_prop:property_service set;
#line 42

#line 42
allow system_app logpersistd_logging_prop:file { getattr open read ioctl lock map };
#line 42

#line 42

auditallow system_app net_radio_prop:property_service set;
auditallow system_app system_radio_prop:property_service set;

# ctl interface

#line 47

#line 47
allow system_app property_socket:sock_file write;
#line 47
allow system_app init:unix_stream_socket connectto;
#line 47

#line 47
allow system_app ctl_default_prop:property_service set;
#line 47

#line 47
allow system_app ctl_default_prop:file { getattr open read ioctl lock map };
#line 47

#line 47


#line 48

#line 48
allow system_app property_socket:sock_file write;
#line 48
allow system_app init:unix_stream_socket connectto;
#line 48

#line 48
allow system_app ctl_bugreport_prop:property_service set;
#line 48

#line 48
allow system_app ctl_bugreport_prop:file { getattr open read ioctl lock map };
#line 48

#line 48


# Create /data/anr/traces.txt.
allow system_app anr_data_file:dir { { open getattr read search ioctl lock } add_name write };
allow system_app anr_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Settings need to access app name and icon from asec
allow system_app asec_apk_file:file { getattr open read ioctl lock map };

# Allow system apps to interact with incidentd

#line 58
# Call the server domain and optionally transfer references to it.
#line 58
allow system_app incidentd:binder { call transfer };
#line 58
# Allow the serverdomain to transfer references to the client on the reply.
#line 58
allow incidentd system_app:binder transfer;
#line 58
# Receive and use open files from the server.
#line 58
allow system_app incidentd:fd use;
#line 58


allow system_app servicemanager:service_manager list;
# TODO: scope this down? Too broad?
allow system_app { service_manager_type -netd_service -dumpstate_service -installd_service -virtual_touchpad_service -vr_hwc_service }:service_manager find;

allow system_app keystore:keystore_key {
    get_state
    get
    insert
    delete
    exist
    list
    reset
    password
    lock
    unlock
    is_empty
    sign
    verify
    grant
    duplicate
    clear_uid
    user_changed
};

# /sys access

#line 85
allow system_app sysfs_type:dir { open getattr read search ioctl lock };
#line 85
allow system_app sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 85



#line 87
# Group AID_LOG checked by filesystem & logd
#line 87
# to permit control commands
#line 87

#line 87

#line 87

#line 87
allow system_app logd_socket:sock_file write;
#line 87
allow system_app logd:unix_stream_socket connectto;
#line 87

#line 87

#line 87


#line 88
allow system_app runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 88


###
### Neverallow rules
###

# app domains which access /dev/fuse should not run as system_app
neverallow system_app fuse_device:chr_file *;
#line 1 "system/sepolicy/private/system_server.te"
#
# System Server aka system_server spawned by zygote.
# Most of the framework services run in this process.
#

typeattribute system_server coredomain;
typeattribute system_server domain_deprecated;
typeattribute system_server mlstrustedsubject;

# Define a type for tmpfs-backed ashmem regions.

#line 11
type system_server_tmpfs, file_type;
#line 11
type_transition system_server tmpfs:file system_server_tmpfs;
#line 11
allow system_server system_server_tmpfs:file { read write getattr };
#line 11
allow system_server tmpfs:dir { getattr search };
#line 11


# Create a socket for connections from crash_dump.
type_transition system_server system_data_file:sock_file system_ndebug_socket "ndebugsocket";

allow system_server zygote_tmpfs:file read;

# For art.
allow system_server dalvikcache_data_file:dir { open getattr read search ioctl lock };
allow system_server dalvikcache_data_file:file { getattr open read ioctl lock map };

# When running system server under --invoke-with, we'll try to load the boot image under the
# system server domain, following links to the system partition.


# /data/resource-cache
allow system_server resourcecache_data_file:file { getattr open read ioctl lock map };
allow system_server resourcecache_data_file:dir { open getattr read search ioctl lock };

# ptrace to processes in the same domain for debugging crashes.
allow system_server self:process ptrace;

# Read and delete last_reboot_reason file
allow system_server reboot_data_file:file { rename { getattr open read ioctl lock map } unlink };
allow system_server reboot_data_file:dir { write search open remove_name };

# Child of the zygote.
allow system_server zygote:fd use;
allow system_server zygote:process sigchld;

# May kill zygote on crashes.
allow system_server zygote:process sigkill;
allow system_server crash_dump:process sigkill;

# Read /system/bin/app_process.
allow system_server zygote_exec:file { getattr open read ioctl lock map };

# Needed to close the zygote socket, which involves getopt / getattr
allow system_server zygote:unix_stream_socket { getopt getattr };

# system server gets network and bluetooth permissions.

#line 52
typeattribute system_server netdomain;
#line 52

# in addition to ioctls whitelisted for all domains, also allow system_server
# to use privileged ioctls commands. Needed to set up VPNs.
allowxperm system_server self:udp_socket ioctl 
#line 55
{
#line 55
# qualcomm rmnet ioctls
#line 55
0x00006900 0x00006902
#line 55
# socket ioctls
#line 55
0x0000890b 0x0000890c 0x0000890d 0x00008911 0x00008914 0x00008916
#line 55
0x00008918 0x0000891a 0x0000891c 0x0000891d 0x0000891e 0x0000891f
#line 55
0x00008920 0x00008922 0x00008923 0x00008924 0x00008925 0x00008926
#line 55
0x00008927 0x00008929 0x00008930 0x00008931 0x00008932
#line 55
0x00008934 0x00008935 0x00008936 0x00008937 0x00008939 0x00008940 0x00008941
#line 55
0x00008943 0x00008946 0x00008947 0x00008948 0x00008949 0x0000894a
#line 55
0x0000894b 0x00008953 0x00008954 0x00008955 0x00008960 0x00008961 0x00008962 0x00008970
#line 55
0x00008971 0x00008980 0x00008981 0x00008982 0x00008983 0x00008990
#line 55
0x00008991 0x00008992 0x00008993 0x00008994
#line 55
0x00008995 0x000089a0 0x000089a1 0x000089a2 0x000089a3 0x000089b0
#line 55
# device and protocol specific ioctls
#line 55
0x000089f0-0x000089ff
#line 55
0x000089e0-0x000089ef
#line 55
# Wireless extension ioctls
#line 55
0x00008b00 0x00008b02 0x00008b04 0x00008b06 0x00008b08 0x00008b0a
#line 55
0x00008b0c 0x00008b0e 0x00008b10 0x00008b14 0x00008b15 0x00008b16 0x00008b17
#line 55
0x00008b18 0x00008b19 0x00008b1a 0x00008b1b 0x00008b1c 0x00008b1d
#line 55
0x00008b20 0x00008b22 0x00008b24 0x00008b26 0x00008b28 0x00008b2a
#line 55
0x00008b2b 0x00008b2c 0x00008b30 0x00008b31 0x00008b32 0x00008b33
#line 55
0x00008b34 0x00008b35 0x00008b36
#line 55
# Dev private ioctl i.e. hardware specific ioctls
#line 55
0x00008be0-0x00008bff
#line 55
};

#line 56
typeattribute system_server bluetoothdomain;
#line 56


# These are the capabilities assigned by the zygote to the
# system server.
allow system_server self:capability {
    ipc_lock
    kill
    net_admin
    net_bind_service
    net_broadcast
    net_raw
    sys_boot
    sys_nice
    sys_ptrace
    sys_time
    sys_tty_config
};


#line 74
# Access /sys/power/wake_lock and /sys/power/wake_unlock
#line 74
allow system_server sysfs_wake_lock:file { { getattr open read ioctl lock map } { open append write lock map } };
#line 74
# Accessing these files requires CAP_BLOCK_SUSPEND
#line 74
allow system_server self:capability2 block_suspend;
#line 74


# Trigger module auto-load.
allow system_server kernel:system module_request;

# Allow alarmtimers to be set
allow system_server self:capability2 wake_alarm;

# Create and share netlink_netfilter_sockets for tetheroffload.
allow system_server self:netlink_netfilter_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Use netlink uevent sockets.
allow system_server self:netlink_kobject_uevent_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Use generic netlink sockets.
allow system_server self:netlink_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };
allow system_server self:netlink_generic_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# libvintf reads the kernel config to verify vendor interface compatibility.
allow system_server config_gz:file { read open };

# Use generic "sockets" where the address family is not known
# to the kernel. The ioctl permission is specifically omitted here, but may
# be added to device specific policy along with the ioctl commands to be
# whitelisted.
allow system_server self:socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Set and get routes directly via netlink.
allow system_server self:netlink_route_socket nlmsg_write;

# Kill apps.
allow system_server appdomain:process { getpgid sigkill signal };

# Set scheduling info for apps.
allow system_server appdomain:process { getsched setsched };
allow system_server audioserver:process { getsched setsched };
allow system_server hal_audio:process { getsched setsched };
allow system_server hal_bluetooth:process { getsched setsched };
allow system_server cameraserver:process { getsched setsched };
allow system_server hal_camera:process { getsched setsched };
allow system_server mediaserver:process { getsched setsched };
allow system_server bootanim:process { getsched setsched };

# Allow system_server to write to cameraserver's /proc/<pid>/timerslack_ns
allow system_server cameraserver:file { open append write lock map };

# Read /proc/pid data for all domains. This is used by ProcessCpuTracker
# within system_server to keep track of memory and CPU usage for
# all processes on the device. In addition, /proc/pid files access is needed
# for dumping stack traces of native processes.

#line 124
allow system_server domain:dir { open getattr read search ioctl lock };
#line 124
allow system_server domain:{ file lnk_file } { getattr open read ioctl lock map };
#line 124


# Read/Write to /proc/net/xt_qtaguid/ctrl and and /dev/xt_qtaguid.
allow system_server qtaguid_proc:file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server qtaguid_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Read /proc/uid_cputime/show_uid_stat.
allow system_server proc_uid_cputime_showstat:file { getattr open read ioctl lock map };

# Write /proc/uid_cputime/remove_uid_range.
allow system_server proc_uid_cputime_removeuid:file { { open append write lock map } getattr };

# Write /proc/uid_procstat/set.
allow system_server proc_uid_procstat_set:file { { open append write lock map } getattr };

# Read /proc/uid_time_in_state.
allow system_server proc_uid_time_in_state:file { getattr open read ioctl lock map };

# Write to /proc/sysrq-trigger.
allow system_server proc_sysrq:file { { getattr open read ioctl lock map } { open append write lock map } };

# Read /proc/stat for CPU usage statistics
allow system_server proc_stat:file { getattr open read ioctl lock map };

# Read /sys/kernel/debug/wakeup_sources.
allow system_server debugfs:file { getattr open read ioctl lock map };

# The DhcpClient and WifiWatchdog use packet_sockets
allow system_server self:packet_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# NetworkDiagnostics requires explicit bind() calls to ping sockets. These aren't actually the same
# as raw sockets, but the kernel doesn't yet distinguish between the two.
allow system_server node:rawip_socket node_bind;

# 3rd party VPN clients require a tun_socket to be created
allow system_server self:tun_socket { create { read getattr write setattr lock append bind connect getopt setopt shutdown } };

# Talk to init and various daemons via sockets.

#line 162

#line 162

#line 162
allow system_server lmkd_socket:sock_file write;
#line 162
allow system_server lmkd:unix_stream_socket connectto;
#line 162

#line 162


#line 163

#line 163

#line 163
allow system_server mtpd_socket:sock_file write;
#line 163
allow system_server mtp:unix_stream_socket connectto;
#line 163

#line 163


#line 164

#line 164

#line 164
allow system_server netd_socket:sock_file write;
#line 164
allow system_server netd:unix_stream_socket connectto;
#line 164

#line 164


#line 165

#line 165

#line 165
allow system_server vold_socket:sock_file write;
#line 165
allow system_server vold:unix_stream_socket connectto;
#line 165

#line 165


#line 166

#line 166

#line 166
allow system_server webview_zygote_socket:sock_file write;
#line 166
allow system_server webview_zygote:unix_stream_socket connectto;
#line 166

#line 166


#line 167

#line 167

#line 167
allow system_server zygote_socket:sock_file write;
#line 167
allow system_server zygote:unix_stream_socket connectto;
#line 167

#line 167


#line 168

#line 168

#line 168
allow system_server racoon_socket:sock_file write;
#line 168
allow system_server racoon:unix_stream_socket connectto;
#line 168

#line 168


#line 169

#line 169

#line 169
allow system_server uncrypt_socket:sock_file write;
#line 169
allow system_server uncrypt:unix_stream_socket connectto;
#line 169

#line 169


# Communicate over a socket created by surfaceflinger.
allow system_server surfaceflinger:unix_stream_socket { read write setopt };

# Perform Binder IPC.

#line 175
# Call the servicemanager and transfer references to it.
#line 175
allow system_server servicemanager:binder { call transfer };
#line 175
# servicemanager performs getpidcon on clients.
#line 175
allow servicemanager system_server:dir search;
#line 175
allow servicemanager system_server:file { read open };
#line 175
allow servicemanager system_server:process getattr;
#line 175
# rw access to /dev/binder and /dev/ashmem is presently granted to
#line 175
# all domains in domain.te.
#line 175


#line 176
# Call the server domain and optionally transfer references to it.
#line 176
allow system_server appdomain:binder { call transfer };
#line 176
# Allow the serverdomain to transfer references to the client on the reply.
#line 176
allow appdomain system_server:binder transfer;
#line 176
# Receive and use open files from the server.
#line 176
allow system_server appdomain:fd use;
#line 176


#line 177
# Call the server domain and optionally transfer references to it.
#line 177
allow system_server binderservicedomain:binder { call transfer };
#line 177
# Allow the serverdomain to transfer references to the client on the reply.
#line 177
allow binderservicedomain system_server:binder transfer;
#line 177
# Receive and use open files from the server.
#line 177
allow system_server binderservicedomain:fd use;
#line 177


#line 178
# Call the server domain and optionally transfer references to it.
#line 178
allow system_server dumpstate:binder { call transfer };
#line 178
# Allow the serverdomain to transfer references to the client on the reply.
#line 178
allow dumpstate system_server:binder transfer;
#line 178
# Receive and use open files from the server.
#line 178
allow system_server dumpstate:fd use;
#line 178


#line 179
# Call the server domain and optionally transfer references to it.
#line 179
allow system_server fingerprintd:binder { call transfer };
#line 179
# Allow the serverdomain to transfer references to the client on the reply.
#line 179
allow fingerprintd system_server:binder transfer;
#line 179
# Receive and use open files from the server.
#line 179
allow system_server fingerprintd:fd use;
#line 179


#line 180
# Call the server domain and optionally transfer references to it.
#line 180
allow system_server gatekeeperd:binder { call transfer };
#line 180
# Allow the serverdomain to transfer references to the client on the reply.
#line 180
allow gatekeeperd system_server:binder transfer;
#line 180
# Receive and use open files from the server.
#line 180
allow system_server gatekeeperd:fd use;
#line 180


#line 181
# Call the server domain and optionally transfer references to it.
#line 181
allow system_server installd:binder { call transfer };
#line 181
# Allow the serverdomain to transfer references to the client on the reply.
#line 181
allow installd system_server:binder transfer;
#line 181
# Receive and use open files from the server.
#line 181
allow system_server installd:fd use;
#line 181


#line 182
# Call the server domain and optionally transfer references to it.
#line 182
allow system_server incidentd:binder { call transfer };
#line 182
# Allow the serverdomain to transfer references to the client on the reply.
#line 182
allow incidentd system_server:binder transfer;
#line 182
# Receive and use open files from the server.
#line 182
allow system_server incidentd:fd use;
#line 182


#line 183
# Call the server domain and optionally transfer references to it.
#line 183
allow system_server netd:binder { call transfer };
#line 183
# Allow the serverdomain to transfer references to the client on the reply.
#line 183
allow netd system_server:binder transfer;
#line 183
# Receive and use open files from the server.
#line 183
allow system_server netd:fd use;
#line 183


#line 184
# Call the server domain and optionally transfer references to it.
#line 184
allow system_server wificond:binder { call transfer };
#line 184
# Allow the serverdomain to transfer references to the client on the reply.
#line 184
allow wificond system_server:binder transfer;
#line 184
# Receive and use open files from the server.
#line 184
allow system_server wificond:fd use;
#line 184


#line 185
typeattribute system_server binderservicedomain;
#line 185


# Use HALs

#line 188
typeattribute system_server halclientdomain;
#line 188
typeattribute system_server hal_allocator_client;
#line 188

#line 188
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 188
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 188
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 188

#line 188
typeattribute system_server hal_allocator;
#line 188
# Find passthrough HAL implementations
#line 188
allow hal_allocator system_file:dir { open getattr read search ioctl lock };
#line 188
allow hal_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 188
allow hal_allocator vendor_file:file { read open getattr execute map };
#line 188

#line 188


#line 189
typeattribute system_server halclientdomain;
#line 189
typeattribute system_server hal_broadcastradio_client;
#line 189

#line 189
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 189
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 189
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 189

#line 189
typeattribute system_server hal_broadcastradio;
#line 189
# Find passthrough HAL implementations
#line 189
allow hal_broadcastradio system_file:dir { open getattr read search ioctl lock };
#line 189
allow hal_broadcastradio vendor_file:dir { open getattr read search ioctl lock };
#line 189
allow hal_broadcastradio vendor_file:file { read open getattr execute map };
#line 189

#line 189


#line 190
typeattribute system_server halclientdomain;
#line 190
typeattribute system_server hal_configstore_client;
#line 190

#line 190
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 190
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 190
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 190

#line 190
typeattribute system_server hal_configstore;
#line 190
# Find passthrough HAL implementations
#line 190
allow hal_configstore system_file:dir { open getattr read search ioctl lock };
#line 190
allow hal_configstore vendor_file:dir { open getattr read search ioctl lock };
#line 190
allow hal_configstore vendor_file:file { read open getattr execute map };
#line 190

#line 190


#line 191
typeattribute system_server halclientdomain;
#line 191
typeattribute system_server hal_contexthub_client;
#line 191

#line 191
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 191
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 191
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 191

#line 191
typeattribute system_server hal_contexthub;
#line 191
# Find passthrough HAL implementations
#line 191
allow hal_contexthub system_file:dir { open getattr read search ioctl lock };
#line 191
allow hal_contexthub vendor_file:dir { open getattr read search ioctl lock };
#line 191
allow hal_contexthub vendor_file:file { read open getattr execute map };
#line 191

#line 191


#line 192
typeattribute system_server halclientdomain;
#line 192
typeattribute system_server hal_fingerprint_client;
#line 192

#line 192
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 192
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 192
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 192

#line 192
typeattribute system_server hal_fingerprint;
#line 192
# Find passthrough HAL implementations
#line 192
allow hal_fingerprint system_file:dir { open getattr read search ioctl lock };
#line 192
allow hal_fingerprint vendor_file:dir { open getattr read search ioctl lock };
#line 192
allow hal_fingerprint vendor_file:file { read open getattr execute map };
#line 192

#line 192


#line 193
typeattribute system_server halclientdomain;
#line 193
typeattribute system_server hal_gnss_client;
#line 193

#line 193
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 193
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 193
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 193

#line 193
typeattribute system_server hal_gnss;
#line 193
# Find passthrough HAL implementations
#line 193
allow hal_gnss system_file:dir { open getattr read search ioctl lock };
#line 193
allow hal_gnss vendor_file:dir { open getattr read search ioctl lock };
#line 193
allow hal_gnss vendor_file:file { read open getattr execute map };
#line 193

#line 193


#line 194
typeattribute system_server halclientdomain;
#line 194
typeattribute system_server hal_graphics_allocator_client;
#line 194

#line 194
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 194
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 194
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 194

#line 194
typeattribute system_server hal_graphics_allocator;
#line 194
# Find passthrough HAL implementations
#line 194
allow hal_graphics_allocator system_file:dir { open getattr read search ioctl lock };
#line 194
allow hal_graphics_allocator vendor_file:dir { open getattr read search ioctl lock };
#line 194
allow hal_graphics_allocator vendor_file:file { read open getattr execute map };
#line 194

#line 194


#line 195
typeattribute system_server halclientdomain;
#line 195
typeattribute system_server hal_ir_client;
#line 195

#line 195
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 195
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 195
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 195

#line 195
typeattribute system_server hal_ir;
#line 195
# Find passthrough HAL implementations
#line 195
allow hal_ir system_file:dir { open getattr read search ioctl lock };
#line 195
allow hal_ir vendor_file:dir { open getattr read search ioctl lock };
#line 195
allow hal_ir vendor_file:file { read open getattr execute map };
#line 195

#line 195


#line 196
typeattribute system_server halclientdomain;
#line 196
typeattribute system_server hal_light_client;
#line 196

#line 196
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 196
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 196
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 196

#line 196
typeattribute system_server hal_light;
#line 196
# Find passthrough HAL implementations
#line 196
allow hal_light system_file:dir { open getattr read search ioctl lock };
#line 196
allow hal_light vendor_file:dir { open getattr read search ioctl lock };
#line 196
allow hal_light vendor_file:file { read open getattr execute map };
#line 196

#line 196


#line 197
typeattribute system_server halclientdomain;
#line 197
typeattribute system_server hal_memtrack_client;
#line 197

#line 197
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 197
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 197
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 197

#line 197
typeattribute system_server hal_memtrack;
#line 197
# Find passthrough HAL implementations
#line 197
allow hal_memtrack system_file:dir { open getattr read search ioctl lock };
#line 197
allow hal_memtrack vendor_file:dir { open getattr read search ioctl lock };
#line 197
allow hal_memtrack vendor_file:file { read open getattr execute map };
#line 197

#line 197


#line 198
typeattribute system_server halclientdomain;
#line 198
typeattribute system_server hal_neuralnetworks_client;
#line 198

#line 198
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 198
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 198
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 198

#line 198
typeattribute system_server hal_neuralnetworks;
#line 198
# Find passthrough HAL implementations
#line 198
allow hal_neuralnetworks system_file:dir { open getattr read search ioctl lock };
#line 198
allow hal_neuralnetworks vendor_file:dir { open getattr read search ioctl lock };
#line 198
allow hal_neuralnetworks vendor_file:file { read open getattr execute map };
#line 198

#line 198


#line 199
typeattribute system_server halclientdomain;
#line 199
typeattribute system_server hal_oemlock_client;
#line 199

#line 199
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 199
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 199
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 199

#line 199
typeattribute system_server hal_oemlock;
#line 199
# Find passthrough HAL implementations
#line 199
allow hal_oemlock system_file:dir { open getattr read search ioctl lock };
#line 199
allow hal_oemlock vendor_file:dir { open getattr read search ioctl lock };
#line 199
allow hal_oemlock vendor_file:file { read open getattr execute map };
#line 199

#line 199

allow system_server hal_omx_hwservice:hwservice_manager find;
allow system_server hidl_token_hwservice:hwservice_manager find;

#line 202
typeattribute system_server halclientdomain;
#line 202
typeattribute system_server hal_power_client;
#line 202

#line 202
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 202
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 202
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 202

#line 202
typeattribute system_server hal_power;
#line 202
# Find passthrough HAL implementations
#line 202
allow hal_power system_file:dir { open getattr read search ioctl lock };
#line 202
allow hal_power vendor_file:dir { open getattr read search ioctl lock };
#line 202
allow hal_power vendor_file:file { read open getattr execute map };
#line 202

#line 202


#line 203
typeattribute system_server halclientdomain;
#line 203
typeattribute system_server hal_sensors_client;
#line 203

#line 203
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 203
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 203
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 203

#line 203
typeattribute system_server hal_sensors;
#line 203
# Find passthrough HAL implementations
#line 203
allow hal_sensors system_file:dir { open getattr read search ioctl lock };
#line 203
allow hal_sensors vendor_file:dir { open getattr read search ioctl lock };
#line 203
allow hal_sensors vendor_file:file { read open getattr execute map };
#line 203

#line 203


#line 204
typeattribute system_server halclientdomain;
#line 204
typeattribute system_server hal_tetheroffload_client;
#line 204

#line 204
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 204
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 204
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 204

#line 204
typeattribute system_server hal_tetheroffload;
#line 204
# Find passthrough HAL implementations
#line 204
allow hal_tetheroffload system_file:dir { open getattr read search ioctl lock };
#line 204
allow hal_tetheroffload vendor_file:dir { open getattr read search ioctl lock };
#line 204
allow hal_tetheroffload vendor_file:file { read open getattr execute map };
#line 204

#line 204


#line 205
typeattribute system_server halclientdomain;
#line 205
typeattribute system_server hal_thermal_client;
#line 205

#line 205
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 205
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 205
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 205

#line 205
typeattribute system_server hal_thermal;
#line 205
# Find passthrough HAL implementations
#line 205
allow hal_thermal system_file:dir { open getattr read search ioctl lock };
#line 205
allow hal_thermal vendor_file:dir { open getattr read search ioctl lock };
#line 205
allow hal_thermal vendor_file:file { read open getattr execute map };
#line 205

#line 205


#line 206
typeattribute system_server halclientdomain;
#line 206
typeattribute system_server hal_tv_cec_client;
#line 206

#line 206
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 206
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 206
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 206

#line 206
typeattribute system_server hal_tv_cec;
#line 206
# Find passthrough HAL implementations
#line 206
allow hal_tv_cec system_file:dir { open getattr read search ioctl lock };
#line 206
allow hal_tv_cec vendor_file:dir { open getattr read search ioctl lock };
#line 206
allow hal_tv_cec vendor_file:file { read open getattr execute map };
#line 206

#line 206


#line 207
typeattribute system_server halclientdomain;
#line 207
typeattribute system_server hal_tv_input_client;
#line 207

#line 207
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 207
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 207
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 207

#line 207
typeattribute system_server hal_tv_input;
#line 207
# Find passthrough HAL implementations
#line 207
allow hal_tv_input system_file:dir { open getattr read search ioctl lock };
#line 207
allow hal_tv_input vendor_file:dir { open getattr read search ioctl lock };
#line 207
allow hal_tv_input vendor_file:file { read open getattr execute map };
#line 207

#line 207


#line 208
typeattribute system_server halclientdomain;
#line 208
typeattribute system_server hal_usb_client;
#line 208

#line 208
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 208
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 208
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 208

#line 208
typeattribute system_server hal_usb;
#line 208
# Find passthrough HAL implementations
#line 208
allow hal_usb system_file:dir { open getattr read search ioctl lock };
#line 208
allow hal_usb vendor_file:dir { open getattr read search ioctl lock };
#line 208
allow hal_usb vendor_file:file { read open getattr execute map };
#line 208

#line 208


#line 209
typeattribute system_server halclientdomain;
#line 209
typeattribute system_server hal_vibrator_client;
#line 209

#line 209
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 209
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 209
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 209

#line 209
typeattribute system_server hal_vibrator;
#line 209
# Find passthrough HAL implementations
#line 209
allow hal_vibrator system_file:dir { open getattr read search ioctl lock };
#line 209
allow hal_vibrator vendor_file:dir { open getattr read search ioctl lock };
#line 209
allow hal_vibrator vendor_file:file { read open getattr execute map };
#line 209

#line 209


#line 210
typeattribute system_server halclientdomain;
#line 210
typeattribute system_server hal_vr_client;
#line 210

#line 210
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 210
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 210
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 210

#line 210
typeattribute system_server hal_vr;
#line 210
# Find passthrough HAL implementations
#line 210
allow hal_vr system_file:dir { open getattr read search ioctl lock };
#line 210
allow hal_vr vendor_file:dir { open getattr read search ioctl lock };
#line 210
allow hal_vr vendor_file:file { read open getattr execute map };
#line 210

#line 210


#line 211
typeattribute system_server halclientdomain;
#line 211
typeattribute system_server hal_weaver_client;
#line 211

#line 211
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 211
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 211
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 211

#line 211
typeattribute system_server hal_weaver;
#line 211
# Find passthrough HAL implementations
#line 211
allow hal_weaver system_file:dir { open getattr read search ioctl lock };
#line 211
allow hal_weaver vendor_file:dir { open getattr read search ioctl lock };
#line 211
allow hal_weaver vendor_file:file { read open getattr execute map };
#line 211

#line 211


#line 212
typeattribute system_server halclientdomain;
#line 212
typeattribute system_server hal_wifi_client;
#line 212

#line 212
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 212
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 212
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 212

#line 212
typeattribute system_server hal_wifi;
#line 212
# Find passthrough HAL implementations
#line 212
allow hal_wifi system_file:dir { open getattr read search ioctl lock };
#line 212
allow hal_wifi vendor_file:dir { open getattr read search ioctl lock };
#line 212
allow hal_wifi vendor_file:file { read open getattr execute map };
#line 212

#line 212


#line 213
typeattribute system_server halclientdomain;
#line 213
typeattribute system_server hal_wifi_offload_client;
#line 213

#line 213
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 213
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 213
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 213

#line 213
typeattribute system_server hal_wifi_offload;
#line 213
# Find passthrough HAL implementations
#line 213
allow hal_wifi_offload system_file:dir { open getattr read search ioctl lock };
#line 213
allow hal_wifi_offload vendor_file:dir { open getattr read search ioctl lock };
#line 213
allow hal_wifi_offload vendor_file:file { read open getattr execute map };
#line 213

#line 213


#line 214
typeattribute system_server halclientdomain;
#line 214
typeattribute system_server hal_wifi_supplicant_client;
#line 214

#line 214
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 214
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 214
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 214

#line 214
typeattribute system_server hal_wifi_supplicant;
#line 214
# Find passthrough HAL implementations
#line 214
allow hal_wifi_supplicant system_file:dir { open getattr read search ioctl lock };
#line 214
allow hal_wifi_supplicant vendor_file:dir { open getattr read search ioctl lock };
#line 214
allow hal_wifi_supplicant vendor_file:file { read open getattr execute map };
#line 214

#line 214



#line 216
# Call the server domain and optionally transfer references to it.
#line 216
allow system_server mediacodec:binder { call transfer };
#line 216
# Allow the serverdomain to transfer references to the client on the reply.
#line 216
allow mediacodec system_server:binder transfer;
#line 216
# Receive and use open files from the server.
#line 216
allow system_server mediacodec:fd use;
#line 216


# Talk with graphics composer fences
allow system_server hal_graphics_composer:fd use;

# Use RenderScript always-passthrough HAL
allow system_server hal_renderscript_hwservice:hwservice_manager find;

# Offer HwBinder services

#line 225
  allow system_server fwk_scheduler_hwservice:hwservice_manager { add find };
#line 225
  allow system_server hidl_base_hwservice:hwservice_manager add;
#line 225
  neverallow { domain -system_server } fwk_scheduler_hwservice:hwservice_manager add;
#line 225


#line 226
  allow system_server fwk_sensor_hwservice:hwservice_manager { add find };
#line 226
  allow system_server hidl_base_hwservice:hwservice_manager add;
#line 226
  neverallow { domain -system_server } fwk_sensor_hwservice:hwservice_manager add;
#line 226


# Talk to tombstoned to get ANR traces.

#line 229

#line 229

#line 229
allow system_server tombstoned_intercept_socket:sock_file write;
#line 229
allow system_server tombstoned:unix_stream_socket connectto;
#line 229

#line 229


# List HAL interfaces to get ANR traces.
allow system_server hwservicemanager:hwservice_manager list;

# Send signals to trigger ANR traces.
allow system_server {
  # This is derived from the list that system server defines as interesting native processes
  # to dump during ANRs or watchdog aborts, defined in NATIVE_STACKS_OF_INTEREST in
  # frameworks/base/services/core/java/com/android/server/Watchdog.java.
  audioserver
  cameraserver
  drmserver
  inputflinger
  mediadrmserver
  mediaextractor
  mediaserver
  mediametrics
  sdcardd
  surfaceflinger

  # This list comes from HAL_INTERFACES_OF_INTEREST in
  # frameworks/base/services/core/java/com/android/server/Watchdog.java.
  hal_audio_server
  hal_bluetooth_server
  hal_camera_server
  hal_graphics_composer_server
  hal_sensors_server
  hal_vr_server
  mediacodec # TODO(b/36375899): hal_omx_server
}:process { signal };

# Use sockets received over binder from various services.
allow system_server audioserver:tcp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow system_server audioserver:udp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow system_server mediaserver:tcp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow system_server mediaserver:udp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };

# Use sockets received over binder from various services.
allow system_server mediadrmserver:tcp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };
allow system_server mediadrmserver:udp_socket { ioctl read getattr write setattr lock append bind connect getopt setopt shutdown };

# Get file context
allow system_server file_contexts_file:file { getattr open read ioctl lock map };
# access for mac_permissions
allow system_server mac_perms_file: file { getattr open read ioctl lock map };
# Check SELinux permissions.

#line 276

#line 276
allow system_server selinuxfs:dir { open getattr read search ioctl lock };
#line 276
allow system_server selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 276

#line 276
allow system_server selinuxfs:file { open append write lock map };
#line 276
allow system_server kernel:security compute_av;
#line 276
allow system_server self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 276


# XXX Label sysfs files with a specific type?
allow system_server sysfs:file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server sysfs_nfc_power_writable:file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server sysfs_devices_system_cpu:file { open append write lock map };
allow system_server sysfs_mac_address:file { getattr open read ioctl lock map };
allow system_server sysfs_thermal:dir search;
allow system_server sysfs_thermal:file { getattr open read ioctl lock map };

# TODO: Remove when HALs are forced into separate processes
allow system_server sysfs_vibrator:file { write append };

# TODO: added to match above sysfs rule. Remove me?
allow system_server sysfs_usb:file { open append write lock map };

# Access devices.
allow system_server device:dir { open getattr read search ioctl lock };
allow system_server mdns_socket:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server alarm_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server gpu_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server iio_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server input_device:dir { open getattr read search ioctl lock };
allow system_server input_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server radio_device:chr_file { getattr open read ioctl lock map };
allow system_server tty_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server usbaccessory_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server video_device:dir { open getattr read search ioctl lock };
allow system_server video_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server adbd_socket:sock_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server rtc_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server audio_device:dir { open getattr read search ioctl lock };

# write access needed for MIDI
allow system_server audio_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# tun device used for 3rd party vpn apps
allow system_server tun_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };

# Manage system data files.
allow system_server system_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server system_data_file:{ file lnk_file sock_file fifo_file } { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow system_server keychain_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server keychain_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow system_server keychain_data_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/app.
allow system_server apk_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server apk_data_file:{ file lnk_file } { { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } link };
allow system_server apk_tmp_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server apk_tmp_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access /vendor/app

#line 329
allow system_server vendor_app_file:dir { open getattr read search ioctl lock };
#line 329
allow system_server vendor_app_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 329


# Access /vendor/app

#line 332
allow system_server vendor_overlay_file:dir { open getattr read search ioctl lock };
#line 332
allow system_server vendor_overlay_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 332


# Manage /data/app-private.
allow system_server apk_private_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server apk_private_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow system_server apk_private_tmp_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server apk_private_tmp_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage files within asec containers.
allow system_server asec_apk_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server asec_apk_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
allow system_server asec_public_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/anr.
#
# TODO: Some of these permissions can be withdrawn once we've switched to the
# new stack dumping mechanism, see b/32064548 and the rules below. In particular,
# the system_server should never need to create a new anr_data_file:file or write
# to one, but it will still need to read and append to existing files.
allow system_server anr_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server anr_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# New stack dumping scheme : request an output FD from tombstoned via a unix
# domain socket.
#
# Allow system_server to connect and write to the tombstoned java trace socket in
# order to dump its traces. Also allow the system server to write its traces to
# dumpstate during bugreport capture.

#line 360

#line 360

#line 360
allow system_server tombstoned_java_trace_socket:sock_file write;
#line 360
allow system_server tombstoned:unix_stream_socket connectto;
#line 360

#line 360

allow system_server tombstoned:fd use;
allow system_server dumpstate:fifo_file append;

# Read /data/misc/incidents - only read. The fd will be sent over binder,
# with no DAC access to it, for dropbox to read.
allow system_server incident_data_file:file read;

# Manage /data/backup.
allow system_server backup_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server backup_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Write to /data/system/heapdump
allow system_server heapdump_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow system_server heapdump_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/misc/adb.
allow system_server adb_keys_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server adb_keys_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/misc/sms.
# TODO:  Split into a separate type?
allow system_server radio_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server radio_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/misc/systemkeys.
allow system_server systemkeys_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server systemkeys_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/misc/textclassifier.
allow system_server textclassifier_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server textclassifier_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Access /data/tombstones.
allow system_server tombstone_data_file:dir { open getattr read search ioctl lock };
allow system_server tombstone_data_file:file { getattr open read ioctl lock map };

# Manage /data/misc/vpn.
allow system_server vpn_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server vpn_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/misc/wifi.
allow system_server wifi_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server wifi_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage /data/misc/zoneinfo.
allow system_server zoneinfo_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server zoneinfo_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Walk /data/data subdirectories.
# Types extracted from seapp_contexts type= fields.
allow system_server { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:dir { getattr read search };
# Also permit for unlabeled /data/data subdirectories and
# for unlabeled asec containers on upgrades from 4.2.
allow system_server unlabeled:dir { open getattr read search ioctl lock };
# Read pkg.apk file before it has been relabeled by vold.
allow system_server unlabeled:file { getattr open read ioctl lock map };

# Populate com.android.providers.settings/databases/settings.db.
allow system_server system_app_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server system_app_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Receive and use open app data files passed over binder IPC.
# Types extracted from seapp_contexts type= fields.
allow system_server { system_app_data_file bluetooth_data_file nfc_data_file radio_data_file shell_data_file app_data_file }:file { getattr read write append };

# Access to /data/media for measuring disk usage.
allow system_server media_rw_data_file:dir { search getattr open read };

# Receive and use open /data/media files passed over binder IPC.
# Also used for measuring disk usage.
allow system_server media_rw_data_file:file { getattr read write append };

# Relabel apk files.
allow system_server { apk_tmp_file apk_private_tmp_file }:{ dir file } { relabelfrom relabelto };
allow system_server { apk_data_file apk_private_data_file }:{ dir file } { relabelfrom relabelto };

# Relabel wallpaper.
allow system_server system_data_file:file relabelfrom;
allow system_server wallpaper_file:file relabelto;
allow system_server wallpaper_file:file { { { getattr open read ioctl lock map } { open append write lock map } } rename unlink };

# Backup of wallpaper imagery uses temporary hard links to avoid data churn
allow system_server { system_data_file wallpaper_file }:file link;

# ShortcutManager icons
allow system_server system_data_file:dir relabelfrom;
allow system_server shortcut_manager_icons:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } relabelto };
allow system_server shortcut_manager_icons:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage ringtones.
allow system_server ringtone_file:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } relabelto };
allow system_server ringtone_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Relabel icon file.
allow system_server icon_file:file relabelto;
allow system_server icon_file:file { { { getattr open read ioctl lock map } { open append write lock map } } unlink };

# FingerprintService.java does a restorecon of the directory /data/system/users/[0-9]+/fpdata(/.*)?
allow system_server system_data_file:dir relabelfrom;

# Property Service write

#line 462

#line 462
allow system_server property_socket:sock_file write;
#line 462
allow system_server init:unix_stream_socket connectto;
#line 462

#line 462
allow system_server system_prop:property_service set;
#line 462

#line 462
allow system_server system_prop:file { getattr open read ioctl lock map };
#line 462

#line 462


#line 463

#line 463
allow system_server property_socket:sock_file write;
#line 463
allow system_server init:unix_stream_socket connectto;
#line 463

#line 463
allow system_server safemode_prop:property_service set;
#line 463

#line 463
allow system_server safemode_prop:file { getattr open read ioctl lock map };
#line 463

#line 463


#line 464

#line 464
allow system_server property_socket:sock_file write;
#line 464
allow system_server init:unix_stream_socket connectto;
#line 464

#line 464
allow system_server dhcp_prop:property_service set;
#line 464

#line 464
allow system_server dhcp_prop:file { getattr open read ioctl lock map };
#line 464

#line 464


#line 465

#line 465
allow system_server property_socket:sock_file write;
#line 465
allow system_server init:unix_stream_socket connectto;
#line 465

#line 465
allow system_server net_radio_prop:property_service set;
#line 465

#line 465
allow system_server net_radio_prop:file { getattr open read ioctl lock map };
#line 465

#line 465


#line 466

#line 466
allow system_server property_socket:sock_file write;
#line 466
allow system_server init:unix_stream_socket connectto;
#line 466

#line 466
allow system_server net_dns_prop:property_service set;
#line 466

#line 466
allow system_server net_dns_prop:file { getattr open read ioctl lock map };
#line 466

#line 466


#line 467

#line 467
allow system_server property_socket:sock_file write;
#line 467
allow system_server init:unix_stream_socket connectto;
#line 467

#line 467
allow system_server system_radio_prop:property_service set;
#line 467

#line 467
allow system_server system_radio_prop:file { getattr open read ioctl lock map };
#line 467

#line 467


#line 468

#line 468
allow system_server property_socket:sock_file write;
#line 468
allow system_server init:unix_stream_socket connectto;
#line 468

#line 468
allow system_server debug_prop:property_service set;
#line 468

#line 468
allow system_server debug_prop:file { getattr open read ioctl lock map };
#line 468

#line 468


#line 469

#line 469
allow system_server property_socket:sock_file write;
#line 469
allow system_server init:unix_stream_socket connectto;
#line 469

#line 469
allow system_server powerctl_prop:property_service set;
#line 469

#line 469
allow system_server powerctl_prop:file { getattr open read ioctl lock map };
#line 469

#line 469


#line 470

#line 470
allow system_server property_socket:sock_file write;
#line 470
allow system_server init:unix_stream_socket connectto;
#line 470

#line 470
allow system_server fingerprint_prop:property_service set;
#line 470

#line 470
allow system_server fingerprint_prop:file { getattr open read ioctl lock map };
#line 470

#line 470


#line 471

#line 471
allow system_server property_socket:sock_file write;
#line 471
allow system_server init:unix_stream_socket connectto;
#line 471

#line 471
allow system_server device_logging_prop:property_service set;
#line 471

#line 471
allow system_server device_logging_prop:file { getattr open read ioctl lock map };
#line 471

#line 471


#line 472

#line 472
allow system_server property_socket:sock_file write;
#line 472
allow system_server init:unix_stream_socket connectto;
#line 472

#line 472
allow system_server dumpstate_options_prop:property_service set;
#line 472

#line 472
allow system_server dumpstate_options_prop:file { getattr open read ioctl lock map };
#line 472

#line 472


#line 473

#line 473
allow system_server property_socket:sock_file write;
#line 473
allow system_server init:unix_stream_socket connectto;
#line 473

#line 473
allow system_server overlay_prop:property_service set;
#line 473

#line 473
allow system_server overlay_prop:file { getattr open read ioctl lock map };
#line 473

#line 473


#line 474

#line 474
allow system_server property_socket:sock_file write;
#line 474
allow system_server init:unix_stream_socket connectto;
#line 474

#line 474
allow system_server wifi_log_prop:property_service set;
#line 474

#line 474
allow system_server wifi_log_prop:file { getattr open read ioctl lock map };
#line 474

#line 474


# ctl interface

#line 477

#line 477
allow system_server property_socket:sock_file write;
#line 477
allow system_server init:unix_stream_socket connectto;
#line 477

#line 477
allow system_server ctl_default_prop:property_service set;
#line 477

#line 477
allow system_server ctl_default_prop:file { getattr open read ioctl lock map };
#line 477

#line 477


#line 478

#line 478
allow system_server property_socket:sock_file write;
#line 478
allow system_server init:unix_stream_socket connectto;
#line 478

#line 478
allow system_server ctl_bugreport_prop:property_service set;
#line 478

#line 478
allow system_server ctl_bugreport_prop:file { getattr open read ioctl lock map };
#line 478

#line 478


# cppreopt property

#line 481

#line 481
allow system_server property_socket:sock_file write;
#line 481
allow system_server init:unix_stream_socket connectto;
#line 481

#line 481
allow system_server cppreopt_prop:property_service set;
#line 481

#line 481
allow system_server cppreopt_prop:file { getattr open read ioctl lock map };
#line 481

#line 481


# Collect metrics on boot time created by init

#line 484
allow system_server boottime_prop:file { getattr open read ioctl lock map };
#line 484


# Read device's serial number from system properties

#line 487
allow system_server serialno_prop:file { getattr open read ioctl lock map };
#line 487


# Read/write the property which keeps track of whether this is the first start of system_server

#line 490

#line 490
allow system_server property_socket:sock_file write;
#line 490
allow system_server init:unix_stream_socket connectto;
#line 490

#line 490
allow system_server firstboot_prop:property_service set;
#line 490

#line 490
allow system_server firstboot_prop:file { getattr open read ioctl lock map };
#line 490

#line 490


# Create a socket for connections from debuggerd.
allow system_server system_ndebug_socket:sock_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Manage cache files.
allow system_server cache_file:lnk_file { getattr open read ioctl lock map };
allow system_server { cache_file cache_recovery_file }:dir { relabelfrom { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } };
allow system_server { cache_file cache_recovery_file }:file { relabelfrom { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } } };
allow system_server { cache_file cache_recovery_file }:fifo_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

allow system_server system_file:dir { open getattr read search ioctl lock };
allow system_server system_file:lnk_file { getattr open read ioctl lock map };

# LocationManager(e.g, GPS) needs to read and write
# to uart driver and ctrl proc entry
allow system_server gps_control:file { { getattr open read ioctl lock map } { open append write lock map } };

# Allow system_server to use app-created sockets and pipes.
allow system_server appdomain:{ tcp_socket udp_socket } { getattr getopt setopt read write shutdown };
allow system_server appdomain:{ fifo_file unix_stream_socket } { getattr read write };

# BackupManagerService needs to manipulate backup data files
allow system_server cache_backup_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow system_server cache_backup_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
# LocalTransport works inside /cache/backup
allow system_server cache_private_backup_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow system_server cache_private_backup_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Allow system to talk to usb device
allow system_server usb_device:chr_file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server usb_device:dir { open getattr read search ioctl lock };

# Read from HW RNG (needed by EntropyMixer).
allow system_server hw_random_device:chr_file { getattr open read ioctl lock map };

# Read and delete files under /dev/fscklogs.

#line 527
allow system_server fscklogs:dir { open getattr read search ioctl lock };
#line 527
allow system_server fscklogs:{ file lnk_file } { getattr open read ioctl lock map };
#line 527

allow system_server fscklogs:dir { write remove_name };
allow system_server fscklogs:file unlink;

# logd access, system_server inherit logd write socket
# (urge is to deprecate this long term)
allow system_server zygote:unix_dgram_socket write;

# Read from log daemon.

#line 536
allow system_server logcat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
#line 536

#line 536

#line 536

#line 536
allow system_server logdr_socket:sock_file write;
#line 536
allow system_server logd:unix_stream_socket connectto;
#line 536

#line 536

#line 536


#line 537
allow system_server runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 537


# Be consistent with DAC permissions. Allow system_server to write to
# /sys/module/lowmemorykiller/parameters/adj
# /sys/module/lowmemorykiller/parameters/minfree
allow system_server sysfs_lowmemorykiller:file { getattr { open append write lock map } };

# Read /sys/fs/pstore/console-ramoops
# Don't worry about overly broad permissions for now, as there's
# only one file in /sys/fs/pstore
allow system_server pstorefs:dir { open getattr read search ioctl lock };
allow system_server pstorefs:file { getattr open read ioctl lock map };

# /sys access
allow system_server sysfs_zram:dir search;
allow system_server sysfs_zram:file { getattr open read ioctl lock map };


#line 554
  allow system_server system_server_service:service_manager { add find };
#line 554
  neverallow { domain -system_server } system_server_service:service_manager add;
#line 554
;
allow system_server audioserver_service:service_manager find;
allow system_server batteryproperties_service:service_manager find;
allow system_server cameraserver_service:service_manager find;
allow system_server drmserver_service:service_manager find;
allow system_server dumpstate_service:service_manager find;
allow system_server fingerprintd_service:service_manager find;
allow system_server hal_fingerprint_service:service_manager find;
allow system_server gatekeeper_service:service_manager find;
allow system_server incident_service:service_manager find;
allow system_server installd_service:service_manager find;
allow system_server keystore_service:service_manager find;
allow system_server mediaserver_service:service_manager find;
allow system_server mediametrics_service:service_manager find;
allow system_server mediaextractor_service:service_manager find;
allow system_server mediacodec_service:service_manager find;
allow system_server mediadrmserver_service:service_manager find;
allow system_server netd_service:service_manager find;
allow system_server nfc_service:service_manager find;
allow system_server radio_service:service_manager find;
allow system_server surfaceflinger_service:service_manager find;
allow system_server wificond_service:service_manager find;

allow system_server keystore:keystore_key {
	get_state
	get
	insert
	delete
	exist
	list
	reset
	password
	lock
	unlock
	is_empty
	sign
	verify
	grant
	duplicate
	clear_uid
	add_auth
	user_changed
};

# Allow system server to search and write to the persistent factory reset
# protection partition. This block device does not get wiped in a factory reset.
allow system_server block_device:dir search;
allow system_server frp_block_device:blk_file { { getattr open read ioctl lock map } { open append write lock map } };

# Clean up old cgroups
allow system_server cgroup:dir { remove_name rmdir };

# /oem access

#line 607
allow system_server oemfs:dir { open getattr read search ioctl lock };
#line 607
allow system_server oemfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 607


# Allow resolving per-user storage symlinks
allow system_server { mnt_user_file storage_file }:dir { getattr search };
allow system_server { mnt_user_file storage_file }:lnk_file { getattr read };

# Allow statfs() on storage devices, which happens fast enough that
# we shouldn't be killed during unsafe removal
allow system_server sdcard_type:dir { getattr search };

# Traverse into expanded storage
allow system_server mnt_expand_file:dir { open getattr read search ioctl lock };

# Allow system process to relabel the fingerprint directory after mkdir
# and delete the directory and files when no longer needed
allow system_server fingerprintd_data_file:dir { { open getattr read search ioctl lock } remove_name rmdir relabelto write };
allow system_server fingerprintd_data_file:file { getattr unlink };

# Allow system process to read network MAC address
allow system_server sysfs_mac_address:file { getattr open read ioctl lock map };


#line 628
  # Allow system server to create and write method traces in /data/misc/trace.
#line 628
  allow system_server method_trace_data_file:dir { open search write add_name remove_name lock };
#line 628
  allow system_server method_trace_data_file:file { create { open append write lock map } };
#line 628

#line 628
  # Allow system server to read dmesg
#line 628
  allow system_server kernel:system syslog_read;
#line 635


# For AppFuse.
allow system_server vold:fd use;
allow system_server fuse_device:chr_file { read write ioctl getattr };
allow system_server app_fuse_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow system_server app_fuse_file:file { read write open getattr append };

# For configuring sdcardfs
allow system_server configfs:dir { { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } } };
allow system_server configfs:file { getattr open unlink write };

# Connect to adbd and use a socket transferred from it.
# Used for e.g. jdwp.
allow system_server adbd:unix_stream_socket connectto;
allow system_server adbd:fd use;
allow system_server adbd:unix_stream_socket { getattr getopt ioctl read write shutdown };

# Allow invoking tools like "timeout"
allow system_server toolbox_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Postinstall
#
# For OTA dexopt, allow calls coming from postinstall.

#line 659
# Call the server domain and optionally transfer references to it.
#line 659
allow system_server postinstall:binder { call transfer };
#line 659
# Allow the serverdomain to transfer references to the client on the reply.
#line 659
allow postinstall system_server:binder transfer;
#line 659
# Receive and use open files from the server.
#line 659
allow system_server postinstall:fd use;
#line 659


allow system_server postinstall:fifo_file write;
allow system_server update_engine:fd use;
allow system_server update_engine:fifo_file write;

# Access to /data/preloads
allow system_server preloads_data_file:file { { getattr open read ioctl lock map } unlink };
allow system_server preloads_data_file:dir { { open getattr read search ioctl lock } write remove_name rmdir };
allow system_server preloads_media_file:file { { getattr open read ioctl lock map } unlink };
allow system_server preloads_media_file:dir { { open getattr read search ioctl lock } write remove_name rmdir };


#line 671
allow system_server cgroup:dir { open getattr read search ioctl lock };
#line 671
allow system_server cgroup:{ file lnk_file } { getattr open read ioctl lock map };
#line 671

allow system_server ion_device:chr_file { getattr open read ioctl lock map };


#line 674
allow system_server proc:dir { open getattr read search ioctl lock };
#line 674
allow system_server proc:{ file lnk_file } { getattr open read ioctl lock map };
#line 674


#line 675
allow system_server proc_meminfo:dir { open getattr read search ioctl lock };
#line 675
allow system_server proc_meminfo:{ file lnk_file } { getattr open read ioctl lock map };
#line 675


#line 676
allow system_server proc_net:dir { open getattr read search ioctl lock };
#line 676
allow system_server proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 676


#line 677
allow system_server rootfs:dir { open getattr read search ioctl lock };
#line 677
allow system_server rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 677


#line 678
allow system_server sysfs_type:dir { open getattr read search ioctl lock };
#line 678
allow system_server sysfs_type:{ file lnk_file } { getattr open read ioctl lock map };
#line 678


### Rules needed when Light HAL runs inside system_server process.
### These rules should eventually be granted only when needed.
allow system_server sysfs_leds:lnk_file read;
allow system_server sysfs_leds:file { { getattr open read ioctl lock map } { open append write lock map } };
allow system_server sysfs_leds:dir { open getattr read search ioctl lock };
###

# Allow WifiService to start, stop, and read wifi-specific trace events.
allow system_server debugfs_tracing_instances:dir search;
allow system_server debugfs_wifi_tracing:dir search;
allow system_server debugfs_wifi_tracing:file { { getattr open read ioctl lock map } { open append write lock map } };

# allow system_server to exec shell, asanwrapper & zygote(app_process) on ASAN builds. Needed to run
# asanwrapper.
#line 698


###
### Neverallow rules
###
### system_server should NEVER do any of this

# Do not allow opening files from external storage as unsafe ejection
# could cause the kernel to kill the system_server.
neverallow system_server sdcard_type:dir { open read write };
neverallow system_server sdcard_type:file { { getattr open read ioctl lock map } { open append write lock map } };

# system server should never be operating on zygote spawned app data
# files directly. Rather, they should always be passed via a
# file descriptor.
# Types extracted from seapp_contexts type= fields, excluding
# those types that system_server needs to open directly.
neverallow system_server { bluetooth_data_file nfc_data_file shell_data_file app_data_file }:file { open create unlink link };

# Forking and execing is inherently dangerous and racy. See, for
# example, https://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them
# Prevent the addition of new file execs to stop the problem from
# getting worse. b/28035297
neverallow system_server {
  file_type
  -toolbox_exec
  -logcat_exec
  
}:file execute_no_trans;

# Ensure that system_server doesn't perform any domain transitions other than
# transitioning to the crash_dump domain when a crash occurs.
neverallow system_server { domain -crash_dump }:process transition;
neverallow system_server *:process dyntransition;

# Only allow crash_dump to connect to system_ndebug_socket.
neverallow { domain -init -system_server -crash_dump } system_ndebug_socket:sock_file { open write };

# system_server should never be executing dex2oat. This is either
# a bug (for example, bug 16317188), or represents an attempt by
# system server to dynamically load a dex file, something we do not
# want to allow.
neverallow system_server dex2oat_exec:file { execute execute_no_trans };

# system_server should never execute or load executable shared libraries
# in /data except for /data/dalvik-cache files.
neverallow system_server {
  data_file_type
  -dalvikcache_data_file #mapping with PROT_EXEC
}:file { execute execute_no_trans };

# The only block device system_server should be accessing is
# the frp_block_device. This helps avoid a system_server to root
# escalation by writing to raw block devices.
neverallow system_server { dev_type -frp_block_device }:blk_file { { append create link unlink relabelfrom rename setattr write } open read ioctl lock };

# system_server should never use JIT functionality
neverallow system_server self:process execmem;
neverallow system_server ashmem_device:chr_file execute;

# TODO: deal with tmpfs_domain pub/priv split properly
neverallow system_server system_server_tmpfs:file execute;

# dexoptanalyzer is currently used only for secondary dex files which
# system_server should never access.
neverallow system_server dexoptanalyzer_exec:file { execute execute_no_trans };

# No ptracing others
neverallow system_server { domain -system_server }:process ptrace;

# CAP_SYS_RESOURCE was traditionally needed for sensitive /proc/PID
# file read access. However, that is now unnecessary (b/34951864)
# This neverallow can be removed after b/34951864 is fixed.
neverallow system_server system_server:capability sys_resource;
#line 1 "system/sepolicy/private/thermalserviced.te"
typeattribute thermalserviced coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init thermalserviced_exec:file { getattr open read execute map };
#line 3
allow init thermalserviced:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow thermalserviced thermalserviced_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init thermalserviced:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init thermalserviced:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init thermalserviced_exec:process thermalserviced;
#line 3

#line 3

#line 3
type thermalserviced_tmpfs, file_type;
#line 3
type_transition thermalserviced tmpfs:file thermalserviced_tmpfs;
#line 3
allow thermalserviced thermalserviced_tmpfs:file { read write getattr };
#line 3
allow thermalserviced tmpfs:dir { getattr search };
#line 3

#line 3


#line 1 "system/sepolicy/private/tombstoned.te"
typeattribute tombstoned coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init tombstoned_exec:file { getattr open read execute map };
#line 3
allow init tombstoned:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow tombstoned tombstoned_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init tombstoned:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init tombstoned:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init tombstoned_exec:process tombstoned;
#line 3

#line 3

#line 3
type tombstoned_tmpfs, file_type;
#line 3
type_transition tombstoned tmpfs:file tombstoned_tmpfs;
#line 3
allow tombstoned tombstoned_tmpfs:file { read write getattr };
#line 3
allow tombstoned tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/toolbox.te"
typeattribute toolbox coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init toolbox_exec:file { getattr open read execute map };
#line 3
allow init toolbox:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow toolbox toolbox_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init toolbox:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init toolbox:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init toolbox_exec:process toolbox;
#line 3

#line 3

#line 3
type toolbox_tmpfs, file_type;
#line 3
type_transition toolbox tmpfs:file toolbox_tmpfs;
#line 3
allow toolbox toolbox_tmpfs:file { read write getattr };
#line 3
allow toolbox tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/tzdatacheck.te"
typeattribute tzdatacheck coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init tzdatacheck_exec:file { getattr open read execute map };
#line 3
allow init tzdatacheck:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow tzdatacheck tzdatacheck_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init tzdatacheck:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init tzdatacheck:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init tzdatacheck_exec:process tzdatacheck;
#line 3

#line 3

#line 3
type tzdatacheck_tmpfs, file_type;
#line 3
type_transition tzdatacheck tmpfs:file tzdatacheck_tmpfs;
#line 3
allow tzdatacheck tzdatacheck_tmpfs:file { read write getattr };
#line 3
allow tzdatacheck tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/ueventd.te"
typeattribute ueventd coredomain;
typeattribute ueventd domain_deprecated;


#line 4
type ueventd_tmpfs, file_type;
#line 4
type_transition ueventd tmpfs:file ueventd_tmpfs;
#line 4
allow ueventd ueventd_tmpfs:file { read write getattr };
#line 4
allow ueventd tmpfs:dir { getattr search };
#line 4

#line 1 "system/sepolicy/private/uncrypt.te"
typeattribute uncrypt coredomain;
typeattribute uncrypt domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init uncrypt_exec:file { getattr open read execute map };
#line 4
allow init uncrypt:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow uncrypt uncrypt_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init uncrypt:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init uncrypt:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init uncrypt_exec:process uncrypt;
#line 4

#line 4

#line 4
type uncrypt_tmpfs, file_type;
#line 4
type_transition uncrypt tmpfs:file uncrypt_tmpfs;
#line 4
allow uncrypt uncrypt_tmpfs:file { read write getattr };
#line 4
allow uncrypt tmpfs:dir { getattr search };
#line 4

#line 4

#line 1 "system/sepolicy/private/untrusted_app.te"
###
### Untrusted apps.
###
### This file defines the rules for untrusted apps.
### Apps are labeled based on mac_permissions.xml (maps signer and
### optionally package name to seinfo value) and seapp_contexts (maps UID
### and optionally seinfo value to domain for process and type for data
### directory).  The untrusted_app domain is the default assignment in
### seapp_contexts for any app with UID between APP_AID (10000)
### and AID_ISOLATED_START (99000) if the app has no specific seinfo
### value as determined from mac_permissions.xml.  In current AOSP, this
### domain is assigned to all non-system apps as well as to any system apps
### that are not signed by the platform key.  To move
### a system app into a specific domain, add a signer entry for it to
### mac_permissions.xml and assign it one of the pre-existing seinfo values
### or define and use a new seinfo value in both mac_permissions.xml and
### seapp_contexts.
###

typeattribute untrusted_app coredomain;


#line 22
typeattribute untrusted_app appdomain;
#line 22
# Label ashmem objects with our own unique type.
#line 22

#line 22
type untrusted_app_tmpfs, file_type;
#line 22
type_transition untrusted_app tmpfs:file untrusted_app_tmpfs;
#line 22
allow untrusted_app untrusted_app_tmpfs:file { read write getattr };
#line 22
allow untrusted_app tmpfs:dir { getattr search };
#line 22

#line 22
# Map with PROT_EXEC.
#line 22
allow untrusted_app untrusted_app_tmpfs:file execute;
#line 22


#line 23
typeattribute untrusted_app untrusted_app_all;
#line 23


#line 24
typeattribute untrusted_app netdomain;
#line 24


#line 25
typeattribute untrusted_app bluetoothdomain;
#line 25


# allow untrusted apps to use UDP sockets provided by the system server but not
# modify them other than to connect
allow untrusted_app system_server:udp_socket { connect getattr read recvfrom sendto write };

# Allow the allocation and use of ptys
# Used by: https://play.google.com/store/apps/details?id=jackpal.androidterm

#line 33
# Each domain gets a unique devpts type.
#line 33
type untrusted_app_devpts, fs_type;
#line 33
# Label the pty with the unique type when created.
#line 33
type_transition untrusted_app devpts:chr_file untrusted_app_devpts;
#line 33
# Allow use of the pty after creation.
#line 33
allow untrusted_app untrusted_app_devpts:chr_file { open getattr read write ioctl };
#line 33
allowxperm untrusted_app untrusted_app_devpts:chr_file ioctl {
#line 33
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 33
  0x0000540b 0x00005410 0x0000540f
#line 33
};
#line 33
# TIOCSTI is only ever used for exploits. Block it.
#line 33
# b/33073072, b/7530569
#line 33
# http://www.openwall.com/lists/oss-security/2016/09/26/14
#line 33
neverallowxperm * untrusted_app_devpts:chr_file ioctl 0x00005412;
#line 33
# Note: devpts:dir search and ptmx_device:chr_file rw_file_perms
#line 33
# allowed to everyone via domain.te.
#line 33


neverallow untrusted_app system_server:udp_socket {
        accept append bind create getopt ioctl listen lock name_bind
        relabelfrom relabelto setattr setopt shutdown };
#line 1 "system/sepolicy/private/untrusted_app_25.te"
###
### Untrusted_app_25
###
### This file defines the rules for untrusted apps running with
### targetSdkVersion <= 25.
###
### Apps are labeled based on mac_permissions.xml (maps signer and
### optionally package name to seinfo value) and seapp_contexts (maps UID
### and optionally seinfo value to domain for process and type for data
### directory).  The untrusted_app domain is the default assignment in
### seapp_contexts for any app with UID between APP_AID (10000)
### and AID_ISOLATED_START (99000) if the app has no specific seinfo
### value as determined from mac_permissions.xml.  In current AOSP, this
### domain is assigned to all non-system apps as well as to any system apps
### that are not signed by the platform key.  To move
### a system app into a specific domain, add a signer entry for it to
### mac_permissions.xml and assign it one of the pre-existing seinfo values
### or define and use a new seinfo value in both mac_permissions.xml and
### seapp_contexts.
###

typeattribute untrusted_app_25 coredomain;


#line 24
typeattribute untrusted_app_25 appdomain;
#line 24
# Label ashmem objects with our own unique type.
#line 24

#line 24
type untrusted_app_25_tmpfs, file_type;
#line 24
type_transition untrusted_app_25 tmpfs:file untrusted_app_25_tmpfs;
#line 24
allow untrusted_app_25 untrusted_app_25_tmpfs:file { read write getattr };
#line 24
allow untrusted_app_25 tmpfs:dir { getattr search };
#line 24

#line 24
# Map with PROT_EXEC.
#line 24
allow untrusted_app_25 untrusted_app_25_tmpfs:file execute;
#line 24


#line 25
typeattribute untrusted_app_25 untrusted_app_all;
#line 25


#line 26
typeattribute untrusted_app_25 netdomain;
#line 26


#line 27
typeattribute untrusted_app_25 bluetoothdomain;
#line 27


# Allow the allocation and use of ptys
# Used by: https://play.google.com/store/apps/details?id=jackpal.androidterm

#line 31
# Each domain gets a unique devpts type.
#line 31
type untrusted_app_25_devpts, fs_type;
#line 31
# Label the pty with the unique type when created.
#line 31
type_transition untrusted_app_25 devpts:chr_file untrusted_app_25_devpts;
#line 31
# Allow use of the pty after creation.
#line 31
allow untrusted_app_25 untrusted_app_25_devpts:chr_file { open getattr read write ioctl };
#line 31
allowxperm untrusted_app_25 untrusted_app_25_devpts:chr_file ioctl {
#line 31
  0x00005411 0x00005451 0x00005401 0x00005402 0x00005413 0x00005414 0x0000540e 0x00005403
#line 31
  0x0000540b 0x00005410 0x0000540f
#line 31
};
#line 31
# TIOCSTI is only ever used for exploits. Block it.
#line 31
# b/33073072, b/7530569
#line 31
# http://www.openwall.com/lists/oss-security/2016/09/26/14
#line 31
neverallowxperm * untrusted_app_25_devpts:chr_file ioctl 0x00005412;
#line 31
# Note: devpts:dir search and ptmx_device:chr_file rw_file_perms
#line 31
# allowed to everyone via domain.te.
#line 31


# b/34115651 - net.dns* properties read
# This will go away in a future Android release

#line 35
allow untrusted_app_25 net_dns_prop:file { getattr open read ioctl lock map };
#line 35


# b/35917228 - /proc/misc access
# This will go away in a future Android release
allow untrusted_app_25 proc_misc:file { getattr open read ioctl lock map };

# Access to /proc/tty/drivers, to allow apps to determine if they
# are running in an emulated environment.
# b/33214085 b/33814662 b/33791054 b/33211769
# https://github.com/strazzere/anti-emulator/blob/master/AntiEmulator/src/diff/strazzere/anti/emulator/FindEmulator.java
# This will go away in a future Android release
allow untrusted_app_25 proc_tty_drivers:file { getattr open read ioctl lock map };
#line 1 "system/sepolicy/private/untrusted_app_all.te"
###
### Untrusted_app_all.
###
### This file defines the rules shared by all untrusted app domains except
### apps which target the v2 security sandbox (ephemeral_app for instant apps,
### untrusted_v2_app for fully installed v2 apps).
### Apps are labeled based on mac_permissions.xml (maps signer and
### optionally package name to seinfo value) and seapp_contexts (maps UID
### and optionally seinfo value to domain for process and type for data
### directory).  The untrusted_app_all attribute is assigned to all default
### seapp_contexts for any app with UID between APP_AID (10000)
### and AID_ISOLATED_START (99000) if the app has no specific seinfo
### value as determined from mac_permissions.xml.  In current AOSP, this
### attribute is assigned to all non-system apps as well as to any system apps
### that are not signed by the platform key.  To move
### a system app into a specific domain, add a signer entry for it to
### mac_permissions.xml and assign it one of the pre-existing seinfo values
### or define and use a new seinfo value in both mac_permissions.xml and
### seapp_contexts.
###
### Note that rules that should apply to all untrusted apps must be in app.te or also
### added to untrusted_v2_app.te and ephemeral_app.te.

# Legacy text relocations
allow untrusted_app_all apk_data_file:file execmod;

# Some apps ship with shared libraries and binaries that they write out
# to their sandbox directory and then execute.
allow untrusted_app_all app_data_file:file { { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } } execmod };

# ASEC
allow untrusted_app_all asec_apk_file:file { getattr open read ioctl lock map };
allow untrusted_app_all asec_apk_file:dir { open getattr read search ioctl lock };
# Execute libs in asec containers.
allow untrusted_app_all asec_public_file:file { execute execmod };

# Used by Finsky / Android "Verify Apps" functionality when
# running "adb install foo.apk".
# TODO: Long term, we don't want apps probing into shell data files.
# Figure out a way to remove these rules.
allow untrusted_app_all shell_data_file:file { getattr open read ioctl lock map };
allow untrusted_app_all shell_data_file:dir { open getattr read search ioctl lock };

# Allow to read staged apks.
allow untrusted_app_all { apk_tmp_file apk_private_tmp_file }:file {read getattr};

# Read and write system app data files passed over Binder.
# Motivating case was /data/data/com.android.settings/cache/*.jpg for
# cropping or taking user photos.
allow untrusted_app_all system_app_data_file:file { read write getattr };

#
# Rules migrated from old app domains coalesced into untrusted_app.
# This includes what used to be media_app, shared_app, and release_app.
#

# Access to /data/media.
allow untrusted_app_all media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow untrusted_app_all media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Traverse into /mnt/media_rw for bypassing FUSE daemon
# TODO: narrow this to just MediaProvider
allow untrusted_app_all mnt_media_rw_file:dir search;

# allow cts to query all services
allow untrusted_app_all servicemanager:service_manager list;

allow untrusted_app_all audioserver_service:service_manager find;
allow untrusted_app_all cameraserver_service:service_manager find;
allow untrusted_app_all drmserver_service:service_manager find;
allow untrusted_app_all mediaserver_service:service_manager find;
allow untrusted_app_all mediaextractor_service:service_manager find;
allow untrusted_app_all mediacodec_service:service_manager find;
allow untrusted_app_all mediametrics_service:service_manager find;
allow untrusted_app_all mediadrmserver_service:service_manager find;
allow untrusted_app_all nfc_service:service_manager find;
allow untrusted_app_all radio_service:service_manager find;
allow untrusted_app_all surfaceflinger_service:service_manager find;
allow untrusted_app_all app_api_service:service_manager find;
allow untrusted_app_all vr_manager_service:service_manager find;

# Allow GMS core to access perfprofd output, which is stored
# in /data/misc/perfprofd/. GMS core will need to list all
# data stored in that directory to process them one by one.

#line 85
  allow untrusted_app_all perfprofd_data_file:file { getattr open read ioctl lock map };
#line 85
  allow untrusted_app_all perfprofd_data_file:dir { open getattr read search ioctl lock };
#line 88


# gdbserver for ndk-gdb ptrace attaches to app process.
allow untrusted_app_all self:process ptrace;

# Cts: HwRngTest
allow untrusted_app_all sysfs_hwrandom:dir search;
allow untrusted_app_all sysfs_hwrandom:file { getattr open read ioctl lock map };

# Allow apps to view preloaded media content
allow untrusted_app_all preloads_media_file:dir { open getattr read search ioctl lock };
allow untrusted_app_all preloads_media_file:file { getattr open read ioctl lock map };
allow untrusted_app_all preloads_data_file:dir search;

# Allow untrusted apps read / execute access to /vendor/app for there can
# be pre-installed vendor apps that package a library within themselves.
# TODO (b/37784178) Consider creating  a special type for /vendor/app installed
# apps.
allow untrusted_app_all vendor_app_file:dir { open getattr read search };
allow untrusted_app_all vendor_app_file:file { open getattr read execute };
allow untrusted_app_all vendor_app_file:lnk_file { open getattr read };
#line 1 "system/sepolicy/private/untrusted_v2_app.te"
###
### Untrusted v2 sandbox apps.
###

typeattribute untrusted_v2_app coredomain;


#line 7
typeattribute untrusted_v2_app appdomain;
#line 7
# Label ashmem objects with our own unique type.
#line 7

#line 7
type untrusted_v2_app_tmpfs, file_type;
#line 7
type_transition untrusted_v2_app tmpfs:file untrusted_v2_app_tmpfs;
#line 7
allow untrusted_v2_app untrusted_v2_app_tmpfs:file { read write getattr };
#line 7
allow untrusted_v2_app tmpfs:dir { getattr search };
#line 7

#line 7
# Map with PROT_EXEC.
#line 7
allow untrusted_v2_app untrusted_v2_app_tmpfs:file execute;
#line 7


#line 8
typeattribute untrusted_v2_app netdomain;
#line 8


#line 9
typeattribute untrusted_v2_app bluetoothdomain;
#line 9


# Read and write system app data files passed over Binder.
# Motivating case was /data/data/com.android.settings/cache/*.jpg for
# cropping or taking user photos.
allow untrusted_v2_app system_app_data_file:file { read write getattr };

# Access to /data/media.
allow untrusted_v2_app media_rw_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow untrusted_v2_app media_rw_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Traverse into /mnt/media_rw for bypassing FUSE daemon
# TODO: narrow this to just MediaProvider
allow untrusted_v2_app mnt_media_rw_file:dir search;

# allow cts to query all services
allow untrusted_v2_app servicemanager:service_manager list;

allow untrusted_v2_app audioserver_service:service_manager find;
allow untrusted_v2_app cameraserver_service:service_manager find;
allow untrusted_v2_app drmserver_service:service_manager find;
allow untrusted_v2_app mediaserver_service:service_manager find;
allow untrusted_v2_app mediaextractor_service:service_manager find;
allow untrusted_v2_app mediacodec_service:service_manager find;
allow untrusted_v2_app mediametrics_service:service_manager find;
allow untrusted_v2_app mediadrmserver_service:service_manager find;
allow untrusted_v2_app nfc_service:service_manager find;
allow untrusted_v2_app radio_service:service_manager find;
allow untrusted_v2_app surfaceflinger_service:service_manager find;
# TODO: potentially provide a tighter list of services here
allow untrusted_v2_app app_api_service:service_manager find;

# gdbserver for ndk-gdb ptrace attaches to app process.
allow untrusted_v2_app self:process ptrace;
#line 1 "system/sepolicy/private/update_engine.te"
typeattribute update_engine coredomain;
typeattribute update_engine domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init update_engine_exec:file { getattr open read execute map };
#line 4
allow init update_engine:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow update_engine update_engine_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init update_engine:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init update_engine:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init update_engine_exec:process update_engine;
#line 4

#line 4

#line 4
type update_engine_tmpfs, file_type;
#line 4
type_transition update_engine tmpfs:file update_engine_tmpfs;
#line 4
allow update_engine update_engine_tmpfs:file { read write getattr };
#line 4
allow update_engine tmpfs:dir { getattr search };
#line 4

#line 4
;
#line 1 "system/sepolicy/private/update_engine_common.te"
# type_transition must be private policy the domain_trans rules could stay
# public, but conceptually should go with this
# The postinstall program is run by update_engine_common and will always be tagged as a
# postinstall_file regardless of its attributes in the new system.

#line 5
# Allow the necessary permissions.
#line 5

#line 5
# Old domain may exec the file and transition to the new domain.
#line 5
allow update_engine_common postinstall_file:file { getattr open read execute map };
#line 5
allow update_engine_common postinstall:process transition;
#line 5
# New domain is entered by executing the file.
#line 5
allow postinstall postinstall_file:file { entrypoint open read execute getattr map };
#line 5
# New domain can send SIGCHLD to its caller.
#line 5
allow postinstall update_engine_common:process sigchld;
#line 5
# Enable AT_SECURE, i.e. libc secure mode.
#line 5
dontaudit update_engine_common postinstall:process noatsecure;
#line 5
# XXX dontaudit candidate but requires further study.
#line 5
allow update_engine_common postinstall:process { siginh rlimitinh };
#line 5

#line 5
# Make the transition occur by default.
#line 5
type_transition update_engine_common postinstall_file:process postinstall;
#line 5

#line 1 "system/sepolicy/private/update_verifier.te"
typeattribute update_verifier coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init update_verifier_exec:file { getattr open read execute map };
#line 3
allow init update_verifier:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow update_verifier update_verifier_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init update_verifier:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init update_verifier:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init update_verifier_exec:process update_verifier;
#line 3

#line 3

#line 3
type update_verifier_tmpfs, file_type;
#line 3
type_transition update_verifier tmpfs:file update_verifier_tmpfs;
#line 3
allow update_verifier update_verifier_tmpfs:file { read write getattr };
#line 3
allow update_verifier tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/vdc.te"
typeattribute vdc coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init vdc_exec:file { getattr open read execute map };
#line 3
allow init vdc:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow vdc vdc_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init vdc:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init vdc:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init vdc_exec:process vdc;
#line 3

#line 3

#line 3
type vdc_tmpfs, file_type;
#line 3
type_transition vdc tmpfs:file vdc_tmpfs;
#line 3
allow vdc vdc_tmpfs:file { read write getattr };
#line 3
allow vdc tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/virtual_touchpad.te"
typeattribute virtual_touchpad coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init virtual_touchpad_exec:file { getattr open read execute map };
#line 3
allow init virtual_touchpad:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow virtual_touchpad virtual_touchpad_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init virtual_touchpad:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init virtual_touchpad:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init virtual_touchpad_exec:process virtual_touchpad;
#line 3

#line 3

#line 3
type virtual_touchpad_tmpfs, file_type;
#line 3
type_transition virtual_touchpad tmpfs:file virtual_touchpad_tmpfs;
#line 3
allow virtual_touchpad virtual_touchpad_tmpfs:file { read write getattr };
#line 3
allow virtual_touchpad tmpfs:dir { getattr search };
#line 3

#line 3

#line 1 "system/sepolicy/private/vold.te"
typeattribute vold coredomain;
typeattribute vold domain_deprecated;


#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init vold_exec:file { getattr open read execute map };
#line 4
allow init vold:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow vold vold_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init vold:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init vold:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init vold_exec:process vold;
#line 4

#line 4

#line 4
type vold_tmpfs, file_type;
#line 4
type_transition vold tmpfs:file vold_tmpfs;
#line 4
allow vold vold_tmpfs:file { read write getattr };
#line 4
allow vold tmpfs:dir { getattr search };
#line 4

#line 4


# Switch to more restrictive domains when executing common tools

#line 7
# Allow the necessary permissions.
#line 7

#line 7
# Old domain may exec the file and transition to the new domain.
#line 7
allow vold sgdisk_exec:file { getattr open read execute map };
#line 7
allow vold sgdisk:process transition;
#line 7
# New domain is entered by executing the file.
#line 7
allow sgdisk sgdisk_exec:file { entrypoint open read execute getattr map };
#line 7
# New domain can send SIGCHLD to its caller.
#line 7
allow sgdisk vold:process sigchld;
#line 7
# Enable AT_SECURE, i.e. libc secure mode.
#line 7
dontaudit vold sgdisk:process noatsecure;
#line 7
# XXX dontaudit candidate but requires further study.
#line 7
allow vold sgdisk:process { siginh rlimitinh };
#line 7

#line 7
# Make the transition occur by default.
#line 7
type_transition vold sgdisk_exec:process sgdisk;
#line 7
;

#line 8
# Allow the necessary permissions.
#line 8

#line 8
# Old domain may exec the file and transition to the new domain.
#line 8
allow vold sdcardd_exec:file { getattr open read execute map };
#line 8
allow vold sdcardd:process transition;
#line 8
# New domain is entered by executing the file.
#line 8
allow sdcardd sdcardd_exec:file { entrypoint open read execute getattr map };
#line 8
# New domain can send SIGCHLD to its caller.
#line 8
allow sdcardd vold:process sigchld;
#line 8
# Enable AT_SECURE, i.e. libc secure mode.
#line 8
dontaudit vold sdcardd:process noatsecure;
#line 8
# XXX dontaudit candidate but requires further study.
#line 8
allow vold sdcardd:process { siginh rlimitinh };
#line 8

#line 8
# Make the transition occur by default.
#line 8
type_transition vold sdcardd_exec:process sdcardd;
#line 8
;

# For a handful of probing tools, we choose an even more restrictive
# domain when working with untrusted block devices

#line 12
# Old domain may exec the file and transition to the new domain.
#line 12
allow vold shell_exec:file { getattr open read execute map };
#line 12
allow vold blkid:process transition;
#line 12
# New domain is entered by executing the file.
#line 12
allow blkid shell_exec:file { entrypoint open read execute getattr map };
#line 12
# New domain can send SIGCHLD to its caller.
#line 12
allow blkid vold:process sigchld;
#line 12
# Enable AT_SECURE, i.e. libc secure mode.
#line 12
dontaudit vold blkid:process noatsecure;
#line 12
# XXX dontaudit candidate but requires further study.
#line 12
allow vold blkid:process { siginh rlimitinh };
#line 12
;

#line 13
# Old domain may exec the file and transition to the new domain.
#line 13
allow vold shell_exec:file { getattr open read execute map };
#line 13
allow vold blkid_untrusted:process transition;
#line 13
# New domain is entered by executing the file.
#line 13
allow blkid_untrusted shell_exec:file { entrypoint open read execute getattr map };
#line 13
# New domain can send SIGCHLD to its caller.
#line 13
allow blkid_untrusted vold:process sigchld;
#line 13
# Enable AT_SECURE, i.e. libc secure mode.
#line 13
dontaudit vold blkid_untrusted:process noatsecure;
#line 13
# XXX dontaudit candidate but requires further study.
#line 13
allow vold blkid_untrusted:process { siginh rlimitinh };
#line 13
;

#line 14
# Old domain may exec the file and transition to the new domain.
#line 14
allow vold fsck_exec:file { getattr open read execute map };
#line 14
allow vold fsck:process transition;
#line 14
# New domain is entered by executing the file.
#line 14
allow fsck fsck_exec:file { entrypoint open read execute getattr map };
#line 14
# New domain can send SIGCHLD to its caller.
#line 14
allow fsck vold:process sigchld;
#line 14
# Enable AT_SECURE, i.e. libc secure mode.
#line 14
dontaudit vold fsck:process noatsecure;
#line 14
# XXX dontaudit candidate but requires further study.
#line 14
allow vold fsck:process { siginh rlimitinh };
#line 14
;

#line 15
# Old domain may exec the file and transition to the new domain.
#line 15
allow vold fsck_exec:file { getattr open read execute map };
#line 15
allow vold fsck_untrusted:process transition;
#line 15
# New domain is entered by executing the file.
#line 15
allow fsck_untrusted fsck_exec:file { entrypoint open read execute getattr map };
#line 15
# New domain can send SIGCHLD to its caller.
#line 15
allow fsck_untrusted vold:process sigchld;
#line 15
# Enable AT_SECURE, i.e. libc secure mode.
#line 15
dontaudit vold fsck_untrusted:process noatsecure;
#line 15
# XXX dontaudit candidate but requires further study.
#line 15
allow vold fsck_untrusted:process { siginh rlimitinh };
#line 15
;

# Newly created storage dirs are always treated as mount stubs to prevent us
# from accidentally writing when the mount point isn't present.
type_transition vold storage_file:dir storage_stub_file;
type_transition vold mnt_media_rw_file:dir mnt_media_rw_stub_file;
#line 1 "system/sepolicy/private/vr_hwc.te"
typeattribute vr_hwc coredomain;

# Daemon started by init.

#line 4

#line 4
# Allow the necessary permissions.
#line 4

#line 4
# Old domain may exec the file and transition to the new domain.
#line 4
allow init vr_hwc_exec:file { getattr open read execute map };
#line 4
allow init vr_hwc:process transition;
#line 4
# New domain is entered by executing the file.
#line 4
allow vr_hwc vr_hwc_exec:file { entrypoint open read execute getattr map };
#line 4
# New domain can send SIGCHLD to its caller.
#line 4

#line 4
# Enable AT_SECURE, i.e. libc secure mode.
#line 4
dontaudit init vr_hwc:process noatsecure;
#line 4
# XXX dontaudit candidate but requires further study.
#line 4
allow init vr_hwc:process { siginh rlimitinh };
#line 4

#line 4
# Make the transition occur by default.
#line 4
type_transition init vr_hwc_exec:process vr_hwc;
#line 4

#line 4

#line 4
type vr_hwc_tmpfs, file_type;
#line 4
type_transition vr_hwc tmpfs:file vr_hwc_tmpfs;
#line 4
allow vr_hwc vr_hwc_tmpfs:file { read write getattr };
#line 4
allow vr_hwc tmpfs:dir { getattr search };
#line 4

#line 4



#line 6
typeattribute vr_hwc halserverdomain;
#line 6
typeattribute vr_hwc hal_graphics_composer_server;
#line 6
typeattribute vr_hwc hal_graphics_composer;
#line 6

#line 1 "system/sepolicy/private/watchdogd.te"
typeattribute watchdogd coredomain;
#line 1 "system/sepolicy/private/webview_zygote.te"
# webview_zygote is an auxiliary zygote process that is used to spawn
# isolated_app processes for rendering untrusted web content.

typeattribute webview_zygote coredomain;

# The webview_zygote needs to be able to transition domains.
typeattribute webview_zygote mlstrustedsubject;

# When init launches the WebView zygote's executable, transition the
# resulting process into webview_zygote domain.

#line 11

#line 11
# Allow the necessary permissions.
#line 11

#line 11
# Old domain may exec the file and transition to the new domain.
#line 11
allow init webview_zygote_exec:file { getattr open read execute map };
#line 11
allow init webview_zygote:process transition;
#line 11
# New domain is entered by executing the file.
#line 11
allow webview_zygote webview_zygote_exec:file { entrypoint open read execute getattr map };
#line 11
# New domain can send SIGCHLD to its caller.
#line 11

#line 11
# Enable AT_SECURE, i.e. libc secure mode.
#line 11
dontaudit init webview_zygote:process noatsecure;
#line 11
# XXX dontaudit candidate but requires further study.
#line 11
allow init webview_zygote:process { siginh rlimitinh };
#line 11

#line 11
# Make the transition occur by default.
#line 11
type_transition init webview_zygote_exec:process webview_zygote;
#line 11

#line 11

#line 11
type webview_zygote_tmpfs, file_type;
#line 11
type_transition webview_zygote tmpfs:file webview_zygote_tmpfs;
#line 11
allow webview_zygote webview_zygote_tmpfs:file { read write getattr };
#line 11
allow webview_zygote tmpfs:dir { getattr search };
#line 11

#line 11


# Allow reading/executing installed binaries to enable preloading the
# installed WebView implementation.
allow webview_zygote apk_data_file:dir { open getattr read search ioctl lock };
allow webview_zygote apk_data_file:file { { getattr open read ioctl lock map } execute };

# Access to the WebView relro file.
allow webview_zygote shared_relro_file:dir search;
allow webview_zygote shared_relro_file:file { getattr open read ioctl lock map };

# Set the UID/GID of the process.
allow webview_zygote self:capability { setgid setuid };
# Drop capabilities from bounding set.
allow webview_zygote self:capability setpcap;
# Switch SELinux context to app domains.
allow webview_zygote self:process setcurrent;
allow webview_zygote isolated_app:process dyntransition;

# For art.
allow webview_zygote dalvikcache_data_file:dir { open getattr read search ioctl lock };
allow webview_zygote dalvikcache_data_file:lnk_file { getattr open read ioctl lock map };
allow webview_zygote dalvikcache_data_file:file { { getattr open read ioctl lock map } execute };

# Allow webview_zygote to stat the files that it opens. It must
# be able to inspect them so that it can reopen them on fork
# if necessary: b/30963384.
allow webview_zygote debugfs_trace_marker:file getattr;

# Allow webview_zygote to manage the pgroup of its children.
allow webview_zygote system_server:process getpgid;

# Interaction between the webview_zygote and its children.
allow webview_zygote isolated_app:process setpgid;

# TODO (b/63631799) fix this access
# Suppress denials to storage. Webview zygote should not be accessing.
dontaudit webview_zygote mnt_expand_file:dir getattr;

# Get seapp_contexts
allow webview_zygote seapp_contexts_file:file { getattr open read ioctl lock map };
# Check validity of SELinux context before use.

#line 53

#line 53
allow webview_zygote selinuxfs:dir { open getattr read search ioctl lock };
#line 53
allow webview_zygote selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 53

#line 53
allow webview_zygote selinuxfs:file { open append write lock map };
#line 53
allow webview_zygote kernel:security check_context;
#line 53

# Check SELinux permissions.

#line 55

#line 55
allow webview_zygote selinuxfs:dir { open getattr read search ioctl lock };
#line 55
allow webview_zygote selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 55

#line 55
allow webview_zygote selinuxfs:file { open append write lock map };
#line 55
allow webview_zygote kernel:security compute_av;
#line 55
allow webview_zygote self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 55


#####
##### Neverallow
#####

# Only permit transition to isolated_app.
neverallow webview_zygote { domain -isolated_app }:process dyntransition;

# Only setcon() transitions, no exec() based transitions, except for crash_dump.
neverallow webview_zygote { domain -crash_dump }:process transition;

# Must not exec() a program without changing domains.
# Having said that, exec() above is not allowed.
neverallow webview_zygote *:file execute_no_trans;

# The only way to enter this domain is for init to exec() us.
neverallow { domain -init } webview_zygote:process transition;
neverallow * webview_zygote:process dyntransition;

# Disallow write access to properties.
neverallow webview_zygote property_socket:sock_file write;
neverallow webview_zygote property_type:property_service set;

# Should not have any access to app data files.
neverallow webview_zygote {
    app_data_file
    system_app_data_file
    bluetooth_data_file
    nfc_data_file
    radio_data_file
    shell_data_file
}:file { { { { getattr open read ioctl lock map } { open append write lock map } } { getattr execute execute_no_trans map } } };

neverallow webview_zygote {
    service_manager_type
    -activity_service
    -webviewupdate_service
}:service_manager find;

# Isolated apps shouldn't be able to access the driver directly.
neverallow webview_zygote gpu_device:chr_file { { { { getattr open read ioctl lock map } { open append write lock map } } { getattr execute execute_no_trans map } } };

# Do not allow webview_zygote access to /cache.
neverallow webview_zygote cache_file:dir ~{ { open getattr read search ioctl lock } };
neverallow webview_zygote cache_file:file ~{ read getattr };

# Do not allow most socket access. This is socket_class_set, excluding unix_dgram_socket,
# unix_stream_socket, and netlink_selinux_socket.
neverallow webview_zygote domain:{
  socket tcp_socket udp_socket rawip_socket netlink_socket packet_socket key_socket
  appletalk_socket netlink_route_socket netlink_tcpdiag_socket
  netlink_nflog_socket netlink_xfrm_socket netlink_audit_socket
  netlink_dnrt_socket netlink_kobject_uevent_socket tun_socket netlink_iscsi_socket
  netlink_fib_lookup_socket netlink_connector_socket netlink_netfilter_socket
  netlink_generic_socket netlink_scsitransport_socket netlink_rdma_socket netlink_crypto_socket
  sctp_socket icmp_socket ax25_socket ipx_socket netrom_socket atmpvc_socket
  x25_socket rose_socket decnet_socket atmsvc_socket rds_socket irda_socket
  pppox_socket llc_socket can_socket tipc_socket bluetooth_socket iucv_socket
  rxrpc_socket isdn_socket phonet_socket ieee802154_socket caif_socket
  alg_socket nfc_socket vsock_socket kcm_socket qipcrtr_socket smc_socket
} *;

# Do not allow access to Bluetooth-related system properties.
# neverallow rules for Bluetooth-related data files are listed above.
neverallow webview_zygote bluetooth_prop:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 1 "system/sepolicy/private/wificond.te"
typeattribute wificond coredomain;


#line 3

#line 3
# Allow the necessary permissions.
#line 3

#line 3
# Old domain may exec the file and transition to the new domain.
#line 3
allow init wificond_exec:file { getattr open read execute map };
#line 3
allow init wificond:process transition;
#line 3
# New domain is entered by executing the file.
#line 3
allow wificond wificond_exec:file { entrypoint open read execute getattr map };
#line 3
# New domain can send SIGCHLD to its caller.
#line 3

#line 3
# Enable AT_SECURE, i.e. libc secure mode.
#line 3
dontaudit init wificond:process noatsecure;
#line 3
# XXX dontaudit candidate but requires further study.
#line 3
allow init wificond:process { siginh rlimitinh };
#line 3

#line 3
# Make the transition occur by default.
#line 3
type_transition init wificond_exec:process wificond;
#line 3

#line 3

#line 3
type wificond_tmpfs, file_type;
#line 3
type_transition wificond tmpfs:file wificond_tmpfs;
#line 3
allow wificond wificond_tmpfs:file { read write getattr };
#line 3
allow wificond tmpfs:dir { getattr search };
#line 3

#line 3


#line 4
typeattribute wificond halclientdomain;
#line 4
typeattribute wificond hal_wifi_offload_client;
#line 4

#line 4
# TODO(b/34170079): Make the inclusion of the rules below conditional also on
#line 4
# non-Treble devices. For now, on non-Treble device, always grant clients of a
#line 4
# HAL sufficient access to run the HAL in passthrough mode (i.e., in-process).
#line 4

#line 4
typeattribute wificond hal_wifi_offload;
#line 4
# Find passthrough HAL implementations
#line 4
allow hal_wifi_offload system_file:dir { open getattr read search ioctl lock };
#line 4
allow hal_wifi_offload vendor_file:dir { open getattr read search ioctl lock };
#line 4
allow hal_wifi_offload vendor_file:file { read open getattr execute map };
#line 4

#line 4

#line 1 "system/sepolicy/private/zygote.te"
# zygote
typeattribute zygote coredomain;
typeattribute zygote domain_deprecated;
typeattribute zygote mlstrustedsubject;


#line 6

#line 6
# Allow the necessary permissions.
#line 6

#line 6
# Old domain may exec the file and transition to the new domain.
#line 6
allow init zygote_exec:file { getattr open read execute map };
#line 6
allow init zygote:process transition;
#line 6
# New domain is entered by executing the file.
#line 6
allow zygote zygote_exec:file { entrypoint open read execute getattr map };
#line 6
# New domain can send SIGCHLD to its caller.
#line 6

#line 6
# Enable AT_SECURE, i.e. libc secure mode.
#line 6
dontaudit init zygote:process noatsecure;
#line 6
# XXX dontaudit candidate but requires further study.
#line 6
allow init zygote:process { siginh rlimitinh };
#line 6

#line 6
# Make the transition occur by default.
#line 6
type_transition init zygote_exec:process zygote;
#line 6

#line 6

#line 6
type zygote_tmpfs, file_type;
#line 6
type_transition zygote tmpfs:file zygote_tmpfs;
#line 6
allow zygote zygote_tmpfs:file { read write getattr };
#line 6
allow zygote tmpfs:dir { getattr search };
#line 6

#line 6



#line 8
allow zygote runtime_event_log_tags_file:file { getattr open read ioctl lock map };
#line 8


# Override DAC on files and switch uid/gid.
allow zygote self:capability { dac_override setgid setuid fowner chown };

# Drop capabilities from bounding set.
allow zygote self:capability setpcap;

# Switch SELinux context to app domains.
allow zygote self:process setcurrent;
allow zygote system_server:process dyntransition;
allow zygote appdomain:process dyntransition;

# Allow zygote to read app /proc/pid dirs (b/10455872).
allow zygote appdomain:dir { getattr search };
allow zygote appdomain:file { { getattr open read ioctl lock map } };

# Move children into the peer process group.
allow zygote system_server:process { getpgid setpgid };
allow zygote appdomain:process { getpgid setpgid };

# Read system data.
allow zygote system_data_file:dir { open getattr read search ioctl lock };
allow zygote system_data_file:file { getattr open read ioctl lock map };

# Write to /data/dalvik-cache.
allow zygote dalvikcache_data_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow zygote dalvikcache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Create symlinks in /data/dalvik-cache.
allow zygote dalvikcache_data_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# Write to /data/resource-cache.
allow zygote resourcecache_data_file:dir { { open getattr read search ioctl lock } { open search write add_name remove_name lock } };
allow zygote resourcecache_data_file:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };

# When WITH_DEXPREOPT is true, the zygote does not load executable content from
# /data/dalvik-cache.
allow { zygote -zygote } dalvikcache_data_file:file execute;

# Execute idmap and dex2oat within zygote's own domain.
# TODO:  Should either of these be transitioned to the same domain
# used by installd or stay in-domain for zygote?
allow zygote idmap_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };
allow zygote dex2oat_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Allow apps access to /vendor/overlay

#line 55
allow zygote vendor_overlay_file:dir { open getattr read search ioctl lock };
#line 55
allow zygote vendor_overlay_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 55


# Control cgroups.
allow zygote cgroup:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow zygote cgroup:{ file lnk_file } { getattr open read ioctl lock map };
allow zygote self:capability sys_admin;

# Allow zygote to stat the files that it opens. The zygote must
# be able to inspect them so that it can reopen them on fork
# if necessary: b/30963384.
allow zygote pmsg_device:chr_file getattr;
allow zygote debugfs_trace_marker:file getattr;

# Get seapp_contexts
allow zygote seapp_contexts_file:file { getattr open read ioctl lock map };
# Check validity of SELinux context before use.

#line 71

#line 71
allow zygote selinuxfs:dir { open getattr read search ioctl lock };
#line 71
allow zygote selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 71

#line 71
allow zygote selinuxfs:file { open append write lock map };
#line 71
allow zygote kernel:security check_context;
#line 71

# Check SELinux permissions.

#line 73

#line 73
allow zygote selinuxfs:dir { open getattr read search ioctl lock };
#line 73
allow zygote selinuxfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 73

#line 73
allow zygote selinuxfs:file { open append write lock map };
#line 73
allow zygote kernel:security compute_av;
#line 73
allow zygote self:netlink_selinux_socket { read write create getattr setattr lock relabelfrom relabelto append bind connect listen accept getopt setopt shutdown recvfrom sendto name_bind };
#line 73


# Native bridge functionality requires that zygote replaces
# /proc/cpuinfo with /system/lib/<ISA>/cpuinfo using a bind mount
allow zygote proc_cpuinfo:file mounton;

# Allow remounting rootfs as MS_SLAVE.
allow zygote rootfs:dir mounton;
allow zygote tmpfs:filesystem { mount unmount };
allow zygote fuse:filesystem { unmount };
allow zygote sdcardfs:filesystem { unmount };

# Allow creating user-specific storage source if started before vold.
allow zygote mnt_user_file:dir { create reparent rename rmdir setattr { { open getattr read search ioctl lock } { open search write add_name remove_name lock } } };
allow zygote mnt_user_file:lnk_file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
# Allowed to mount user-specific storage into place
allow zygote storage_file:dir { search mounton };

# Handle --invoke-with command when launching Zygote with a wrapper command.
allow zygote zygote_exec:file { { getattr open read ioctl lock map } { getattr execute execute_no_trans map } };

# Read access to pseudo filesystems.

#line 95
allow zygote proc_net:dir { open getattr read search ioctl lock };
#line 95
allow zygote proc_net:{ file lnk_file } { getattr open read ioctl lock map };
#line 95


# Root fs.

#line 98
allow zygote rootfs:dir { open getattr read search ioctl lock };
#line 98
allow zygote rootfs:{ file lnk_file } { getattr open read ioctl lock map };
#line 98


# System file accesses.

#line 101
allow zygote system_file:dir { open getattr read search ioctl lock };
#line 101
allow zygote system_file:{ file lnk_file } { getattr open read ioctl lock map };
#line 101



#line 103
  # Allow zygote to create and write method traces in /data/misc/trace.
#line 103
  allow zygote method_trace_data_file:dir { open search write add_name remove_name lock };
#line 103
  allow zygote method_trace_data_file:file { create { open append write lock map } };
#line 107


allow zygote ion_device:chr_file { getattr open read ioctl lock map };
allow zygote tmpfs:dir { open getattr read search ioctl lock };

# Let the zygote access overlays so it can initialize the AssetManager.

#line 113
allow zygote overlay_prop:file { getattr open read ioctl lock map };
#line 113


###
### neverallow rules
###

# Ensure that all types assigned to app processes are included
# in the appdomain attribute, so that all allow and neverallow rules
# written on appdomain are applied to all app processes.
# This is achieved by ensuring that it is impossible for zygote to
# setcon (dyntransition) to any types other than those associated
# with appdomain plus system_server.
neverallow zygote ~{ appdomain system_server }:process dyntransition;

# Zygote should never execute anything from /data except for /data/dalvik-cache files.
neverallow zygote {
  data_file_type
  -dalvikcache_data_file # map PROT_EXEC
}:file { execute execute_no_trans };

# Do not allow access to Bluetooth-related system properties and files
neverallow zygote bluetooth_prop:file { create rename setattr unlink { { getattr open read ioctl lock map } { open append write lock map } } };
#line 1 "system/sepolicy/private/roles_decl"
role r;
#line 1 "system/sepolicy/public/roles"
role r types domain;
#line 1 "system/sepolicy/private/users"
user u roles { r } level s0 range s0 - s0:c0.c1023;
#line 1 "system/sepolicy/private/initial_sid_contexts"
sid kernel u:r:kernel:s0
sid security u:object_r:kernel:s0
sid unlabeled u:object_r:unlabeled:s0
sid fs u:object_r:labeledfs:s0
sid file u:object_r:unlabeled:s0
sid file_labels u:object_r:unlabeled:s0
sid init u:object_r:unlabeled:s0
sid any_socket u:object_r:unlabeled:s0
sid port u:object_r:port:s0
sid netif u:object_r:netif:s0
sid netmsg u:object_r:unlabeled:s0
sid node u:object_r:node:s0
sid igmp_packet u:object_r:unlabeled:s0
sid icmp_socket u:object_r:unlabeled:s0
sid tcp_socket u:object_r:unlabeled:s0
sid sysctl_modprobe u:object_r:unlabeled:s0
sid sysctl u:object_r:proc:s0
sid sysctl_fs u:object_r:unlabeled:s0
sid sysctl_kernel u:object_r:unlabeled:s0
sid sysctl_net u:object_r:unlabeled:s0
sid sysctl_net_unix u:object_r:unlabeled:s0
sid sysctl_vm u:object_r:unlabeled:s0
sid sysctl_dev u:object_r:unlabeled:s0
sid kmod u:object_r:unlabeled:s0
sid policy u:object_r:unlabeled:s0
sid scmp_packet u:object_r:unlabeled:s0
sid devnull u:object_r:null_device:s0
#line 1 "system/sepolicy/private/fs_use"
# Label inodes via getxattr.
fs_use_xattr yaffs2 u:object_r:labeledfs:s0;
fs_use_xattr jffs2 u:object_r:labeledfs:s0;
fs_use_xattr ext2 u:object_r:labeledfs:s0;
fs_use_xattr ext3 u:object_r:labeledfs:s0;
fs_use_xattr ext4 u:object_r:labeledfs:s0;
fs_use_xattr xfs u:object_r:labeledfs:s0;
fs_use_xattr btrfs u:object_r:labeledfs:s0;
fs_use_xattr f2fs u:object_r:labeledfs:s0;
fs_use_xattr squashfs u:object_r:labeledfs:s0;

# Label inodes from task label.
fs_use_task pipefs u:object_r:pipefs:s0;
fs_use_task sockfs u:object_r:sockfs:s0;

# Label inodes from combination of task label and fs label.
# Define type_transition rules if you want per-domain types.
fs_use_trans devpts u:object_r:devpts:s0;
fs_use_trans tmpfs u:object_r:tmpfs:s0;
fs_use_trans devtmpfs u:object_r:device:s0;
fs_use_trans shm u:object_r:shm:s0;
fs_use_trans mqueue u:object_r:mqueue:s0;

#line 1 "system/sepolicy/private/genfs_contexts"
# Label inodes with the fs label.
genfscon rootfs / u:object_r:rootfs:s0
# proc labeling can be further refined (longest matching prefix).
genfscon proc / u:object_r:proc:s0
genfscon proc /config.gz u:object_r:config_gz:s0
genfscon proc /interrupts u:object_r:proc_interrupts:s0
genfscon proc /iomem u:object_r:proc_iomem:s0
genfscon proc /meminfo u:object_r:proc_meminfo:s0
genfscon proc /misc u:object_r:proc_misc:s0
genfscon proc /modules u:object_r:proc_modules:s0
genfscon proc /net u:object_r:proc_net:s0
genfscon proc /net/xt_qtaguid/ctrl u:object_r:qtaguid_proc:s0
genfscon proc /cpuinfo u:object_r:proc_cpuinfo:s0
genfscon proc /softirqs u:object_r:proc_timer:s0
genfscon proc /stat u:object_r:proc_stat:s0
genfscon proc /sysrq-trigger u:object_r:proc_sysrq:s0
genfscon proc /sys/fs/protected_hardlinks u:object_r:proc_security:s0
genfscon proc /sys/fs/protected_symlinks u:object_r:proc_security:s0
genfscon proc /sys/fs/suid_dumpable u:object_r:proc_security:s0
genfscon proc /sys/kernel/core_pattern u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/dmesg_restrict u:object_r:proc_security:s0
genfscon proc /sys/kernel/hotplug u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/kptr_restrict u:object_r:proc_security:s0
genfscon proc /sys/kernel/modprobe u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/modules_disabled u:object_r:proc_security:s0
genfscon proc /sys/kernel/perf_event_max_sample_rate u:object_r:proc_perf:s0
genfscon proc /sys/kernel/poweroff_cmd u:object_r:usermodehelper:s0
genfscon proc /sys/kernel/randomize_va_space u:object_r:proc_security:s0
genfscon proc /sys/kernel/usermodehelper u:object_r:usermodehelper:s0
genfscon proc /sys/net u:object_r:proc_net:s0
genfscon proc /sys/vm/mmap_min_addr u:object_r:proc_security:s0
genfscon proc /sys/vm/mmap_rnd_bits u:object_r:proc_security:s0
genfscon proc /sys/vm/mmap_rnd_compat_bits u:object_r:proc_security:s0
genfscon proc /sys/vm/drop_caches u:object_r:proc_drop_caches:s0
genfscon proc /sys/vm/overcommit_memory u:object_r:proc_overcommit_memory:s0
genfscon proc /timer_list u:object_r:proc_timer:s0
genfscon proc /timer_stats u:object_r:proc_timer:s0
genfscon proc /tty/drivers u:object_r:proc_tty_drivers:s0
genfscon proc /uid_cputime/show_uid_stat u:object_r:proc_uid_cputime_showstat:s0
genfscon proc /uid_cputime/remove_uid_range u:object_r:proc_uid_cputime_removeuid:s0
genfscon proc /uid_io/stats u:object_r:proc_uid_io_stats:s0
genfscon proc /uid_procstat/set u:object_r:proc_uid_procstat_set:s0
genfscon proc /uid_time_in_state u:object_r:proc_uid_time_in_state:s0
genfscon proc /zoneinfo u:object_r:proc_zoneinfo:s0

# selinuxfs booleans can be individually labeled.
genfscon selinuxfs / u:object_r:selinuxfs:s0
genfscon cgroup / u:object_r:cgroup:s0
# sysfs labels can be set by userspace.
genfscon sysfs / u:object_r:sysfs:s0
genfscon sysfs /devices/system/cpu u:object_r:sysfs_devices_system_cpu:s0
genfscon sysfs /class/leds                        u:object_r:sysfs_leds:s0
genfscon sysfs /devices/platform/nfc-power/nfc_power u:object_r:sysfs_nfc_power_writable:s0
genfscon sysfs /devices/virtual/block/zram0     u:object_r:sysfs_zram:s0
genfscon sysfs /devices/virtual/block/zram1     u:object_r:sysfs_zram:s0
genfscon sysfs /devices/virtual/block/zram0/uevent    u:object_r:sysfs_zram_uevent:s0
genfscon sysfs /devices/virtual/block/zram1/uevent    u:object_r:sysfs_zram_uevent:s0
genfscon sysfs /devices/virtual/misc/hw_random    u:object_r:sysfs_hwrandom:s0
genfscon sysfs /fs/ext4/features                  u:object_r:sysfs_fs_ext4_features:s0
genfscon sysfs /power/wake_lock u:object_r:sysfs_wake_lock:s0
genfscon sysfs /power/wake_unlock u:object_r:sysfs_wake_lock:s0
genfscon sysfs /kernel/uevent_helper u:object_r:sysfs_usermodehelper:s0
genfscon sysfs /module/lowmemorykiller u:object_r:sysfs_lowmemorykiller:s0
genfscon sysfs /module/wlan/parameters/fwpath u:object_r:sysfs_wlan_fwpath:s0
genfscon sysfs /devices/virtual/timed_output/vibrator/enable u:object_r:sysfs_vibrator:s0

genfscon debugfs /mmc0                                u:object_r:debugfs_mmc:s0
genfscon debugfs /tracing                             u:object_r:debugfs_tracing:s0
genfscon debugfs /tracing/instances                   u:object_r:debugfs_tracing_instances:s0
genfscon tracefs /instances                           u:object_r:debugfs_tracing_instances:s0
genfscon debugfs /tracing/instances/wifi              u:object_r:debugfs_wifi_tracing:s0
genfscon tracefs /instances/wifi                      u:object_r:debugfs_wifi_tracing:s0
genfscon debugfs /tracing/trace_marker                u:object_r:debugfs_trace_marker:s0
genfscon tracefs /trace_marker                        u:object_r:debugfs_trace_marker:s0

genfscon debugfs /tracing/events/sync/enable                         u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/workqueue/enable                    u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/regulator/enable                    u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/pagecache/enable                    u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/irq/enable                          u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/ipi/enable                          u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/f2fs/f2fs_sync_file_enter/enable    u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/f2fs/f2fs_sync_file_exit/enable     u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/f2fs/f2fs_write_begin/enable        u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/f2fs/f2fs_write_end/enable          u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/ext4/ext4_da_write_begin/enable     u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/ext4/ext4_da_write_end/enable       u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/ext4/ext4_sync_file_enter/enable    u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/ext4/ext4_sync_file_exit/enable     u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/block/block_rq_issue/enable         u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/events/block/block_rq_complete/enable      u:object_r:debugfs_tracing_debug:s0
genfscon debugfs /tracing/saved_cmdlines_size                        u:object_r:debugfs_tracing_debug:s0

genfscon tracefs /events/sync/enable                         u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/workqueue/enable                    u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/regulator/enable                    u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/pagecache/enable                    u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/irq/enable                          u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/ipi/enable                          u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/f2fs/f2fs_sync_file_enter/enable    u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/f2fs/f2fs_sync_file_exit/enable     u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/f2fs/f2fs_write_begin/enable        u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/f2fs/f2fs_write_end/enable          u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/ext4/ext4_da_write_begin/enable     u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/ext4/ext4_da_write_end/enable       u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/ext4/ext4_sync_file_enter/enable    u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/ext4/ext4_sync_file_exit/enable     u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/block/block_rq_issue/enable         u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /events/block/block_rq_complete/enable      u:object_r:debugfs_tracing_debug:s0
genfscon tracefs /saved_cmdlines_size                        u:object_r:debugfs_tracing_debug:s0

genfscon inotifyfs / u:object_r:inotify:s0
genfscon vfat / u:object_r:vfat:s0
genfscon debugfs / u:object_r:debugfs:s0
genfscon tracefs / u:object_r:debugfs_tracing:s0
genfscon fuse / u:object_r:fuse:s0
genfscon configfs / u:object_r:configfs:s0
genfscon sdcardfs / u:object_r:sdcardfs:s0
genfscon pstore / u:object_r:pstorefs:s0
genfscon functionfs / u:object_r:functionfs:s0
genfscon usbfs / u:object_r:usbfs:s0
genfscon binfmt_misc / u:object_r:binfmt_miscfs:s0
#line 1 "system/sepolicy/private/port_contexts"
# portcon statements go here, e.g.
# portcon tcp 80 u:object_r:http_port:s0

