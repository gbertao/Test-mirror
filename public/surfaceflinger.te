# surfaceflinger - display compositor service
type surfaceflinger, domain;
type surfaceflinger_exec, exec_type, file_type;

typeattribute surfaceflinger mlstrustedsubject;

# surfaceflinger_tmpfs is public so devices can pass
# ashmem/tmpfs allocated buffers via IPC for graphics
# rendering applications.
type surfaceflinger_tmpfs, file_type;
allow surfaceflinger surfaceflinger_tmpfs:file { read write };
allow surfaceflinger tmpfs:dir { getattr search };

# Perform HwBinder IPC.
hwbinder_use(surfaceflinger)
binder_call(surfaceflinger, hal_graphics_allocator)
binder_call(surfaceflinger, hal_graphics_composer)

# Perform Binder IPC.
binder_use(surfaceflinger)
binder_call(surfaceflinger, binderservicedomain)
binder_call(surfaceflinger, appdomain)
binder_call(surfaceflinger, bootanim)
binder_service(surfaceflinger)

# Binder IPC to bu, presently runs in adbd domain.
binder_call(surfaceflinger, adbd)

# Read /proc/pid files for Binder clients.
r_dir_file(surfaceflinger, binderservicedomain)
r_dir_file(surfaceflinger, appdomain)

# Access the GPU.
allow surfaceflinger gpu_device:chr_file rw_file_perms;

# Access /dev/graphics/fb0.
allow surfaceflinger graphics_device:dir search;
allow surfaceflinger graphics_device:chr_file rw_file_perms;

# Access /dev/video1.
allow surfaceflinger video_device:dir r_dir_perms;
allow surfaceflinger video_device:chr_file rw_file_perms;

# Create and use netlink kobject uevent sockets.
allow surfaceflinger self:netlink_kobject_uevent_socket create_socket_perms_no_ioctl;

# Set properties.
set_prop(surfaceflinger, system_prop)
set_prop(surfaceflinger, ctl_bootanim_prop)

# Use open files supplied by an app.
allow surfaceflinger appdomain:fd use;
allow surfaceflinger app_data_file:file { read write };

# Allow a dumpstate triggered screenshot
binder_call(surfaceflinger, dumpstate)
binder_call(surfaceflinger, shell)
r_dir_file(surfaceflinger, dumpstate)

# Needed on some devices for playing DRM protected content,
# but seems expected and appropriate for all devices.
allow surfaceflinger tee:unix_stream_socket connectto;
allow surfaceflinger tee_device:chr_file rw_file_perms;


# media.player service
add_service(surfaceflinger, gpu_service)
add_service(surfaceflinger, surfaceflinger_service)

allow surfaceflinger mediaserver_service:service_manager find;
allow surfaceflinger permission_service:service_manager find;
allow surfaceflinger power_service:service_manager find;
allow surfaceflinger window_service:service_manager find;

# allow self to set SCHED_FIFO
allow surfaceflinger self:capability sys_nice;
allow surfaceflinger proc_meminfo:file r_file_perms;
r_dir_file(surfaceflinger, cgroup)
r_dir_file(surfaceflinger, sysfs_type)
r_dir_file(surfaceflinger, system_file)
allow surfaceflinger tmpfs:dir r_dir_perms;
allow surfaceflinger system_server:fd use;
allow surfaceflinger ion_device:chr_file r_file_perms;

###
### Neverallow rules
###
### surfaceflinger should NEVER do any of this

# Do not allow accessing SDcard files as unsafe ejection could
# cause the kernel to kill the process.
neverallow surfaceflinger sdcard_type:file rw_file_perms;

# Domains should only read/write and possible stat a surfaceflinger_tmpfs buffer
# XXX better way? some of these are covered by general neverallows...
neverallow {
    domain
    -surfaceflinger
} surfaceflinger_tmpfs:file {
    ioctl
	create
	setattr
	lock
	append
	unlink
	link
	rename
	execute
	quotaon
	mounton
	execute_no_trans
	entrypoint
	execmod
	open
	audit_access
};
