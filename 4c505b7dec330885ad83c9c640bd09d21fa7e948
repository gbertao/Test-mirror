{
  "comments": [
    {
      "key": {
        "uuid": "1bca1158_87b535a1",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2019-08-06T23:24:39Z",
      "side": 1,
      "message": "I\u0027m starting to question whether we really need such a high granularity of access control for exported props. IIUC exported props are of interest because they cross Treble boundary, so do we care if an exported prop is set from vendor_init or, say, rild? As long as we can guarantee that all exported props have stable API, we\u0027re OK, right?",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2823523_6a5a3a85",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-06T23:36:29Z",
      "side": 1,
      "message": "Correct. We don\u0027t need to distinguish vendor_init from other vendor processes. To us, they are all the same. So vendor_init_* could be renamed to just vendor_*.\n\nBut we anyway need to distinguish core(system)/public/vendor and readable/settable/non_settable, right?",
      "parentUuid": "1bca1158_87b535a1",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fb55eff6_aea334c9",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2019-08-07T00:10:52Z",
      "side": 1,
      "message": "Not sure, could you give an example? I can\u0027t think of a reason why we want to distinguish between system reading a vendor prop and vendor reading a system prop.",
      "parentUuid": "b2823523_6a5a3a85",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "deae3a54_6c9214e0",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-07T00:47:07Z",
      "side": 1,
      "message": "system reading a vendor-defined prop (e.g. ro.qcom.foo.bar) is a Treble violation, while vendor reading a system prop (e.g. ro.build.product) is okay as long as the system prop is made public.\n\nWe also want to distinguish read-only and writable sysprops. For example, it is okay for vendor to read ro.secure, but it\u0027s not okay for them to set it (via vendor_init).",
      "parentUuid": "fb55eff6_aea334c9",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62e6e2b3_0b6be4ac",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2019-08-07T05:36:02Z",
      "side": 1,
      "message": "I think renaming vendor_init_* to vendor_* can be confusing and a little overpowered. It sounds like every vendor process will be able to touch the exported properties. Why do we want that, even when granting access to only vendor_init is enough?",
      "parentUuid": "deae3a54_6c9214e0",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b38d7a48_928aa350",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2019-08-07T20:41:29Z",
      "side": 1,
      "message": "I agree that permissions need to be more granular. I think we should keep the permissions in terms of types, not attributes. And use the attributes to fix the neverallows, which imo is the problematic area with the existing scheme, e.g.\n\n # This definition might need refinement.\n define(`vendordomain\u0027,`{ domain -coredomain }\u0027)\n\n # Prop is set by system iff it has system_prop_type attribute.\n attribute system_prop_type;\n neverallow coredomain { property_type -system_prop_type }:property_service set;\n neverallow vendordomain system_prop_type:property_service set;\n # We\u0027ll need to test to make sure that all props have property_type attribute on them.\n\n # System can\u0027t read props set by vendor except whitelist.\n neverallow coredomain {\n        vendor_prop_type\n        -...\n }:file no_rw_file_perms;\n\n # Plus symmetric rules for vendordomain and vendor_prop_type.\n\nSo, say, vendor_init sets foo_prop, and system_server reads it, then\n\n type foo_prop, vendor_prop_type\n set_prop(vendor_init, foo_prop);\n get_prop(system_server, foo_prop);\n # Add foo_prop to the list to coredomain\u0027s neverallow whitelist\n # If foo_prop-specific constraints need to be introduced, write neverallows in terms of foo_prop.\n\nThis way we:\n(1) avoid embedding access control policy into names of attributes.\n(2) relax the neverallows, which makes us room to rename/merge/change semantics of existing \"exported\" props.\n(3) maintain high granularity of permission, because we don\u0027t grant them using attributes.\n\nProblem with this approach is that it assumes props are only set from either system or vendor.\n\nSorry for the churn. WDYT?",
      "parentUuid": "62e6e2b3_0b6be4ac",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8455f724_e7dc19dc",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-08T03:23:58Z",
      "side": 1,
      "message": "neverallow vendordomain system_prop_type:property_service set;\n\nI think this is wrong. There are many platform-defined properties that are expected to be set by vendor. They act as control knobs to the platform.\n\nHowever, in a broader sense, I think we are saying the same thing. Attributes will be used for specifying overarching rules like \u0027vendor process can\u0027t access private properties from platform\u0027. This will allow us to avoid adding type names to the rules whenever a new type is added. Domain-specific rules like \u0027process X can/can\u0027t write certain props\u0027 will still be written with types.",
      "parentUuid": "b38d7a48_928aa350",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31149ba7_a55386f0",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2019-08-08T19:07:44Z",
      "side": 1,
      "message": "\u003e neverallow vendordomain system_prop_type:property_service set;\n\n\u003e I think this is wrong. There are many platform-defined properties that are expected to be set by vendor. They act as control knobs to the platform.\n\nIn this case that platform-defined prop should have vendor_prop_type attribute. \n\nThat may sound odd, but I think making the setter, in this example vendor, also the \"owner\" of the prop simplifies the way we reason about these props, even if the definition of the type is in system. This is somewhat like a HAL interface being defined in system, but the HAL process counts as a vendor process.\n\n\u003e However, in a broader sense, I think we are saying the same thing. Attributes will be used for specifying overarching rules like \u0027vendor process can\u0027t access private properties from platform\u0027. This will allow us to avoid adding type names to the rules whenever a new type is added. Domain-specific rules like \u0027process X can/can\u0027t write certain props\u0027 will still be written with types.\n\nYes, we agree on the general idea. There is a caveat with attributes though. Say, you have:\n neverallow some_domains { \n        property_type;\n        -public_readable_property_type\n }:file no_rw_file_perms;\n\nHere, you need to test that public_readable_property_type is not applied inappropriately by vendors.\n\nI would prefer a scheme that avoids this neverallow pattern with \"-attribute\".",
      "parentUuid": "8455f724_e7dc19dc",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b516c600_6ba6b29e",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2019-08-09T09:32:39Z",
      "side": 1,
      "message": "Three thoughts:\n\n1) Suppose we introduce attributes that represent the owner, e.g. vendor_prop_type, system_prop_type, etc, and create neverallow rules based on them. Then properties with no such attributes will have no restrictions at all. So we must enforce one of such attributes is assigned to each property. But won\u0027t it be so painful to fix all of them in once?\n\nOn the other hand, if we introduce access policy attributes like this, I think we can refactor one by one.\n\n2) I don\u0027t understand why access policy attributes are bad.\n\n3) But, still I absolutely agree to avoid \"-attribute\".",
      "parentUuid": "31149ba7_a55386f0",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "44f502e4_e8be28a4",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-09T09:45:57Z",
      "side": 1,
      "message": "Tri, \n\n\u003e In this case that platform-defined prop should have vendor_prop_type attribute. \n\nYeah, but that\u0027s what vendor_init_settable_property_type is for. Isn\u0027t it more descriptive and less confusing then just saying vendor_prop_type?\n\n\u003e Here, you need to test that public_readable_property_type is not applied inappropriately by vendors.\n\nSure we can have tests.\n\n\u003e I would prefer a scheme that avoids this neverallow pattern with \"-attribute\".\n\nYeah, attribute is powerful but sepolicy itself doesn\u0027t seem to be capable of restricting associating an attribute to a type. So we have to rely on external tests.\n\n\nInseob,\n\n\u003e Then properties with no such attributes will have no restrictions at all\n\nIf there is no rule, nothing is allowed. We could also have a neverallow rule for properties that don\u0027t have any attribute.\n\nneverallow domain { property_type -vendor_prop_type -system_prop_type -xxx_prop_type}:file r_file_perms",
      "parentUuid": "31149ba7_a55386f0",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06a6074d_2805ccc2",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1124693
      },
      "writtenOn": "2019-08-09T19:14:14Z",
      "side": 1,
      "message": "Inseob,\n\n\u003e 1) Suppose we introduce attributes that represent the owner, e.g. vendor_prop_type, system_prop_type, etc, and create neverallow rules based on them. Then properties with no such attributes will have no restrictions at all. \n\nNeither system nor vendor would be able to set the prop in this case though.\n\n\u003e So we must enforce one of such attributes is assigned to each property. But won\u0027t it be so painful to fix all of them in once?\n\nYes, you\u0027re right. Doing this for vendor props would be very painful.\n\n\u003e 2) I don\u0027t understand why access policy attributes are bad.\n\nAssuming we avoid \"-attribute\", we might have something like\n\n get_prop(x, core_readable_property_type);\n neverallow y { core_readable_property_type -z }:file read;\n\nThis makes it problematic to add more to core_readable_property_type, since that adds more permission and tightens a neverallow at the same time. Also, first rule is too permissive.\n\n\nJiyong,\n\n\u003e Yeah, but that\u0027s what vendor_init_settable_property_type is for. Isn\u0027t it more descriptive and less confusing then just saying vendor_prop_type?\n\n\"vendor_init_settable_property_type\" conflates labels with rules. We generally avoid embedding access control policy in the names and instead express them as rules. I think vendor_prop_type + associated rules is more consistent with the convention.\n\nMaybe SELinux folks can weigh in on this?\n\n\u003e Sure we can have tests.\n\nIt doesn\u0027t seem like a trivial thing to do. Will we have to maintain another whitelist of types that are allowed to be public_readable_property_type? same for vendor_init_readable_property_type, vendor_init_settable_property_type \n\nOTOH ensuring (vendor_prop_type \u003d\u003d props set by vendor) is fairly straightforward:\n\n neverallow { domain -coredomain } { property_type -vendor_prop_type }:property_service set;\n neverallow coredomain vendor_prop_type:property_service set;\n\nNote that this approach leverages the fact that we can trust \"coredomain\" to mean \"system process\", since we already test that. The only real test we\u0027d need to add is checking that *all* props have property_type attribute. We can do that by looking at all property_contexts and cross-checking with the policy. We already do something like this with system_file_type and vendor_file_type.",
      "parentUuid": "44f502e4_e8be28a4",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ec39bb7_ef1e0c3d",
        "filename": "public/attributes",
        "patchSetId": 3
      },
      "lineNbr": 95,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2019-09-20T00:05:46Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "06a6074d_2805ccc2",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 95,
        "endChar": 49
      },
      "revId": "4c505b7dec330885ad83c9c640bd09d21fa7e948",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}