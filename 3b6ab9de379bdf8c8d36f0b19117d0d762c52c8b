{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a1c0fae0_07de7482",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2023-01-19T20:47:41Z",
      "side": 1,
      "message": "-1 to this from me as well. There are already NDK APIs to select networks and we should use those. As for needing to obtain a net_handle_t - it\u0027s true that that is difficult without calling Java APIs, but in general if you can\u0027t call Java APIs you can\u0027t obtain the state of networking at all anyway.\n\nWhere does this code live? How does it know what interface to use, and how does it know that that interface is currently connected and can be used? Is this all just hardcoded?",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fac99e9f_ee9d4a60",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2023-01-19T20:55:48Z",
      "side": 1,
      "message": "This code is a HAL implementation so it has to be native. The interface is hard-coded. We know what interface it is because we control the network environment. We are reevaluating whether it is possible to pass the network interfacae down through java layer.",
      "parentUuid": "a1c0fae0_07de7482",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10d9246d_e4a129c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1135107
      },
      "writtenOn": "2023-01-19T21:26:21Z",
      "side": 1,
      "message": "How much of a problem would it be to add NDK API to obtain net_handle_t? This is about to be a common problem for our other project.",
      "parentUuid": "fac99e9f_ee9d4a60",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4fa6e6bd_2e2feca3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2023-01-19T21:57:12Z",
      "side": 1,
      "message": "\u003e How much of a problem would it be to add NDK API to obtain net_handle_t? This is about to be a common problem for our other project.\n\nA net_handle_t for which network? I don\u0027t think we can help much unless we know what you are trying to achieve.",
      "parentUuid": "10d9246d_e4a129c2",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa87c51a_a6445cc7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2023-01-19T22:18:54Z",
      "side": 1,
      "message": "We are trying to get net_handle_t for ethernet interface with a specific name, like \u0027eth0\u0027. We are trying to achieve something similar to:\n\nsetsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, mIfname.c_str(), mIfname.size());",
      "parentUuid": "4fa6e6bd_2e2feca3",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f396af6e_531abab1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000835
      },
      "writtenOn": "2023-01-20T02:33:24Z",
      "side": 1,
      "message": "That\u0027s already very clear. What\u0027s not clear is - what process is this code running in? Does this process have a java component? Who creates this interface? What NetworkCapabilities does it have? What is its lifecycle? etc.",
      "parentUuid": "aa87c51a_a6445cc7",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e27f572d_ed7f5fa8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1135107
      },
      "writtenOn": "2023-01-20T23:27:49Z",
      "side": 1,
      "message": "Actually, in the case of most of our other uses (Yu\u0027s use also fits here IMO), we want to grab net_handle_t of a network with VEHICLE_INTERNAL capability. So far we\u0027ve been \"hardcoding\" (via custom config file) to a specific interface name because of missing NDK APIs to fetch it by network capability.\n\nA good part of these services are AIDL HAL proxies - they are native, separate processes and don\u0027t have any Java components (their clients may be Java, but we can\u0027t modify e.g. GNSS, Radio or Supplicant HAL to inject this implementation-specific info).\n\nThe lifecycle of these processes starts early in the boot process and the interface is present (hardwired) all the time, from boot until shutdown (unless there\u0027s some hardware fault).",
      "parentUuid": "f396af6e_531abab1",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e8675f8_a09432a8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1003247
      },
      "writtenOn": "2023-01-21T09:08:35Z",
      "side": 1,
      "message": "netd already knows which interfaces map to which netids, since this is required for iproute/iptables configuration which it performs, and other things - and we require for there to be at most one netid associated with an interface otherwise packet marking simply doesn\u0027t work (note that the reverse is not true: not all interfaces are assigned to a netid).\n\n# iptables-save -t mangle | egrep \u0027^-A routectrl_mangle_INPUT -i wlan0 -j MARK --set-xmark 0x\u0027                                                                             \n-A routectrl_mangle_INPUT -i wlan0 -j MARK --set-xmark 0x30073/0xffefffff\n\nthe netid for wlan0 is thus 0x30073 \u0026 0xFFFF \u003d\u003d 0x73, which IFIRC means the net handle is netIdToNetHandle(0x73) \u003d\u003d 0x73cafed00d\n\n(side note: it\u0027s also possible to figure this out as the shell user just from inspecting the ip rule/route configuration, though it\u0027s much more annoying to do)\n\nIt doesn\u0027t seem unreasonable to add a native api to lookup a network by interface name...\n\nIt seems pretty trivial to do - netd just needs to iterate over all the Network objects looking for one where hasInterface(\"eth0\") returns true and return netIdtoNetHandle(Network.getNetId())\n\nsee system/netd/server/Network.h:\n  class Network {\n    unsigned getNetId() const;\n    bool hasInterface(const std::string\u0026 interface) const;\n\nI guess the question is whether via binder (presumably a privileged rpc?) or via fwmarkserver (allowing binding directly to an interface in addition to a nethandle)\n\nOf course... this would have no notification system, and netids can come and go... but for a use case like this one where AFAICT they\u0027re static... it seems reasonable enough to me for a root/system uid priv binder call?\n\nThat said I\u0027m not sure whether this is a good idea or not... Lorenzo?",
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9d6935a_9206644b",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2023-01-13T10:02:36Z",
      "side": 1,
      "message": "It would probably be better to use hal_automotive_socket_exemption here, as below; this also seems like it shouldn\u0027t happen on non-auto builds.\n\nBut it\u0027s not clear to me that the exemption should be extended to this neverallow. I\u0027ll leave it to @jeffv@google.com to decide.",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9917eb6c_d9fa0ed8",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1054468
      },
      "writtenOn": "2023-01-13T11:07:09Z",
      "side": 1,
      "message": "Let\u0027s ask the Core networking team if this is acceptable. Generally only core networking code should be allowed to modify network settings. This appears to break that assumption.\n\n+lorenzo@ and +maze@ to comment.",
      "parentUuid": "b9d6935a_9206644b",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e38c131b_9bcb3712",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1003247
      },
      "writtenOn": "2023-01-13T12:06:37Z",
      "side": 1,
      "message": "Yeah, I\u0027m not following why this is a good idea to do - *especially* so in non-auto-specific logic...\n\nWhat specific setsockopt(s) requires net_raw?\nIs there a design doc / discussion for this somewhere?\nI tried following the link to the bug, but that doesn\u0027t seem useful...\nWhy can\u0027t this use normal Android access permission model for binding to networks?\n\nAlso why does this also allow net_admin?\n(does this mean a separate neverallow for net_admin should be added?)",
      "parentUuid": "9917eb6c_d9fa0ed8",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02acc07e_f7ea4381",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2023-01-13T18:08:49Z",
      "side": 1,
      "message": "Yes, we only need net_raw, I can add a never allow rule for net_admin.\n\nThe reason we need this is for this CL: ag/20964735 to work. Specifically, we use the grpc\u0027s SetSocketMutator function. We need to use setsockopt(SO_BINDTODEVICE) to bind the socket fd to a specific interface.",
      "parentUuid": "e38c131b_9bcb3712",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2913926b_f246420e",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1003247
      },
      "writtenOn": "2023-01-13T18:25:03Z",
      "side": 1,
      "message": "Hah, so I happened to learn about this yesterday, due to a forward porting bug of a patch I wrote for prodkernel being incorrectly applied to 5.15, but:\n\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id\u003dc427bfec18f2190b8f4718785ee8ed2db4f84ee6\n\nnet: core: enable SO_BINDTODEVICE for non-root users\n\nWhich is in Linux ~5.6..5.7 so in Pixel 6+\n\n---\n\nNow a separate question is whether we\u0027re actually OK with this change for Android... since it might break some network binding assumptions.",
      "parentUuid": "02acc07e_f7ea4381",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9644254d_6bbff9fe",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1003247
      },
      "writtenOn": "2023-01-13T18:29:32Z",
      "side": 1,
      "message": "btw. I expect you should fix grpc to use android ndk network socket binding primitives.",
      "parentUuid": "2913926b_f246420e",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32524175_38054584",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2023-01-13T18:35:07Z",
      "side": 1,
      "message": "Can you point me to the ndk network socket binding primitives? Do you mean if I use that I do not need NET_RAW permission?",
      "parentUuid": "9644254d_6bbff9fe",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e6d4464_463c5f4d",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1003247
      },
      "writtenOn": "2023-01-13T18:54:24Z",
      "side": 1,
      "message": "https://source.corp.google.com/aosp-master/frameworks/native/include/android/multinetwork.h;l\u003d72\n\n/**\n * Set the network to be used by the given socket file descriptor.\n *\n * To clear a previous socket binding, invoke with NETWORK_UNSPECIFIED.\n *\n * This is the equivalent of: [android.net.Network#bindSocket()](https://developer.android.com/reference/android/net/Network.html#bindSocket(java.net.Socket))\n *\n * Available since API level 23.\n */\nint android_setsocknetwork(net_handle_t network, int fd) __INTRODUCED_IN(23);",
      "parentUuid": "32524175_38054584",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed1860e6_9b0055b1",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1135107
      },
      "writtenOn": "2023-01-19T19:00:54Z",
      "side": 1,
      "message": "This doesn\u0027t require any changes in gRPC, just the same socket mutator as in http://ag/20964735\n\nThe tedious (as in: more code) part is that it requires selecting a network and not picking via interface name. The benefit would be making this more reliable on Android, probably.",
      "parentUuid": "9e6d4464_463c5f4d",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74969a23_f97b21ac",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2023-01-19T19:16:16Z",
      "side": 1,
      "message": "Yes, that API is helpful. The issue here is how to get the network_handle_t which requires java code. We do not have java code in remote access HAL so it would need to be passed down from remote access service.",
      "parentUuid": "ed1860e6_9b0055b1",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0088212b_5c9c47c9",
        "filename": "public/hal_neverallows.te",
        "patchSetId": 1
      },
      "lineNbr": 7,
      "author": {
        "id": 1135107
      },
      "writtenOn": "2023-01-19T19:24:29Z",
      "side": 1,
      "message": "Ouch, seriously? This will be a problem with our other project!",
      "parentUuid": "74969a23_f97b21ac",
      "range": {
        "startLine": 7,
        "startChar": 3,
        "endLine": 7,
        "endChar": 26
      },
      "revId": "3b6ab9de379bdf8c8d36f0b19117d0d762c52c8b",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}